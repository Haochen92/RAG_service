query_id,query_text,chunk_id,chunk_text,score,rank,relevance
eval2_q001,How do I apply a global theme override so it affects Mantine components across my app?,968bb896-1574-4c10-90c4-cde0f0946fd0,"Topic: MantineProvider
Section: theme

Pass [theme object](https://mantine.dev/theming/theme-object) override to `theme` prop. It will be merged with the default
theme and used in all components.  
```tsx
import { createTheme, MantineProvider } from '@mantine/core';

const theme = createTheme({
fontFamily: 'Open Sans, sans-serif',
primaryColor: 'cyan',
});

function Demo() {
return (
<MantineProvider theme={theme}>
{/* Your app here */}
</MantineProvider>
);
}
```",0.015527202696196438,1,2
eval2_q001,How do I apply a global theme override so it affects Mantine components across my app?,299c2690-956e-4dfb-87fe-266a7fc85ab2,"Topic: GettingStarted
Section: Get started without framework

const theme = createTheme({
/** Put your mantine theme override here */
});

function Demo() {
return (
<MantineProvider theme={theme}>
{/* Your app here */}
</MantineProvider>
);
}
```  
If your application has server side rendering, add [ColorSchemeScript](https://mantine.dev/theming/color-schemes)
to the `<head />` of your application and spread `mantineHtmlProps` on the `<html />` element
to [avoid seeing a hydration warning](https://help.mantine.dev/q/color-scheme-hydration-warning):  
```tsx
import { ColorSchemeScript, mantineHtmlProps } from '@mantine/core';

function Demo() {
return (
<html lang=""en"" {...mantineHtmlProps}>
<head>
<meta charSet=""UTF-8"" />
<meta
name=""viewport""
content=""width=device-width, initial-scale=1.0""
/>
<title>My awesome app</title>

<ColorSchemeScript />
</head>
<body>{/* Your app here */}</body>
</html>
);
}
```  
All set! You can now use Mantine components in your application.",0.015058876811594204,2,2
eval2_q001,How do I apply a global theme override so it affects Mantine components across my app?,9305c813-be5e-489e-8138-c7051217c39e,"Topic: ThemeObject
Section: Store theme override object in a variable

To store theme override object in a variable, use `createTheme` function:  
```tsx
import { createTheme, MantineProvider } from '@mantine/core';

const myTheme = createTheme({
primaryColor: 'orange',
defaultRadius: 0,
});

function Demo() {
return (
<MantineProvider theme={myTheme}>
{/* Your app here */}
</MantineProvider>
);
}
```",0.01482213438735178,3,2
eval2_q001,How do I apply a global theme override so it affects Mantine components across my app?,092378dc-9185-4fbf-8afb-cb7ea1ce589a,"Topic: General
Section: How can I customize colors with theme?

You can define custom colors in the [theme object](https://mantine.dev/theming/theme-object).  
```tsx
import { createTheme, MantineProvider } from '@mantine/core';

const theme = createTheme({
colors: {
sepia: [
'#F4ECD8',
'#EAD8B7',
'#DFC29A',
'#D4AC7E',
'#C99862',
'#BD8447',
'#B2702D',
'#A55C15',
'#924908',
'#7A3704',
],
},
});

function Demo() {
return (
<MantineProvider theme={theme}>
<App />
</MantineProvider>
);
}
```  
Then you can reference these values in components and `.css` files:  
```scss
body {
background-color: var(--mantine-color-sepia-0);
color: var(--mantine-color-sepia-9);
}
```",0.013891568589619912,4,1
eval2_q001,How do I apply a global theme override so it affects Mantine components across my app?,e08a2d85-8a49-4d0f-92f3-2e9552bade60,"Topic: General
Section: Is there anything I need to do on my side to make my app accessible?

Of course! While Mantine components provide a solid foundation for accessible applications,
there are still things that you need to do to ensure that your app is fully accessible.
If the component requires props to make it accessible, it will be mentioned in the component
documentation.  
Things to look out for while building accessible applications:  
* Use semantic HTML elements where possible: use `<button>` for buttons, `<a>` for links, etc.
* Provide proper labels for inputs
* Use `aria-label` attribute where necessary
* Ensure that your app is fully navigable with a keyboard
* Ensure that all elements in your app have proper color contrast
* And more  
If you are interested in learning more about web accessibility, you can check out these
free courses:  
* [Web Accessibility on Udacity](https://www.udacity.com/course/web-accessibility--ud891)
* [Develop Accessible Web Apps with React on Egghead](https://egghead.io/courses/develop-accessible-web-apps-with-react)",0.00819672131147541,5,0
eval2_q001,How do I apply a global theme override so it affects Mantine components across my app?,f6744b6a-c548-4adb-9e77-a5a5fcd7802e,"Topic: ThemeObject
Section: Usage

To customize theme, pass theme override object to [MantineProvider](https://mantine.dev/theming/mantine-provider/) `theme` prop.
Theme override will be deeply merged with the default theme.  
```tsx
import { createTheme, MantineProvider } from '@mantine/core';

const theme = createTheme({
colors: {
// Add your color
deepBlue: [
'#eef3ff',
'#dce4f5',
'#b9c7e2',
'#94a8d0',
'#748dc1',
'#5f7cb8',
'#5474b4',
'#44639f',
'#39588f',
'#2d4b81',
],
// or replace default theme color
blue: [
'#eef3ff',
'#dee2f2',
'#bdc2de',
'#98a0ca',
'#7a84ba',
'#6672b0',
'#5c68ac',
'#4c5897',
'#424e88',
'#364379',
],
},

shadows: {
md: '1px 1px 3px rgba(0, 0, 0, .25)',
xl: '5px 5px 3px rgba(0, 0, 0, .25)',
},

headings: {
fontFamily: 'Roboto, sans-serif',
sizes: {
h1: { fontSize: '36px' },
},
},
});

function Demo() {
return (
<MantineProvider theme={theme}>
{/* Your app here */}
</MantineProvider>
);
}
```",0.00819672131147541,6,3
eval2_q001,How do I apply a global theme override so it affects Mantine components across my app?,66f79561-fe33-49e5-b19d-d6a37810a27a,"Topic: General
Section: Overview

# My styles are overridden by Mantine components styles, what should I do?
Learn how to use CSS layers to control styles order and prevent Mantine components from overriding your styles",0.008064516129032258,7,0
eval2_q001,How do I apply a global theme override so it affects Mantine components across my app?,caa2e8d2-fb07-4323-a5cd-75122832986a,"Topic: ThemeObject
Section: Access theme outside of components

To access theme outside of components, you need to create a full theme object
(your theme override merged with the default theme).  
```tsx
// theme.ts
import {
createTheme,
DEFAULT_THEME,
mergeMantineTheme,
} from '@mantine/core';

const themeOverride = createTheme({
primaryColor: 'orange',
defaultRadius: 0,
});

export const theme = mergeMantineTheme(DEFAULT_THEME, themeOverride);
```  
Then you will be able to import it anywhere in your application:  
```tsx
import { theme } from './theme';
```",0.007936507936507936,8,1
eval2_q001,How do I apply a global theme override so it affects Mantine components across my app?,fc674ca7-1ad8-49fd-8515-1253ee3f5e72,"Topic: General
Section: Overview

# How can I apply styles to all Mantine components?
Learn how to use attribute selector to apply styles to all Mantine components",0.007936507936507936,9,0
eval2_q001,How do I apply a global theme override so it affects Mantine components across my app?,0675135d-5dc6-4456-890a-0e9e3de3d521,"Topic: MantineProvider
Section: Usage

```tsx
import { createTheme, MantineProvider } from '@mantine/core';

const theme = createTheme({
/** Your theme override here */
});

function Demo() {
return (
<MantineProvider theme={theme}>
{/* Your app here */}
</MantineProvider>
);
}
```",0.0078125,10,2
eval2_q001,How do I apply a global theme override so it affects Mantine components across my app?,12002107-37e8-46ad-9cd2-ee751075eaa9,"Topic: General
Section: I want to add a custom color scheme. Can I do that?

No, Mantine does not support custom color schemes. If you attempt to do that,
most of the components will have broken styles. Instead of applying a custom
color scheme, customize colors with [theme](https://mantine.dev/theming/theme-object/).",0.007692307692307693,11,0
eval2_q001,How do I apply a global theme override so it affects Mantine components across my app?,abe16395-6325-49d4-a307-132341bb45ab,"Topic: GlobalStyles
Section: Add global styles in your application

It is recommended to use [CSS modules](https://mantine.dev/styles/css-modules) to apply styles to Mantine components
with `className` prop or with [Styles API](https://mantine.dev/styles/styles-api). CSS modules files names usually
end with `.module.css`, if you want to add global styles to your application, create a file with
`.css` extension but without `.module` part, for example `global.css`.  
In global `.css` files you can reference all Mantine [CSS variables](https://mantine.dev/styles/css-variables) and
change styles of `<body />`, `:root` and other elements. For example, to change body background-color:  
```css
body {
background-color: var(--mantine-color-red-filled);
}
```",0.007692307692307693,12,0
eval2_q001,How do I apply a global theme override so it affects Mantine components across my app?,ada99f74-df60-41b7-b58d-253068891b13,"Topic: General
Section: Overview

# My styles are broken with disabled JavaScript. What should I do?
Learn how to use Mantine without JavaScript enabled",0.007575757575757576,13,0
eval2_q001,How do I apply a global theme override so it affects Mantine components across my app?,4e400222-92be-4348-9bd4-4055cb0e7b3e,"Topic: Storybook
Section: Theme object

To shared [theme object](https://mantine.dev/theming/theme-object) between your application and Storybook, create
`src/theme.ts` (or any other path in your application) file with your theme override:  
```tsx
// src/theme.ts
import { createTheme } from '@mantine/core';

export const theme = createTheme({
fontFamily: 'serif',
// ... other theme override properties
});
```  
Then you will be able to use the same theme both in your application and Storybook:  
```tsx
// In your application

import { MantineProvider } from '@mantine/core';
import { theme } from './theme';

function App() {
return <MantineProvider theme={theme}>{/* ... */}</MantineProvider>;
}
```",0.007462686567164179,14,0
eval2_q001,How do I apply a global theme override so it affects Mantine components across my app?,12d83b92-d7a0-47be-883a-b0eeb981be74,"Topic: LLMDocumentation
Section: Example prompts

Here are some example prompts you can use with AI tools:  
* ""Using Mantine v8, how do I create a dark mode toggle?""
* ""Show me how to use the AppShell component with a collapsible navbar""
* ""How can I customize the theme colors in MantineProvider?""
* ""Create a form with validation using Mantine's form hooks""
* ""How to align input with a button in a flex container?""",0.007352941176470588,15,0
eval2_q001,How do I apply a global theme override so it affects Mantine components across my app?,850644d6-78d5-464f-bd04-efb1eb740c74,"Topic: MantineProvider
Section: MantineProvider props

`MantineProvider` supports the following props:  
```tsx
interface MantineProviderProps {
/** Theme override object */
theme?: MantineThemeOverride;

/** Used to retrieve/set color scheme value in external storage, by default uses `window.localStorage` */
colorSchemeManager?: MantineColorSchemeManager;

/** Default color scheme value used when `colorSchemeManager` cannot retrieve value from external storage, `light` by default */
defaultColorScheme?: MantineColorScheme;

/** Forces color scheme value, if set, MantineProvider ignores `colorSchemeManager` and `defaultColorScheme` */
forceColorScheme?: 'light' | 'dark';

/** CSS selector to which CSS variables should be added, by default variables are applied to `:root` and `:host` */
cssVariablesSelector?: string;

/** Determines whether theme CSS variables should be added to given `cssVariablesSelector`, `true` by default */
withCssVariables?: boolean;

/** Determines whether CSS variables should be deduplicated: if CSS variable has the same value as in default theme, it is not added in the runtime. `true` by default. */
deduplicateCssVariables?: boolean;

/** Function to resolve root element to set `data-mantine-color-scheme` attribute, must return undefined on server, `() => document.documentElement` by default */
getRootElement?: () => HTMLElement | undefined;

/** A prefix for components static classes (for example {selector}-Text-root), `mantine` by default */
classNamesPrefix?: string;

/** Function to generate nonce attribute added to all generated `<style />` tags */
getStyleNonce?: () => string;

/** Function to generate CSS variables based on theme object */
cssVariablesResolver?: CSSVariablesResolver;

/** Determines whether components should have static classes, for example, `mantine-Button-root`. `true` by default */
withStaticClasses?: boolean;",0.007352941176470588,16,1
eval2_q001,How do I apply a global theme override so it affects Mantine components across my app?,1f837915-605a-4775-bd54-3d75e5e5626f,"Topic: DefaultProps
Section: Default props with MantineThemeProvider

You can also use `MantineThemeProvider` to define default props
for a part of your application:  
```tsx
import {
Button,
createTheme,
MantineThemeProvider,
} from '@mantine/core';

const theme = createTheme({
components: {
Button: Button.extend({
defaultProps: {
color: 'cyan',
variant: 'outline',
},
}),
},
});

function Demo() {
return (
<>
<MantineThemeProvider theme={theme}>
{/* Part of the app with theme */}
</MantineThemeProvider>

{/* Another part without theme */}
</>
);
}
```",0.007142857142857143,17,0
eval2_q001,How do I apply a global theme override so it affects Mantine components across my app?,aa8420a4-6457-4d3e-a1e8-857ad5073149,"Topic: StylesApi
Section: classNames in theme.components

You can also define `classNames` in [`theme.components`](https://mantine.dev/theming/theme-object) to apply them to all
components of a specific type:  
```tsx
import { useState } from 'react';
import {
createTheme,
MantineProvider,
TextInput,
} from '@mantine/core';
// Styles are the same as in previous example
import classes from './Demo.module.css';

const theme = createTheme({
components: {
TextInput: TextInput.extend({
classNames: {
root: classes.root,
input: classes.input,
label: classes.label,
},
}),
},
});

function Demo() {
return (
<MantineProvider theme={theme}>
{/* Your app here */}
</MantineProvider>
);
}
```",0.007142857142857143,18,0
eval2_q001,How do I apply a global theme override so it affects Mantine components across my app?,41e08fef-e4fb-4ce1-b678-0337e7899a2c,"Topic: ThemeObject
Section: Default theme

You can import default theme object from `@mantine/core` package. It includes
all theme properties with default values. When you pass theme override to
[MantineProvider](https://mantine.dev/theming/mantine-provider), it will be deeply merged with
the default theme.  
```tsx
import { DEFAULT_THEME } from '@mantine/core';
```",0.007042253521126761,19,1
eval2_q001,How do I apply a global theme override so it affects Mantine components across my app?,5cdf8b15-6457-43e0-9c22-1b7b75d8c081,"Topic: MantineProvider
Section: Overview

# MantineProvider  
`MantineProvider` provides a [theme object](https://mantine.dev/theming/theme-object) context value, manages color scheme
changes and injects [CSS variables](https://mantine.dev/styles/css-variables/). It must be rendered at the root of your
application and should be used only once.",0.006944444444444444,20,1
eval2_q001,How do I apply a global theme override so it affects Mantine components across my app?,ebe2a797-ba02-481a-a115-da5a327a2789,"Topic: General
Section: How do I know which version is the latest?

All `@mantine/*` packages have the same version, so you can check the latest
version of [@mantine/hooks package on npm](https://www.npmjs.com/package/@mantine/hooks). It
is also displayed near the Mantine logo on the [documentation home page](https://mantine.dev).  
To check the latest version of `postcss-preset-mantine` package, visit
[postcss-preset-mantine package on npm](https://www.npmjs.com/package/postcss-preset-mantine).",0.006944444444444444,21,0
eval2_q001,How do I apply a global theme override so it affects Mantine components across my app?,3a1030d0-4518-4593-a55e-0a7e4cf303be,"Topic: StylesApi
Section: Styles API selectors

Every Mantine component that supports the styles API has a set of element names that can be used to
apply styles to inner elements inside the component. For simplicity, these elements names are called
selectors in Mantine documentation. You can find selectors information under the `Styles API` tab
in a component's documentation.  
Example of [Button](https://mantine.dev/core/button) component selectors:  
<SelectorsTable data={ButtonStylesApi} component=""Button"" withTableBorder={false} fixedLayout={false} />  
You can use these selectors in `classNames` and `styles` in, both, component props and `theme.components`:  
```tsx
import { Button, createTheme, MantineProvider } from '@mantine/core';

function ClassNamesDemo() {
return (
<Button
classNames={{
root: 'my-root-class',
label: 'my-label-class',
inner: 'my-inner-class',
}}
>
Button
</Button>
);
}

function StylesDemo() {
return (
<Button
styles={{
root: { backgroundColor: 'red' },
label: { color: 'blue' },
inner: { fontSize: 20 },
}}
>
Button
</Button>
);
}

const theme = createTheme({
components: {
Button: Button.extend({
classNames: {
root: 'my-root-class',
label: 'my-label-class',
inner: 'my-inner-class',
},
styles: {
root: { backgroundColor: 'red' },
label: { color: 'blue' },
inner: { fontSize: 20 },
},
}),
},
});

function ProviderDemo() {
return (
<MantineProvider theme={theme}>
<Button>Button</Button>
</MantineProvider>
);
}
```",0.00684931506849315,22,0
eval2_q001,How do I apply a global theme override so it affects Mantine components across my app?,47d04ab4-7516-42e6-b12a-6aee0aa55d7c,"Topic: General
Section: Overview

# How can I change component color prop value depending on the color scheme?
Learn how to use CSS variables resolver to change color value depending on the color scheme  
`color` prop in all components uses Mantine [CSS variables](https://mantine.dev/styles/css-variables)
to resolve color value depending on the color scheme. You can define these variables with `virtualColor` function:  
#### Example: ColorSchemeColor  
```tsx
import { virtualColor, createTheme, MantineProvider } from '@mantine/core';

const theme = createTheme({
colors: {
primary: virtualColor({ name: 'primary', light: 'blue', dark: 'red' }),
},
});

function App() {
return (
<MantineProvider theme={theme}>
<YourApp />
</MantineProvider>
);
}
```",0.006756756756756757,23,0
eval2_q001,How do I apply a global theme override so it affects Mantine components across my app?,8e777a70-5289-4770-ad83-f206be449423,"Topic: ColorSchemes
Section: Overview

# Color schemes  
[MantineProvider](https://mantine.dev/theming/mantine-provider/) manages color scheme context in your application.
You can configure the default color scheme value with `defaultColorScheme` prop, possible values are `light`,
`dark` and `auto` (system color scheme is used). The default value is `light`.  
```tsx
import { MantineProvider } from '@mantine/core';

function Demo() {
return (
<MantineProvider defaultColorScheme=""dark"">
{/* Your app here */}
</MantineProvider>
);
}
```",0.006756756756756757,24,0
eval2_q001,How do I apply a global theme override so it affects Mantine components across my app?,27296001-21e0-4297-a2c0-1ccd2f9135c4,"Topic: DefaultProps
Section: Overview

# Default props  
You can define default props for every Mantine component by setting `theme.components`.
These props will be used by default by all components of your application unless they are overridden by component props:  
#### Example: defaultProps  
```tsx
import { MantineProvider, Button, Group, createTheme } from '@mantine/core';

const theme = createTheme({
components: {
Button: Button.extend({
defaultProps: {
color: 'cyan',
variant: 'outline',
},
}),
},
});

function Demo() {
return (
<MantineProvider theme={theme}>
<Group>
<Button>Default button</Button>
<Button color=""red"" variant=""filled"">
Button with props
</Button>
</Group>
</MantineProvider>
);
}
```",0.006666666666666667,25,1
eval2_q001,How do I apply a global theme override so it affects Mantine components across my app?,83e5a116-3c93-4ddc-ad9a-0e2ed3a79b43,"Topic: General
Section: Overview

# MantineProvider was not found in component tree. What should I do?
Learn how to resolve MantineProvider issues  
<ErrorMessage error=""@mantine/core: MantineProvider was not found in component tree, make sure you have it in your app."" />  
The error above occurs in the following cases:  
* You do not have `MantineProvider` in your app at all
* You are rendering Mantine components outside of `MantineProvider` context
* You have different versions of `@mantine/*` packages in your application.
For example, you have `@mantine/core@7.0.0` and `@mantine/dates@7.1.0` installed.
* There was an issue during packages installation. Usually this happens with pnpm.
* Your app has multiple instances of `@mantine/core` package in the bundle. This may
happen if your project is a monorepo and you have multiple node\_modules folders.  
Steps to resolve the issue:  
* Make sure that you have `MantineProvider` in your app and it wraps all Mantine components.
* Make sure that you have only one version of `@mantine/core` in your app. If you are using
monorepo, make sure all packages depend on the same version of `@mantine/core`.
* Reinstall dependencies by removing `node_modules` folder and running `npm install` or
`yarn install` again.
* If you still have issues, you can use [one of the official templates](https://mantine.dev/getting-started/#get-started-with-a-template) as reference.",0.006666666666666667,26,0
eval2_q002,How can I set a global default border radius so most components use it automatically?,48a77532-8dcb-4260-822d-daedc111c6ec,"Topic: ThemeObject
Section: defaultRadius

`theme.defaultRadius` controls the default `border-radius` property in most components, for example, [Button](https://mantine.dev/core/button) or [TextInput](https://mantine.dev/core/text-input).
You can set to either one of the values from `theme.radius` or a number/string to use exact value. Note that numbers are treated as pixels, but
converted to rem. For example, `theme.defaultRadius: 4` will be converted to `0.25rem`.
You can learn more about rem conversion in the [rem units guide](https://mantine.dev/styles/rem).  
#### Example: defaultRadiusConfigurator  
```tsx
import { MantineProvider, TextInput, Button } from '@mantine/core';

function Demo() {
return (
<MantineProvider theme={{ defaultRadius: '' }}>
<Button fullWidth>Button with defaultRadius</Button>
<TextInput mt=""sm"" label=""TextInput with defaultRadius"" placeholder=""TextInput with default radius"" />
</MantineProvider>
);
}
```",0.016009221311475412,1,3
eval2_q002,How can I set a global default border radius so most components use it automatically?,9f468227-4236-4bb9-aedb-a02dfada2b8c,"Topic: CssVariables
Section: Border radius variables

Mantine components that support `radius` prop use border radius variables to control border radius.
The following CSS variables are defined based on `theme.radius`:  
<CssVariablesGroup
data={[
{
variable: '--mantine-radius-xs',
defaultValue: '0.125rem (2px)',
},
{
variable: '--mantine-radius-sm',
defaultValue: '0.25rem (4px)',
},
{
variable: '--mantine-radius-md',
defaultValue: '0.5rem (8px)',
},
{
variable: '--mantine-radius-lg',
defaultValue: '1rem (16px)',
},
{
variable: '--mantine-radius-xl',
defaultValue: '2rem (32px)',
},
]}
/>  
Additionally, `--mantine-radius-default` variable is defined based on `theme.defaultRadius`
value. If `radius` prop on components is not set explicitly, `--mantine-radius-default` is used instead.  
To define custom border radius values, use `theme.radius` and `theme.defaultRadius` properties:  
```tsx
import { createTheme } from '@mantine/core';

const theme = createTheme({
defaultRadius: 'sm',
radius: {
xs: '0.25rem',
sm: '0.5rem',
md: '1rem',
lg: '2rem',
xl: '3rem',
},
});
```",0.015417457305502846,2,2
eval2_q002,How can I set a global default border radius so most components use it automatically?,a6b5a798-94d7-4e79-bd7b-e674c5637c11,"Topic: Paper
Section: Polymorphic component

function Demo() {
return <Paper component=""button"" />;
}
```  
You can also use components in component prop, for example, Next.js Link:  
```tsx
import Link from 'next/link';
import { Paper } from '@mantine/core';

function Demo() {
return <Paper component={Link} href=""/"" />;
}
```  
**Polymorphic components with TypeScript**  
Note that polymorphic components props types are different from regular components – they do not extend HTML element props of the default element. For example, PaperProps does not extend React.ComponentPropsWithoutRef<'div'> although div is the default element.  
If you want to create a wrapper for a polymorphic component that is not polymorphic (does not support component prop), then your component props interface should extend HTML element props.  
#### Props  
| Prop | Type | Default | Description |
|------|------|---------|-------------|
| radius | MantineRadius | number | - | Key of <code>theme.radius</code> or any valid CSS value to set border-radius, numbers are converted to rem |
| shadow | MantineShadow | - | Key of <code>theme.shadows</code> or any valid CSS value to set <code>box-shadow</code> |
| withBorder | boolean | - | Adds border to the root element |  
#### Styles API  
Paper component supports Styles API. With Styles API, you can customize styles of any inner element. Follow the documentation to learn how to use CSS modules, CSS variables and inline styles to get full control over component styles.  
**Paper selectors**  
| Selector | Static selector | Description |
|----------|----------------|-------------|
| root | .mantine-Paper-root | Root element |  
**Paper CSS variables**  
| Selector | Variable | Description |
|----------|----------|-------------|
| root | --paper-radius | Controls `border-radius` |
| root | --paper-shadow | Controls `box-shadow` |  
**Paper data attributes**  
| Selector | Attribute | Condition | Value |
|----------|-----------|-----------|-------|
| root | data-with-border | - | - |",0.014938684503901897,3,0
eval2_q002,How can I set a global default border radius so most components use it automatically?,10efcc17-9248-40a0-9d2b-1ed2d15fd736,"Topic: CSSFilesList
Section: Global styles

All Mantine components depend on global styles, you need to import them before
all other styles:  
* `baseline.css` – a minimal CSS reset, sets `box-sizing: border-box` and changes font properties
* `default-css-variables.css` – contains all CSS variables generated from the default theme
* `global.css` – global classes used in Mantine components  
```tsx
import '@mantine/core/styles/baseline.css';
import '@mantine/core/styles/default-css-variables.css';
import '@mantine/core/styles/global.css';
```",0.014785823005001086,4,0
eval2_q002,How can I set a global default border radius so most components use it automatically?,2548c6eb-968e-4602-88d0-becea7bf8b4b,"Topic: BackgroundImage
Section: Polymorphic component

BackgroundImage is a polymorphic component – its default root element is div, but it can be changed to any other element or component with component prop:  
```tsx
import { BackgroundImage } from '@mantine/core';

function Demo() {
return <BackgroundImage component=""button"" />;
}
```  
**Polymorphic components with TypeScript**  
Note that polymorphic components props types are different from regular components – they do not extend HTML element props of the default element. For example, BackgroundImageProps does not extend React.ComponentPropsWithoutRef<'div'> although div is the default element.  
If you want to create a wrapper for a polymorphic component that is not polymorphic (does not support component prop), then your component props interface should extend HTML element props.  
#### Props  
| Prop | Type | Default | Description |
|------|------|---------|-------------|
| radius | MantineRadius | number | - | Key of <code>theme.radius</code> or any valid CSS value to set border-radius, numbers are converted to rem |
| src | string | required | Image url |  
#### Styles API  
BackgroundImage component supports Styles API. With Styles API, you can customize styles of any inner element. Follow the documentation to learn how to use CSS modules, CSS variables and inline styles to get full control over component styles.  
**BackgroundImage selectors**  
| Selector | Static selector | Description |
|----------|----------------|-------------|
| root | .mantine-BackgroundImage-root | Root element |  
**BackgroundImage CSS variables**  
| Selector | Variable | Description |
|----------|----------|-------------|
| root | --bi-radius | Controls `border-radius` |",0.00819672131147541,5,0
eval2_q002,How can I set a global default border radius so most components use it automatically?,617a8268-2f74-4d60-bafd-671de07d6720,"Topic: ThemeObject
Section: Overview

/** Function to resolve colors based on variant.
*  Can be used to deeply customize how colors are applied to `Button`, `ActionIcon`, `ThemeIcon`
*  and other components that use colors from theme.
* */
variantColorResolver: VariantColorsResolver;

/** Determines whether text color must be changed based on the given `color` prop in filled variant
*  For example, if you pass `color=""blue.1""` to Button component, text color will be changed to `var(--mantine-color-black)`
*  Default value – `false`
* */
autoContrast: boolean;

/** Determines which luminance value is used to determine if text color should be light or dark.
*  Used only if `theme.autoContrast` is set to `true`.
*  Default value is `0.3`
* */
luminanceThreshold: number;

/** font-family used in all components, system fonts by default */
fontFamily: string;

/** Monospace font-family, used in code and other similar components, system fonts by default  */
fontFamilyMonospace: string;

/** Controls various styles of h1-h6 elements, used in Typography and Title components */
headings: {
fontFamily: string;
fontWeight: string;
textWrap: 'wrap' | 'nowrap' | 'balance' | 'pretty' | 'stable';
sizes: {
h1: HeadingStyle;
h2: HeadingStyle;
h3: HeadingStyle;
h4: HeadingStyle;
h5: HeadingStyle;
h6: HeadingStyle;
};
};

/** Object of values that are used to set `border-radius` in all components that support it */
radius: MantineRadiusValues;

/** Key of `theme.radius` or any valid CSS value. Default `border-radius` used by most components */
defaultRadius: MantineRadius;

/** Object of values that are used to set various CSS properties that control spacing between elements */
spacing: MantineSpacingValues;

/** Object of values that are used to control `font-size` property in all components */
fontSizes: MantineFontSizesValues;

/** Object of values that are used to control `line-height` property in `Text` component */
lineHeights: MantineLineHeightValues;",0.008064516129032258,6,0
eval2_q002,How can I set a global default border radius so most components use it automatically?,27296001-21e0-4297-a2c0-1ccd2f9135c4,"Topic: DefaultProps
Section: Overview

# Default props  
You can define default props for every Mantine component by setting `theme.components`.
These props will be used by default by all components of your application unless they are overridden by component props:  
#### Example: defaultProps  
```tsx
import { MantineProvider, Button, Group, createTheme } from '@mantine/core';

const theme = createTheme({
components: {
Button: Button.extend({
defaultProps: {
color: 'cyan',
variant: 'outline',
},
}),
},
});

function Demo() {
return (
<MantineProvider theme={theme}>
<Group>
<Button>Default button</Button>
<Button color=""red"" variant=""filled"">
Button with props
</Button>
</Group>
</MantineProvider>
);
}
```",0.007936507936507936,7,0
eval2_q002,How can I set a global default border radius so most components use it automatically?,d695b57b-b87a-4ca4-9c82-53b7a48e6ae0,"Topic: GlobalStyles
Section: Body and :root elements styles

`@mantine/core` package includes the following `body` and `:root` elements styles:  
```css
:root {
color-scheme: var(--mantine-color-scheme);
}

body {
font-family: var(--mantine-font-family);
font-size: var(--mantine-font-size-md);
line-height: var(--mantine-line-height);
background-color: var(--mantine-color-body);
color: var(--mantine-color-text);

-webkit-font-smoothing: var(--mantine-webkit-font-smoothing);
-moz-osx-font-smoothing: var(--mantine-moz-font-smoothing);
}
```",0.0078125,8,0
eval2_q002,How can I set a global default border radius so most components use it automatically?,6d2d42a7-b7b3-434e-acf1-2f1a2926817f,"Topic: GlobalStyles
Section: CSS reset

`@mantine/core` package includes minimal CSS reset – it includes only basic styles required for components to work
in modern browsers. If you need to support older browsers, you can additionally include [normalize.css](https://necolas.github.io/normalize.css/)
or any other CSS reset of your choice.  
```css
body {
margin: 0;
}

*,
*::before,
*::after {
box-sizing: border-box;
}

input,
button,
textarea,
select {
font: inherit;
}

button,
select {
text-transform: none;
}
```",0.007692307692307693,9,0
eval2_q002,How can I set a global default border radius so most components use it automatically?,8f0ca072-3342-4f70-9cca-41c2c8942d09,"Topic: General
Section: Can I use SegmentedControl with initial empty value?

[SegmentedControl](https://mantine.dev/core/segmented-control/) cannot be used without a value.
It is based on [FloatingIndicator](https://mantine.dev/core/floating-indicator/) and requires a value to work properly.
If neither `value` nor `defaultValue` is provided, `SegmentedControl` will automatically set first item as active.",0.007575757575757576,10,0
eval2_q002,How can I set a global default border radius so most components use it automatically?,cafedd4a-71e2-425a-8bb5-5971bd142e30,"Topic: ThemeObject
Section: defaultGradient

`theme.defaultGradient` controls the default gradient configuration for components that support `variant=""gradient""`
([Button](https://mantine.dev/core/button), [ActionIcon](https://mantine.dev/core/action-icon), [Badge](https://mantine.dev/core/badge), etc.).  
#### Example: defaultGradient  
```tsx
import { MantineProvider, createTheme, Button } from '@mantine/core';

const theme = createTheme({
defaultGradient: {
from: 'orange',
to: 'red',
deg: 45,
},
});

function Demo() {
return (
<MantineProvider theme={theme}>
<Button variant=""gradient"">Button with custom default gradient</Button>
</MantineProvider>
);
}
```",0.007575757575757576,11,0
eval2_q002,How can I set a global default border radius so most components use it automatically?,abe16395-6325-49d4-a307-132341bb45ab,"Topic: GlobalStyles
Section: Add global styles in your application

It is recommended to use [CSS modules](https://mantine.dev/styles/css-modules) to apply styles to Mantine components
with `className` prop or with [Styles API](https://mantine.dev/styles/styles-api). CSS modules files names usually
end with `.module.css`, if you want to add global styles to your application, create a file with
`.css` extension but without `.module` part, for example `global.css`.  
In global `.css` files you can reference all Mantine [CSS variables](https://mantine.dev/styles/css-variables) and
change styles of `<body />`, `:root` and other elements. For example, to change body background-color:  
```css
body {
background-color: var(--mantine-color-red-filled);
}
```",0.007462686567164179,12,0
eval2_q002,How can I set a global default border radius so most components use it automatically?,cfa908cf-8382-442f-a0c8-17903de6fca0,"Topic: GlobalStyles
Section: Overview

# Global styles  
`@mantine/core` package includes some global styles that are required for components to work correctly.
If you override these styles, some components might not work as expected.  
Global styles are automatically imported with:  
```tsx
import '@mantine/core/styles.css';
```  
If you want to import styles [per component](https://mantine.dev/styles/css-files-list), you need to import all global
styles manually:  
```tsx
import '@mantine/core/styles/baseline.css';
import '@mantine/core/styles/default-css-variables.css';
import '@mantine/core/styles/global.css';
```",0.007462686567164179,13,0
eval2_q002,How can I set a global default border radius so most components use it automatically?,107cdcf9-62f2-4140-9600-99225ae69921,"Topic: StyleProp
Section: Define CSS variables in style prop

You can define CSS variables in the style prop. Note that it only works with Mantine components:  
```tsx
import { Box } from '@mantine/core';

function Demo() {
return (
<Box
style={{ '--radius': '0.5rem', borderRadius: 'var(--radius)' }}
/>
);
}
```",0.007352941176470588,14,0
eval2_q002,How can I set a global default border radius so most components use it automatically?,6a779d28-f558-45e4-b43b-ca0b96efd5fd,"Topic: General
Section: How should I decide which library to use?

Go through the documentation and examples of each library, try to build something with them,
and decide which one fits your needs better.
Mantine, as well as other libraries, provides a lot of examples and documentation,
so you can make an informed decision based on that.",0.007246376811594203,15,0
eval2_q002,How can I set a global default border radius so most components use it automatically?,cb145096-7da4-4f61-ab88-512ad848a30e,"Topic: Image
Section: Usage with Next.js Image

`Image` component is a [polymorphic component](https://mantine.dev/guides/polymorphic), its root element can be changed with `component` prop.
You can use it with `next/image` and other similar components.  
```tsx
import NextImage from 'next/image';
import { Image } from '@mantine/core';
import myImage from './my-image.jpg';

function Demo() {
return <Image component={NextImage} src={myImage} alt=""My image"" />;
}
```  
#### Props  
| Prop | Type | Default | Description |
|------|------|---------|-------------|
| fallbackSrc | string | - | Image url used as a fallback if the image cannot be loaded |
| fit | ObjectFit | - | Controls <code>object-fit</code> style |
| onError | (event: SyntheticEvent<HTMLImageElement, Event>) => void | - | Called when image fails to load |
| radius | MantineRadius | number | - | Key of <code>theme.radius</code> or any valid CSS value to set <code>border-radius</code> |
| src | any | - | Image url |  
#### Styles API  
Image component supports Styles API. With Styles API, you can customize styles of any inner element. Follow the documentation to learn how to use CSS modules, CSS variables and inline styles to get full control over component styles.  
**Image selectors**  
| Selector | Static selector | Description |
|----------|----------------|-------------|
| root | .mantine-Image-root | Root element |  
**Image CSS variables**  
| Selector | Variable | Description |
|----------|----------|-------------|
| root | --image-object-fit | Controls `object-fit` property |
| root | --image-radius | Controls `border-radius` property |  
**Image data attributes**  
| Selector | Attribute | Condition | Value |
|----------|-----------|-----------|-------|
| root | data-fallback | Image failed to load | - |",0.007142857142857143,16,0
eval2_q002,How can I set a global default border radius so most components use it automatically?,ed39c2bd-fc79-4419-a05a-713b6a723f23,"Topic: Rem
Section: rem units

All Mantine components use `rem` units to apply size styles (`margin`, `padding`, `width`, etc.).
By default, `1rem` is considered to be `16px` as it is a default setting in most browsers.
All components scale based on the user's browser font-size settings or font-size of `html`/`:root`.  
#### Example: remSlider  
```tsx
import { Slider } from '@mantine/core';

function Demo() {
return (
<Slider
defaultValue={100}
min={70}
max={130}
onChange={(value) => {
document.documentElement.style.fontSize = `${value}%`;
}}
/>
);
}
```",0.007142857142857143,17,0
eval2_q002,How can I set a global default border radius so most components use it automatically?,0c1b3056-616a-4197-be68-5bd91cea9d5c,"Topic: General
Section: I prefer a third-party styles solution, can I use Mantine with it?

All Mantine components are fully compatible with any third-party styling solution and native CSS.
There are two main strategies to apply styles with a third-party library:  
* `className`, `classNames`, `style` and `styles` props
* with static selectors, for example `.mantine-Text-root`  
Example of applying styles with a utility CSS library:  
```tsx
import { TextInput } from '@mantine/core';

function Demo() {
return (
<TextInput
classNames={{
root: 'mt-4',
input: 'bg-red-500 text-white',
}}
/>
);
}
```  
Example of applying styles with global CSS:  
```css
/* styles.css */

/* Note that these styles are not scoped and
will be applied to all TextInput components */
.mantine-TextInput-root {
margin-top: 0.8rem;
}

.mantine-TextInput-input {
background-color: var(--mantine-color-red-filled);
color: var(--mantine-color-white);
}
```  
You can combine both approaches to achieve desired results, for example,
`@emotion/styled` and `styled-components` packages will pass `className` prop to
a given component, and you can use static selectors to style inner elements:  
```tsx
import styled from '@emotion/styled';
import { Slider } from '@mantine/core';

const StyledSlider = styled(Slider)`
& .mantine-Slider-bar {
background-color: var(--mantine-color-pink-5);
}

& .mantine-Slider-thumb {
border-color: var(--mantine-color-pink-5);
background-color: white;
width: 1.5rem;
height: 1.5rem;
}
`;

function Demo() {
return <StyledSlider defaultValue={40} />;
}
```",0.007042253521126761,18,0
eval2_q002,How can I set a global default border radius so most components use it automatically?,e9c6babf-0d01-4cf7-a80e-e4b0ff365b82,"Topic: Badge
Section: Rounded

Set `circle` prop, to reduce horizontal padding and make badge width equal to its height:  
#### Example: rounded  
```tsx
import { Badge, Group } from '@mantine/core';

function Demo() {
return (
<Group>
<Badge size=""xs"" circle>
1
</Badge>
<Badge size=""sm"" circle>
7
</Badge>
<Badge size=""md"" circle>
9
</Badge>
<Badge size=""lg"" circle>
3
</Badge>
<Badge size=""xl"" circle>
8
</Badge>
</Group>
);
}
```",0.007042253521126761,19,0
eval2_q002,How can I set a global default border radius so most components use it automatically?,5d6d8375-bc91-44cc-a34b-00414bd75517,"Topic: SixToSeven
Section: Global styles

`Global` component and global styles on theme are not available in 7.0. Instead,
create a global stylesheet (`.css` file) and import it in your application entry point.  
```tsx
// 6.x
import { Global } from '@mantine/core';

function Demo() {
return (
<Global
styles={(theme) => ({
'*, *::before, *::after': {
boxSizing: 'border-box',
},

body: {
backgroundColor:
theme.colorScheme === 'dark'
? theme.colors.dark[7]
: theme.white,
color:
theme.colorScheme === 'dark'
? theme.colors.dark[0]
: theme.black,
lineHeight: theme.lineHeight,
},

'.your-class': {
backgroundColor: 'red',
},

'#your-id > [data-active]': {
backgroundColor: 'pink',
},
})}
/>
);
}
```  
```scss
/* 7.0 */
/* src/index.css */
*,
*::before,
*::after {
box-sizing: border-box;
}

body {
background-color: light-dark(
var(--mantine-color-white),
var(--mantine-color-dark-7)
);
color: light-dark(
var(--mantine-color-black),
var(--mantine-color-white)
);
line-height: var(--mantine-line-height);
}

.your-class {
background-color: red;
}

#your-id > [data-active] {
background-color: pink;
}
```",0.006944444444444444,20,0
eval2_q002,How can I set a global default border radius so most components use it automatically?,7b6fa433-4234-4c38-a179-244c389f74a6,"Topic: useFocusReturn
Section: Usage

`use-focus-return` automatically returns focus to the last focused element when a given condition is met.
For example, it is used in [Modal](https://mantine.dev/core/modal/) component to restore focus after the modal was closed.  
Close the modal with the `Escape` key and see how focus returns to the button after the modal closes:  
#### Example: usage  
```tsx
import { useDisclosure } from '@mantine/hooks';
import { Modal, Button } from '@mantine/core';

function Demo() {
const [opened, { open, close }] = useDisclosure(false);

return (
<>
<Modal opened={opened} onClose={close} title=""Authentication"">
{/* Modal content */}
</Modal>

<Button variant=""default"" onClick={open}>
Open modal
</Button>
</>
);
}
```  
In most cases, you should use this hook with [use-focus-trap](https://mantine.dev/hooks/use-focus-trap/).  
```tsx
import { useFocusReturn } from '@mantine/hooks';

useFocusReturn({
// Is region with focus trap active?
// When it activates hook saves document.activeElement to the internal state
// and focuses this element once focus trap is deactivated
opened: false,

// Determines whether focus should be returned automatically, true by default
shouldReturnFocus: true,
});
```  
If `shouldReturnFocus` option is set to `false` you can call returned function to focus last active element:  
```tsx
import { useFocusReturn } from '@mantine/hooks';

const returnFocus = useFocusReturn({
opened: false,
shouldReturnFocus: false,
});

// ... later
returnFocus();
```",0.006944444444444444,21,0
eval2_q002,How can I set a global default border radius so most components use it automatically?,5b49e9c6-edcc-4800-851c-7033c45c45bb,"Topic: General
Section: Overview

# How can I test Modal/Drawer/Popover components?
Learn how to use react-testing-library to test components that use portals and transitions.",0.00684931506849315,22,0
eval2_q002,How can I set a global default border radius so most components use it automatically?,6bcd1856-5246-4913-a7d5-a0acdbf82f30,"Topic: Rem
Section: rem units scaling

If you want to change font-size of `:root`/`html` element and preserve Mantine components sizes,
set `scale` on [theme](https://mantine.dev/theming/theme-object) to the value of `1 / htmlFontSize`.  
For example, if you set `html` font-size to `10px` and want to scale Mantine components accordingly, you need
to set `scale` to `1 / (10 / 16)` (16 – default font-size) = `1 / 0.625` = `1.6`:  
```css
:root {
font-size: 10px;
}
```  
```tsx
import { createTheme, MantineProvider } from '@mantine/core';

const theme = createTheme({
scale: 1.6,
});

function Demo() {
return (
<MantineProvider theme={theme}>
{/* Your app here */}
</MantineProvider>
);
}
```",0.006756756756756757,23,0
eval2_q002,How can I set a global default border radius so most components use it automatically?,a6aad0fb-caca-484a-8fd5-fb5b27b0cdd4,"Topic: General
Section: Overview

# How can I test Select/MultiSelect components?
Learn how to use react-testing-library to test Select and MultiSelect components.",0.006756756756756757,24,0
eval2_q002,How can I set a global default border radius so most components use it automatically?,9e282d9d-c77e-4567-8474-34e589adb62e,"Topic: StylesOverview
Section: Component specific props

Most of the components provide props that allow you to customize their styles. For example,
[Button](https://mantine.dev/core/button/) component has `color`, `variant`, `size` and `radius` props that control its
appearance:  
#### Example: configurator  
```tsx
import { Button } from '@mantine/core';

function Demo() {
return <Button>Button</Button>;
}
```  
These props usually control multiple CSS properties, for example `color` and variant props control `color`,
`background-color` and `border` properties. In most cases, changing components props is the most optimal way to customize Mantine components.",0.006666666666666667,25,0
eval2_q002,How can I set a global default border radius so most components use it automatically?,fc674ca7-1ad8-49fd-8515-1253ee3f5e72,"Topic: General
Section: Overview

# How can I apply styles to all Mantine components?
Learn how to use attribute selector to apply styles to all Mantine components",0.006666666666666667,26,0
eval2_q004,How can I define and use a new Button style variant via theming?,3aa175cc-28ca-480e-8f24-8b0c26b39c85,"Topic: Button
Section: Custom variants

To add new `Button` variants, use [data-variant](https://mantine.dev/styles/variants-sizes) attribute.
Usually new variants are added on [theme](https://mantine.dev/theming/theme-object), this way they are
available in all `Button` components in your application.  
#### Example: customVariant  
```tsx
// Demo.tsx
import { Group, Button, MantineProvider, createTheme } from '@mantine/core';
import classes from './Demo.module.css';

const theme = createTheme({
components: {
Button: Button.extend({
classNames: classes,
}),
},
});

function Demo() {
return (
<MantineProvider theme={theme}>
<Group>
<Button variant=""danger"">Danger variant</Button>
<Button variant=""primary"">Primary variant</Button>
</Group>
</MantineProvider>
);
}

// Demo.module.css
.root {
&[data-variant='danger'] {
background-color: var(--mantine-color-red-9);
color: var(--mantine-color-red-0);
}

&[data-variant='primary'] {
background: linear-gradient(45deg, #4b6cb7 10%, #253b67 90%);
color: var(--mantine-color-white);
border-width: 0;
}
}
```",0.016009221311475412,1,3
eval2_q004,How can I define and use a new Button style variant via theming?,0c24360d-0d9d-422c-97b3-c29d21939251,"Topic: VariantsAndSizes
Section: Custom variants types

You can define types for custom variants by creating `mantine.d.ts` file
in your project and extending `{x}Props` interface with the new variant type.  
Example of adding custom variant type to [Button](https://mantine.dev/core/button) component:  
```tsx
import { ButtonVariant, MantineSize } from '@mantine/core';

type ExtendedButtonVariant = ButtonVariant | 'contrast' | 'radial-gradient';

declare module '@mantine/core' {
export interface ButtonProps {
variant?: ExtendedButtonVariant;
}
}
```",0.015549662487945998,2,1
eval2_q004,How can I define and use a new Button style variant via theming?,ca16b6ac-2802-44f1-9ca8-c859469d2212,"Topic: VariantsAndSizes
Section: variantColorResolver

[Button](https://mantine.dev/core/button), [Badge](https://mantine.dev/core/badge), [ActionIcon](https://mantine.dev/core/action-icon) and other
components support custom variants with [variantColorResolver](https://mantine.dev/theming/colors#colors-variant-resolver)
– it supports both changing colors and adding new variants. Note that `theme.variantColorResolver` is
responsible only for colors, if you need to change other properties, use `data-variant` attribute.  
#### Example: variantColorsResolver  
```tsx
import {
Button,
Group,
MantineProvider,
defaultVariantColorsResolver,
VariantColorsResolver,
parseThemeColor,
rgba,
darken,
} from '@mantine/core';

const variantColorResolver: VariantColorsResolver = (input) => {
const defaultResolvedColors = defaultVariantColorsResolver(input);
const parsedColor = parseThemeColor({
color: input.color || input.theme.primaryColor,
theme: input.theme,
});

// Override some properties for variant
if (parsedColor.isThemeColor && parsedColor.color === 'lime' && input.variant === 'filled') {
return {
...defaultResolvedColors,
color: 'var(--mantine-color-black)',
hoverColor: 'var(--mantine-color-black)',
};
}

// Completely override variant
if (input.variant === 'light') {
return {
background: rgba(parsedColor.value, 0.1),
hover: rgba(parsedColor.value, 0.15),
border: `1px solid ${parsedColor.value}`,
color: darken(parsedColor.value, 0.1),
};
}

// Add new variants support
if (input.variant === 'danger') {
return {
background: 'var(--mantine-color-red-9)',
hover: 'var(--mantine-color-red-8)',
color: 'var(--mantine-color-white)',
border: 'none',
};
}

return defaultResolvedColors;
};

function Demo() {
return (
<MantineProvider theme={{ variantColorResolver }}>
<Group>
<Button color=""lime.4"" variant=""filled"">
Lime filled button
</Button>

<Button color=""orange"" variant=""light"">
Orange light button
</Button>

<Button variant=""danger"">Danger button</Button>
</Group>
</MantineProvider>
);
}
```",0.015289449112978524,3,1
eval2_q004,How can I define and use a new Button style variant via theming?,67ee1557-0c29-4da3-b591-e5976425f250,"Topic: Button
Section: Customize variants colors

You can customize colors for `Button` and other components variants by adding
[variantColorResolver](https://mantine.dev/theming/colors#colors-variant-resolver) to your theme.  
#### Example: variantColorsResolver  
```tsx
import {
Button,
Group,
MantineProvider,
defaultVariantColorsResolver,
VariantColorsResolver,
parseThemeColor,
rgba,
darken,
} from '@mantine/core';

const variantColorResolver: VariantColorsResolver = (input) => {
const defaultResolvedColors = defaultVariantColorsResolver(input);
const parsedColor = parseThemeColor({
color: input.color || input.theme.primaryColor,
theme: input.theme,
});

// Override some properties for variant
if (parsedColor.isThemeColor && parsedColor.color === 'lime' && input.variant === 'filled') {
return {
...defaultResolvedColors,
color: 'var(--mantine-color-black)',
hoverColor: 'var(--mantine-color-black)',
};
}

// Completely override variant
if (input.variant === 'light') {
return {
background: rgba(parsedColor.value, 0.1),
hover: rgba(parsedColor.value, 0.15),
border: `1px solid ${parsedColor.value}`,
color: darken(parsedColor.value, 0.1),
};
}

// Add new variants support
if (input.variant === 'danger') {
return {
background: 'var(--mantine-color-red-9)',
hover: 'var(--mantine-color-red-8)',
color: 'var(--mantine-color-white)',
border: 'none',
};
}

return defaultResolvedColors;
};

function Demo() {
return (
<MantineProvider theme={{ variantColorResolver }}>
<Group>
<Button color=""lime.4"" variant=""filled"">
Lime filled button
</Button>

<Button color=""orange"" variant=""light"">
Orange light button
</Button>

<Button variant=""danger"">Danger button</Button>
</Group>
</MantineProvider>
);
}
```  
<AutoContrast component=""Button"" />",0.015008960573476702,4,1
eval2_q004,How can I define and use a new Button style variant via theming?,b2ad74dc-9338-4388-97d9-2f8235b59100,"Topic: VariantsAndSizes
Section: Adding custom variants

Most of Mantine components support `variant` prop, it can be used in CSS variables resolver,
and it is also exposed as `data-variant=""{value}""` attribute on the root element of the component.
The easiest way to add custom variants is to add styles that use `[data-variant=""{value}""]`.  
Example of adding a new variant to the [Input](https://mantine.dev/core/input) component:  
* `underline` variant styles are added
* `filled` variant is a default variant – you do not need to define any additional styles for it  
#### Example: customVariant  
```tsx
// Demo.tsx
import { Input, MantineProvider, createTheme } from '@mantine/core';
import classes from './Demo.module.css';

// It is better to add new variants in theme.components
// This way you will be able to use them in anywhere in the app
const theme = createTheme({
components: {
Input: Input.extend({ classNames: classes }),
}
});

function Demo() {
return (
<MantineProvider theme={theme}>
<Input variant=""underline"" placeholder=""Underline input"" />
<Input variant=""filled"" placeholder=""Filled input"" mt=""md"" />
</MantineProvider>
);
}

// Demo.module.css
.input {
&[data-variant='underline'] {
border-bottom: 2px solid;
border-radius: 0;
padding-left: 0;
padding-right: 0;

@mixin light {
border-color: var(--mantine-color-gray-3);
}

@mixin dark {
border-color: var(--mantine-color-dark-3);
}

&:focus {
border-color: var(--mantine-color-blue-filled);
}
}
}
```  
Note that you can add custom variants to every Mantine component that supports [Styles API](https://mantine.dev/styles/styles-api)
even if there are no variants defined on the library side.  
> **Overriding existing variants styles**
>
> Apart from adding new variants, you can also override existing ones, for example, you can change the
> `filled` variant of the [Input](https://mantine.dev/core/input) component with `.input[data-variant=""filled""]` selector.",0.014734561213434454,5,2
eval2_q004,How can I define and use a new Button style variant via theming?,c3446d1c-ad25-4efe-b8cd-4205bec49ca8,"Topic: TypeScript
Section: Custom variants types

You can define types for custom [variants](https://mantine.dev/styles/variants-sizes) by
extending `{x}Props` interface with the new variant type in your `mantine.d.ts` file.  
Example of adding custom variant type to [Button](https://mantine.dev/core/button) component:  
```tsx
import { ButtonVariant, MantineSize } from '@mantine/core';

type ExtendedButtonVariant = ButtonVariant | 'contrast' | 'radial-gradient';

declare module '@mantine/core' {
export interface ButtonProps {
variant?: ExtendedButtonVariant;
}
}
```",0.014603174603174604,6,1
eval2_q004,How can I define and use a new Button style variant via theming?,12d83b92-d7a0-47be-883a-b0eeb981be74,"Topic: LLMDocumentation
Section: Example prompts

Here are some example prompts you can use with AI tools:  
* ""Using Mantine v8, how do I create a dark mode toggle?""
* ""Show me how to use the AppShell component with a collapsible navbar""
* ""How can I customize the theme colors in MantineProvider?""
* ""Create a form with validation using Mantine's form hooks""
* ""How to align input with a button in a flex container?""",0.008064516129032258,7,0
eval2_q004,How can I define and use a new Button style variant via theming?,e0ddae02-5969-4802-8fd3-330490f39698,"Topic: ActionIcon
Section: Add custom variants

To add new `ActionIcon` variants, use [data-variant](https://mantine.dev/styles/variants-sizes) attribute.
Usually new variants are added on [theme](https://mantine.dev/theming/theme-object), this way they are
available in all `ActionIcon` components in your application.  
#### Example: customVariant  
```tsx
// Demo.tsx
import { Group, ActionIcon, MantineProvider, createTheme } from '@mantine/core';
import { IconHeart } from '@tabler/icons-react';
import classes from './Demo.module.css';

const theme = createTheme({
components: {
ActionIcon: ActionIcon.extend({
classNames: classes,
}),
},
});

function Demo() {
return (
<MantineProvider theme={theme}>
<Group justify=""center"">
<ActionIcon size=""xl"" variant=""danger"" aria-label=""Danger variant"">
<IconHeart />
</ActionIcon>
<ActionIcon size=""xl"" variant=""primary"" aria-label=""Primary variant"">
<IconHeart />
</ActionIcon>
</Group>
</MantineProvider>
);
}

// Demo.module.css
.root {
&[data-variant='danger'] {
background-color: var(--mantine-color-red-9);
color: var(--mantine-color-red-0);
}

&[data-variant='primary'] {
background: linear-gradient(45deg, #4b6cb7 10%, #253b67 90%);
color: var(--mantine-color-white);
}
}
```",0.0078125,8,1
eval2_q004,How can I define and use a new Button style variant via theming?,092378dc-9185-4fbf-8afb-cb7ea1ce589a,"Topic: General
Section: How can I customize colors with theme?

You can define custom colors in the [theme object](https://mantine.dev/theming/theme-object).  
```tsx
import { createTheme, MantineProvider } from '@mantine/core';

const theme = createTheme({
colors: {
sepia: [
'#F4ECD8',
'#EAD8B7',
'#DFC29A',
'#D4AC7E',
'#C99862',
'#BD8447',
'#B2702D',
'#A55C15',
'#924908',
'#7A3704',
],
},
});

function Demo() {
return (
<MantineProvider theme={theme}>
<App />
</MantineProvider>
);
}
```  
Then you can reference these values in components and `.css` files:  
```scss
body {
background-color: var(--mantine-color-sepia-0);
color: var(--mantine-color-sepia-9);
}
```",0.007692307692307693,9,0
eval2_q004,How can I define and use a new Button style variant via theming?,115bed3e-3cdd-4e52-bd7a-9841f2bdf88a,"Topic: Button
Section: Get element ref

component supports Styles API. With Styles API, you can customize styles of any inner element. Follow the documentation to learn how to use CSS modules, CSS variables and inline styles to get full control over component styles.  
**Button selectors**  
| Selector | Static selector | Description |
|----------|----------------|-------------|
| root | .mantine-Button-root | Root element |
| loader | .mantine-Button-loader | Loader component, displayed only when `loading` prop is set |
| inner | .mantine-Button-inner | Contains all other elements, child of the `root` element |
| section | .mantine-Button-section | Left and right sections of the button |
| label | .mantine-Button-label | Button children |  
**Button CSS variables**  
| Selector | Variable | Description |
|----------|----------|-------------|
| root | --button-bg | Controls `background` |
| root | --button-bd | Control `border` |
| root | --button-hover | Controls `background` when hovered |
| root | --button-color | Control text `color` |
| root | --button-hover-color | Control text `color` when hovered |
| root | --button-radius | Controls `border-radius` |
| root | --button-height | Controls `height` of the button |
| root | --button-padding-x | Controls horizontal `padding` of the button |
| root | --button-fz | Controls `font-size` of the button |
| root | --button-justify | Controls `justify-content` of `inner` element |  
**Button data attributes**  
| Selector | Attribute | Condition | Value |
|----------|-----------|-----------|-------|
| root | data-disabled | - | - |  
**Button.Group selectors**  
| Selector | Static selector | Description |
|----------|----------------|-------------|
| group | .mantine-ButtonGroup-group | Root element |  
**Button.Group CSS variables**  
| Selector | Variable | Description |
|----------|----------|-------------|
| group | --button-border-width | `border-width` of child `Button` components |  
**Button.Group data attributes**  
| Selector | Attribute |",0.007575757575757576,10,0
eval2_q004,How can I define and use a new Button style variant via theming?,85e12e1a-59a2-45d3-8a0c-0090ae1f4b3e,"Topic: Tooltip
Section: Multiline

To enable multiline mode, set `multiline` prop to enable line breaks and `w` [style prop](https://mantine.dev/styles/style-props) to set tooltip width:  
#### Example: multiline  
```tsx
import { Tooltip, Button } from '@mantine/core';

function Demo() {
return (
<Tooltip
multiline
w={220}
withArrow
transitionProps={{ duration: 200 }}
label=""Use this button to save this information in your profile, after that you will be able to access it any time and share it via email.""
>
<Button>Multiline tooltip</Button>
</Tooltip>
);
}
```",0.007575757575757576,11,0
eval2_q004,How can I define and use a new Button style variant via theming?,82e8faf4-7ba0-4b26-b488-746fbf3d0f99,"Topic: VariantsAndSizes
Section: Sizes with components CSS variables

You can add custom sizes to any component that supports `size` prop by providing a custom
CSS variables resolver, usually it is done in `theme.components`:  
#### Example: vars  
```tsx
// MantineProvider.tsx
import { Button, Group, MantineProvider, createTheme } from '@mantine/core';

const theme = createTheme({
components: {
Button: Button.extend({
vars: (theme, props) => {
if (props.size === 'xxl') {
return {
root: {
'--button-height': '60px',
'--button-padding-x': '30px',
'--button-fz': '24px',
},
};
}

if (props.size === 'xxs') {
return {
root: {
'--button-height': '24px',
'--button-padding-x': '10px',
'--button-fz': '10px',
},
};
}

return { root: {} };
},
}),
},
});

function Demo() {
return (
<MantineProvider theme={theme}>
<Group>
<Button size=""xxl"">XXL Button</Button>
<Button size=""xxs"">XXS Button</Button>
</Group>
</MantineProvider>
);
}

// Inline.tsx
import { Button, PartialVarsResolver, ButtonFactory, Group } from '@mantine/core';

const varsResolver: PartialVarsResolver<ButtonFactory> = (theme, props) => {
if (props.size === 'xxl') {
return {
root: {
'--button-height': '60px',
'--button-padding-x': '30px',
'--button-fz': '24px',
},
};
}

if (props.size === 'xxs') {
return {
root: {
'--button-height': '24px',
'--button-padding-x': '10px',
'--button-fz': '10px',
},
};
}

return { root: {} };
};

function Demo() {
return (
<Group>
<Button vars={varsResolver} size=""xxl"">
XXL Button
</Button>
<Button vars={varsResolver} size=""xxs"">
XXS Button
</Button>
</Group>
);
}
```",0.007462686567164179,12,0
eval2_q004,How can I define and use a new Button style variant via theming?,9eb441b4-d9ef-4a7a-b30a-b7718cfef8dc,"Topic: General
Section: Can I have just one shade per color?

If you do not plan to use light variant, support different colors for
light/dark color schemes, and you do not rely on color changes for hover
effects, you can define just one shade per color with `colorsTuple` function:  
```tsx
import { colorsTuple, createTheme } from '@mantine/core';

const theme = createTheme({
colors: {
custom: colorsTuple('#FFC0CB'),
},
});
```",0.007462686567164179,13,0
eval2_q004,How can I define and use a new Button style variant via theming?,022c363b-08c5-44b3-b4e2-94192de60acb,"Topic: StylesApi
Section: Components CSS variables

if (props.size === 'xxs') {
return {
root: {
'--button-height': '24px',
'--button-padding-x': '10px',
'--button-fz': '10px',
},
};
}

return { root: {} };
};

function Demo() {
return (
<Group>
<Button vars={varsResolver} size=""xxl"">
XXL Button
</Button>
<Button vars={varsResolver} size=""xxs"">
XXS Button
</Button>
</Group>
);
}
```",0.007246376811594203,14,0
eval2_q004,How can I define and use a new Button style variant via theming?,de29656a-7d3b-408a-8007-3a1aecf5e42c,"Topic: Contribute
Section: Ways to contribute

* **Improve documentation:** Fix incomplete or missing docs, bad wording, examples or explanations.
* **Give feedback:** We are constantly working on making Mantine better. Please share how you use Mantine, what features are missing and what is done well via [GitHub Discussions](https://github.com/mantinedev/mantine/discussions/new) or [Discord](https://discord.gg/wbH82zuWMN).
* **Share Mantine:** Share links to the Mantine docs with everyone who might be interested! [Share Mantine on X here](https://x.com/intent/tweet?text=Mantine%20%E2%80%93%20new%20React%20library%20with%20100%2B%20components%20and%20hooks.%20It%20has%20native%20dark%20theme%20support%20and%20focuses%20on%20accessibility%20and%20usability.%0A%0Ahttp%3A%2F%2Fmantine.dev%0A%0A%23reactjs%20).
* **Contribute to the codebase:** Propose new features via [GitHub Issues](https://github.com/mantinedev/mantine/issues/new), or find an [existing issue](https://github.com/mantinedev/mantine/labels/help%20wanted) that you are interested in and work on it!
* **Give us a code review:** Help us identify problems with the [source code](https://github.com/mantinedev/mantine/tree/master/packages) or make Mantine more performant.",0.007246376811594203,15,0
eval2_q004,How can I define and use a new Button style variant via theming?,06fda8f9-5e3d-4582-be63-b53824a2e052,"Topic: StylesApi
Section: Components CSS variables

Most of Mantine components use CSS variables to define colors, sizes, paddings and other
properties. You can override these values using a custom CSS variables resolver function
in [theme.components](https://mantine.dev/theming/theme-object) or by passing it to the `vars` prop.  
You can find CSS variables information under the `Styles API` tab in a component's documentation.
Example of [Button](https://mantine.dev/core/button) component CSS variables:  
<VariablesTable data={ButtonStylesApi} withTableBorder={false} fixedLayout={false} />  
Example of a custom CSS variables resolver function used to add more sizes to the [Button](https://mantine.dev/core/button) component:  
#### Example: vars  
```tsx
// MantineProvider.tsx
import { Button, Group, MantineProvider, createTheme } from '@mantine/core';

const theme = createTheme({
components: {
Button: Button.extend({
vars: (theme, props) => {
if (props.size === 'xxl') {
return {
root: {
'--button-height': '60px',
'--button-padding-x': '30px',
'--button-fz': '24px',
},
};
}

if (props.size === 'xxs') {
return {
root: {
'--button-height': '24px',
'--button-padding-x': '10px',
'--button-fz': '10px',
},
};
}

return { root: {} };
},
}),
},
});

function Demo() {
return (
<MantineProvider theme={theme}>
<Group>
<Button size=""xxl"">XXL Button</Button>
<Button size=""xxs"">XXS Button</Button>
</Group>
</MantineProvider>
);
}

// Inline.tsx
import { Button, PartialVarsResolver, ButtonFactory, Group } from '@mantine/core';

const varsResolver: PartialVarsResolver<ButtonFactory> = (theme, props) => {
if (props.size === 'xxl') {
return {
root: {
'--button-height': '60px',
'--button-padding-x': '30px',
'--button-fz': '24px',
},
};
}

if (props.size === 'xxs') {
return {
root: {
'--button-height': '24px',
'--button-padding-x': '10px',
'--button-fz': '10px',
},
};
}

return { root: {} };
};",0.007142857142857143,16,0
eval2_q004,How can I define and use a new Button style variant via theming?,1f837915-605a-4775-bd54-3d75e5e5626f,"Topic: DefaultProps
Section: Default props with MantineThemeProvider

You can also use `MantineThemeProvider` to define default props
for a part of your application:  
```tsx
import {
Button,
createTheme,
MantineThemeProvider,
} from '@mantine/core';

const theme = createTheme({
components: {
Button: Button.extend({
defaultProps: {
color: 'cyan',
variant: 'outline',
},
}),
},
});

function Demo() {
return (
<>
<MantineThemeProvider theme={theme}>
{/* Part of the app with theme */}
</MantineThemeProvider>

{/* Another part without theme */}
</>
);
}
```",0.007142857142857143,17,0
eval2_q004,How can I define and use a new Button style variant via theming?,b295af2a-16ee-463b-a879-afa2663b9edf,"Topic: CssVariables
Section: Variant colors

Some Mantine components like [Button](https://mantine.dev/core/button) or [Badge](https://mantine.dev/core/badge) have `variant` prop
that in combination with `color` prop controls the component text, background and border colors.
For each variant and color, Mantine defines a set of CSS variables that control these colors.
For example, for the default `blue` color the following CSS variables are defined:  
<CssVariablesGroup
data={[
{ group: 'Filled variant' },
{
variable: '--mantine-color-blue-filled',
description: 'Background color of filled variant',
defaultValue: 'var(--mantine-color-blue-6)',
},
{
variable: '--mantine-color-blue-filled-hover',
description: 'Background color of filled variant on hover',
defaultValue: 'var(--mantine-color-blue-7)',
},
{ group: 'Light variant' },
{
variable: '--mantine-color-blue-light',
description: 'Background color of light variant',
defaultValue: 'rgba(34, 139, 230, 0.1)',
},
{
variable: '--mantine-color-blue-light-hover',
description: 'Background color of light variant on hover',
defaultValue: 'rgba(34, 139, 230, 0.12)',
},
{
variable: '--mantine-color-blue-light-color',
description: 'Text color of light variant',
defaultValue: 'var(--mantine-color-blue-6)',
},
{ group: 'Outline variant' },
{
variable: '--mantine-color-blue-outline',
description: 'Border color of outline variant',
defaultValue: 'var(--mantine-color-blue-6)',
},
{
variable: '--mantine-color-blue-outline-hover',
description: 'Border color of outline variant',
defaultValue: 'rgba(34, 139, 230, 0.05)',
},
]}
/>  
For example, if you use [Button](https://mantine.dev/core/button) component the following way:  
```tsx
import { Button } from '@mantine/core';",0.007042253521126761,18,0
eval2_q004,How can I define and use a new Button style variant via theming?,48240b20-f413-4580-9772-d5bd4140c71b,"Topic: CssVariables
Section: Variant colors

function Demo() {
return (
<Button color=""pink"" variant=""filled"">
Filled pink button
</Button>
);
}
```  
The component will have the following styles:  
* Background color will be `var(--mantine-color-pink-filled)`
* Background color on hover will be `var(--mantine-color-pink-filled-hover)`
* Text color will be `var(--mantine-color-white)`
* Border color will be `transparent`  
Note that the variables above are not static, they are generated based on the values of
`theme.colors` and `theme.primaryShade`. Additionally, their values are different for
dark and light color schemes.  
Variant colors variables are used in all components that support `color` prop, for example,
[Button](https://mantine.dev/core/button), [Badge](https://mantine.dev/core/badge), [Avatar](https://mantine.dev/core/avatar) and [Pagination](https://mantine.dev/core/pagination).
Colors values that are used by these components are determined by `cssVariablesResolver` described below
and [variantColorResolver](https://mantine.dev/styles/variants-sizes/#variantcolorresolver).",0.006944444444444444,19,0
eval2_q004,How can I define and use a new Button style variant via theming?,b27b3204-f734-478b-8ebc-485954c4c754,"Topic: Colors
Section: Colors variant resolver

// Override some properties for variant
if (parsedColor.isThemeColor && parsedColor.color === 'lime' && input.variant === 'filled') {
return {
...defaultResolvedColors,
color: 'var(--mantine-color-black)',
hoverColor: 'var(--mantine-color-black)',
};
}

// Completely override variant
if (input.variant === 'light') {
return {
background: rgba(parsedColor.value, 0.1),
hover: rgba(parsedColor.value, 0.15),
border: `1px solid ${parsedColor.value}`,
color: darken(parsedColor.value, 0.1),
};
}

// Add new variants support
if (input.variant === 'danger') {
return {
background: 'var(--mantine-color-red-9)',
hover: 'var(--mantine-color-red-8)',
color: 'var(--mantine-color-white)',
border: 'none',
};
}

return defaultResolvedColors;
};

function Demo() {
return (
<MantineProvider theme={{ variantColorResolver }}>
<Group>
<Button color=""lime.4"" variant=""filled"">
Lime filled button
</Button>

<Button color=""orange"" variant=""light"">
Orange light button
</Button>

<Button variant=""danger"">Danger button</Button>
</Group>
</MantineProvider>
);
}
```",0.00684931506849315,20,0
eval2_q004,How can I define and use a new Button style variant via theming?,d3b6f38f-ef8b-4c9d-af50-4e625e821081,"Topic: General
Section: How can I know what is coming next?

New features are usually announced in the [Discord server](https://discord.gg/wbH82zuWMN) and on [X](https://x.com/mantinedev)
when they are released. Upcoming features are usually discussed with the community on [Discord](https://discord.gg/wbH82zuWMN).",0.00684931506849315,21,0
eval2_q004,How can I define and use a new Button style variant via theming?,9491f630-eae2-4a3d-9fb5-130747b518b5,"Topic: StylesApi
Section: Static classes

Every component that supports Styles API also includes static classes that can be used to style
component without using `classNames` or `styles` props. By default, static classes have
`.mantine-{ComponentName}-{selector}` format. For example, `root` selector of [Button](https://mantine.dev/core/button)
component will have `.mantine-Button-root` class.  
You can use static classes to style a component with CSS or [any other styling solution](https://mantine.dev/styles/css-modules#styling-mantine-components-without-css-modules):  
```css
.mantine-Button-root {
background-color: red;
}
```  
The prefix of static classes can be changed with `classNamesPrefix` of [MantineProvider](https://mantine.dev/theming/mantine-provider#classnamesprefix).",0.006756756756756757,22,0
eval2_q004,How can I define and use a new Button style variant via theming?,9e282d9d-c77e-4567-8474-34e589adb62e,"Topic: StylesOverview
Section: Component specific props

Most of the components provide props that allow you to customize their styles. For example,
[Button](https://mantine.dev/core/button/) component has `color`, `variant`, `size` and `radius` props that control its
appearance:  
#### Example: configurator  
```tsx
import { Button } from '@mantine/core';

function Demo() {
return <Button>Button</Button>;
}
```  
These props usually control multiple CSS properties, for example `color` and variant props control `color`,
`background-color` and `border` properties. In most cases, changing components props is the most optimal way to customize Mantine components.",0.006756756756756757,23,0
eval2_q004,How can I define and use a new Button style variant via theming?,1a68207d-a2c4-40bc-9ba4-c7bb6136965b,"Topic: GettingStarted
Section: Learn

Before you jump into the code, it is recommended to learn more about Mantine theming and styling options.
The most important documentation pages are:  
* [Theme object](https://mantine.dev/theming/theme-object) – learn about available theme properties
* [Colors](https://mantine.dev/theming/colors) – learn how to add/replace colors in the theme object
* [CSS modules](https://mantine.dev/styles/css-modules) – learn how to use CSS modules with Mantine
* [postcss-preset-mantine](https://mantine.dev/styles/postcss-preset) – learn about `postcss-preset-mantine` functions and mixins
* [Responsive styles](https://mantine.dev/styles/responsive) – learn how to apply responsive styles to components
* [Styles API](https://mantine.dev/styles/styles-api) – learn how to style internal elements of any component
* [Polymorphic components](https://mantine.dev/guides/polymorphic) – learn how to use polymorphic components to change rendered element",0.006666666666666667,24,0
eval2_q005,How can I add a persistent top header area as part of the main application layout?,462eca27-f91f-4aee-913a-947307855e0c,"Topic: AppShell
Section: Usage

`AppShell` is a layout component that can be used to implement a common Header / Navbar / Footer / Aside
layout pattern. All `AppShell` components have `position: fixed` style, so they do not scroll with
the page.  
[Basic AppShell example](https://mantine.dev/app-shell?e=BasicAppShell) with header and navbar.
The navbar is hidden on mobile by default and toggled with the burger button.  
```tsx
import { AppShell, Burger } from '@mantine/core';
import { useDisclosure } from '@mantine/hooks';

function Demo() {
const [opened, { toggle }] = useDisclosure();

return (
<AppShell
padding=""md""
header={{ height: 60 }}
navbar={{
width: 300,
breakpoint: 'sm',
collapsed: { mobile: !opened },
}}
>
<AppShell.Header>
<Burger
opened={opened}
onClick={toggle}
hiddenFrom=""sm""
size=""sm""
/>

<div>Logo</div>
</AppShell.Header>

<AppShell.Navbar>Navbar</AppShell.Navbar>

<AppShell.Main>Main</AppShell.Main>
</AppShell>
);
}
```",0.01626123744050767,1,3
eval2_q005,How can I add a persistent top header area as part of the main application layout?,6ef54a87-6d10-4574-8d69-7c19675e083c,"Topic: AppShell
Section: AppShell components

* `AppShell` – root component that wraps all other sections and configures the overall layout.
* `AppShell.Header` – fixed header at the top, controlled by the `header` prop.
* `AppShell.Navbar` – fixed navbar on the left, controlled by the `navbar` prop.
* `AppShell.Aside` – fixed aside on the right, controlled by the `aside` prop.
* `AppShell.Footer` – fixed footer at the bottom, controlled by the `footer` prop.
* `AppShell.Main` – main content area, statically positioned and offset by the other sections.
* `AppShell.Section` – utility for grouping content inside `AppShell.Navbar` or `AppShell.Aside`, useful for scrollable areas.",0.016133229247983348,2,2
eval2_q005,How can I add a persistent top header area as part of the main application layout?,753daa4d-a7ad-450d-9073-adc08690a547,"Topic: Table
Section: Sticky header

Set `stickyHeader` to make table header sticky. To customize top position of the header use `stickyHeaderOffset` prop:
it is useful when you have a fixed header in your application. For example, Mantine documentation website has a fixed
header with 60px height:  
#### Example: stickyHeader  
```tsx
import { Table } from '@mantine/core';

const elements = [
{ position: 6, mass: 12.011, symbol: 'C', name: 'Carbon' },
{ position: 7, mass: 14.007, symbol: 'N', name: 'Nitrogen' },
{ position: 39, mass: 88.906, symbol: 'Y', name: 'Yttrium' },
{ position: 56, mass: 137.33, symbol: 'Ba', name: 'Barium' },
{ position: 58, mass: 140.12, symbol: 'Ce', name: 'Cerium' },
];

function Demo() {
const rows = elements.map((element) => (
<Table.Tr key={element.name}>
<Table.Td>{element.position}</Table.Td>
<Table.Td>{element.name}</Table.Td>
<Table.Td>{element.symbol}</Table.Td>
<Table.Td>{element.mass}</Table.Td>
</Table.Tr>
));

return (
<Table stickyHeader stickyHeaderOffset={60}>
<Table.Thead>
<Table.Tr>
<Table.Th>Element position</Table.Th>
<Table.Th>Element name</Table.Th>
<Table.Th>Symbol</Table.Th>
<Table.Th>Atomic mass</Table.Th>
</Table.Tr>
</Table.Thead>
<Table.Tbody>{rows}</Table.Tbody>
<Table.Caption>Scroll page to see sticky thead</Table.Caption>
</Table>
);
}
```",0.014854753521126762,3,0
eval2_q005,How can I add a persistent top header area as part of the main application layout?,1f9f1c26-870c-4f7a-bc6e-5c7f1305fc11,"Topic: AppShell
Section: Header offset configuration

The `header` prop includes an `offset` property that allows you to control
whether the `AppShell.Main` component is offset by the header's height.
This is particularly useful when you want to collapse the `AppShell.Header`
based on scroll position. For example, you can use the [use-headroom](https://mantine.dev/hooks/use-headroom)
hook to hide the header when the user scrolls down and show it when
scrolling up ([example](https://mantine.dev/app-shell?e=Headroom)).  
```tsx
import { AppShell, rem } from '@mantine/core';
import { useHeadroom } from '@mantine/hooks';

function Demo() {
const pinned = useHeadroom({ fixedAt: 120 });

return (
<AppShell
header={{ height: 60, collapsed: !pinned, offset: false }}
padding=""md""
>
<AppShell.Header>Header</AppShell.Header>

<AppShell.Main
pt={`calc(${rem(60)} + var(--mantine-spacing-md))`}
>
{/* Content */}
</AppShell.Main>
</AppShell>
);
}
```",0.008064516129032258,4,2
eval2_q005,How can I add a persistent top header area as part of the main application layout?,e6140292-c274-4afb-ae7c-41aee4515648,"Topic: AppShell
Section: CSS variables

of all transitions in ms |
| transitionTimingFunction | TransitionTimingFunction | - | Timing function of all transitions |
| withBorder | boolean | - | If set, the associated components have a border |
| zIndex | string | number | - | <code>z-index</code> of all associated elements |  
#### Styles API  
AppShell component supports Styles API. With Styles API, you can customize styles of any inner element. Follow the documentation to learn how to use CSS modules, CSS variables and inline styles to get full control over component styles.  
**AppShell selectors**  
| Selector | Static selector | Description |
|----------|----------------|-------------|
| root | .mantine-AppShell-root | Root element (`AppShell` component) |
| navbar | .mantine-AppShell-navbar | `AppShell.Navbar` root element |
| header | .mantine-AppShell-header | `AppShell.Header` root element |
| main | .mantine-AppShell-main | `AppShell.Main` root element |
| aside | .mantine-AppShell-aside | `AppShell.Aside` root element |
| footer | .mantine-AppShell-footer | `AppShell.Footer` root element |
| section | .mantine-AppShell-section | `AppShell.Section` root element |  
**AppShell CSS variables**  
| Selector | Variable | Description |
|----------|----------|-------------|
| root | --app-shell-transition-duration | Controls transition duration of all children |  
**AppShell data attributes**  
| Selector | Attribute | Condition | Value |
|----------|-----------|-----------|-------|
| root | data-resizing | User is resizing the window | - |
| root | data-layout | - | Value of the  |
| root | data-disabled | - | - |",0.007936507936507936,5,0
eval2_q005,How can I add a persistent top header area as part of the main application layout?,ef0d4bf6-f42c-4f86-8565-fc3bcc026742,"Topic: Highlight
Section: Usage

Use Highlight component to highlight a substring in a given string with a mark tag.  
Pass the main string as children to Highlight component and string part that should be highlighted to `highlight` prop.
If the main string does not include `highlight` part, it will be ignored.
`Highlight` ignores trailing whitespace and highlights all matched characters sequences.  
#### Example: usage  
```tsx
import { Highlight } from '@mantine/core';

function Demo() {
return (
<Highlight>
{{children}}
</Highlight>
);
}
```",0.0078125,6,0
eval2_q005,How can I add a persistent top header area as part of the main application layout?,3881ed01-4b12-4586-ad67-8a0c10b9410f,"Topic: useHeadroom
Section: Overview

Package: @mantine/hooks
Import: import { UseHeadroom } from '@mantine/hooks';",0.007692307692307693,7,0
eval2_q005,How can I add a persistent top header area as part of the main application layout?,99bf298e-cca7-4a0e-89e2-848be2dd8461,"Topic: AppShell
Section: CSS variables

Example of using CSS variables in styles:  
```scss
.main {
min-height: calc(100dvh - var(--app-shell-header-height));
}
```  
#### Props  
| Prop | Type | Default | Description |
|------|------|---------|-------------|
| aside | AppShellAsideConfiguration | - | <code>Aside</code> configuration, controls width, breakpoints and collapsed state. Required if you use <code>Aside</code> component. |
| disabled | boolean | - | If set, <code>Navbar</code>, <code>Aside</code>, <code>Header</code> and <code>Footer</code> components are hidden |
| footer | AppShellFooterConfiguration | - | <code>Footer</code> configuration, controls height, offset and collapsed state. Required if you use <code>Footer</code> component. |
| header | AppShellHeaderConfiguration | - | <code>Header</code> configuration, controls height, offset and collapsed state. Required if you use <code>Header</code> component. |
| layout | ""default"" | ""alt"" | - | Determines how <code>Navbar</code>/<code>Aside</code> are arranged relative to <code>Header</code>/<code>Footer</code> |
| mode | ""fixed"" | ""static"" | - | Determines positioning mode of all sections |
| navbar | AppShellNavbarConfiguration | - | <code>Navbar</code> configuration, controls width, breakpoints and collapsed state. Required if you use <code>Navbar</code> component. |
| offsetScrollbars | boolean | - | If set, <code>Header</code> and <code>Footer</code> components include styles to offset scrollbars. Based on <code>react-remove-scroll</code>. |
| padding | MantineSpacing | AppShellResponsiveSize | - | Padding of the main section. Important: use <code>padding</code> prop instead of <code>p</code>. |
| transitionDuration | number | - | Duration of all transitions in ms |
| transitionTimingFunction | TransitionTimingFunction | - | Timing function of all transitions |
| withBorder | boolean | - | If set, the associated components have a border |
| zIndex | string | number | - | <code>z-index</code> of all associated elements |  
#### Styles",0.007692307692307693,8,0
eval2_q005,How can I add a persistent top header area as part of the main application layout?,1f837915-605a-4775-bd54-3d75e5e5626f,"Topic: DefaultProps
Section: Default props with MantineThemeProvider

You can also use `MantineThemeProvider` to define default props
for a part of your application:  
```tsx
import {
Button,
createTheme,
MantineThemeProvider,
} from '@mantine/core';

const theme = createTheme({
components: {
Button: Button.extend({
defaultProps: {
color: 'cyan',
variant: 'outline',
},
}),
},
});

function Demo() {
return (
<>
<MantineThemeProvider theme={theme}>
{/* Part of the app with theme */}
</MantineThemeProvider>

{/* Another part without theme */}
</>
);
}
```",0.007575757575757576,9,0
eval2_q005,How can I add a persistent top header area as part of the main application layout?,f4ff4a37-885d-49af-8591-2fb6d65d70a8,"Topic: AppShell
Section: Overview

Package: @mantine/core
Import: import { AppShell } from '@mantine/core';
Description: Responsive shell for your application with header, navbar, aside and footer",0.007575757575757576,10,1
eval2_q005,How can I add a persistent top header area as part of the main application layout?,4ec3f783-f980-40bb-a9c0-f28e249c2737,"Topic: LLMDocumentation
Section: Windsurf

For Windsurf users:  
1. Reference the documentation using `@https://mantine.dev/llms.txt`
2. Or add it to your `.windsurfrules` file for persistent access",0.007462686567164179,11,0
eval2_q005,How can I add a persistent top header area as part of the main application layout?,6fe2de53-91c0-4f10-8284-ee0caf4793a1,"Topic: AppShell
Section: layout prop

`layout` prop controls how `AppShell.Header`/`AppShell.Footer` and `AppShell.Navbar`/`AppShell.Aside`
are positioned relative to each other. It accepts `alt` and `default` values:  
* `alt` – `AppShell.Navbar`/`AppShell.Aside` extends the full viewport height, while `AppShell.Header`/`AppShell.Footer` width equals the viewport width minus the width of `AppShell.Navbar` and `AppShell.Aside` ([example](https://mantine.dev/app-shell?e=AltLayout))
* `default` – `AppShell.Navbar`/`AppShell.Aside` height equals the viewport height minus `AppShell.Header`/`AppShell.Footer` height, and `AppShell.Header`/`AppShell.Footer` spans the full viewport width ([example](https://mantine.dev/app-shell?e=FullLayout))",0.007462686567164179,12,0
eval2_q005,How can I add a persistent top header area as part of the main application layout?,6a779d28-f558-45e4-b43b-ca0b96efd5fd,"Topic: General
Section: How should I decide which library to use?

Go through the documentation and examples of each library, try to build something with them,
and decide which one fits your needs better.
Mantine, as well as other libraries, provides a lot of examples and documentation,
so you can make an informed decision based on that.",0.007352941176470588,13,0
eval2_q005,How can I add a persistent top header area as part of the main application layout?,f406ea3d-de8f-4960-9d20-1bf030599606,"Topic: General
Section: How can I build the same footer?

* Give footer fixed position with `position: fixed` and `bottom: 0` properties.
* Create a div element that will contain all content except footer.
* Set `min-height: 100vh` on the content container to make sure that footer is always under by the content.
* Make sure that your content container has background color.
* Done! You have a footer at the bottom of the page.",0.007352941176470588,14,0
eval2_q005,How can I add a persistent top header area as part of the main application layout?,c6a14a91-ab0d-4bf5-b409-20a2aebe9cf0,"Topic: NextJs
Section: app + pages router together

If you use both app and pages router in one application, you need to setup both `pages/_app.tsx`
and `app/layout.tsx` files as described above.",0.007246376811594203,15,0
eval2_q005,How can I add a persistent top header area as part of the main application layout?,f022f400-57be-4fbc-86fe-6ad9333afbb1,"Topic: General
Section: Scroll to the top of the form on submit

Using the second callback of `form.onSubmit` you can scroll to the top of the form.
If your application includes a fixed header (like Mantine Help Center website), use
[scroll-margin](https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-margin) CSS property
to ensure that the form is not hidden behind the header. Note that `scroll-margin` does not
work if the form has `overflow: hidden;` styles or is inside other element that has
`overflow: hidden;` styles.  
#### Example: ScrollToTopOfForm  
```tsx
function Demo() {
const form = useForm({
mode: 'uncontrolled',
initialValues: {
name: '',
email: '',
},

validate: {
name: isNotEmpty('Name is required'),
email: isEmail('Invalid email'),
},
});

return (
<form
id=""my-form""
style={{ scrollMargin: '100px' }}
onSubmit={form.onSubmit(
() => {},
() => {
document
.getElementById('my-form')
?.scrollIntoView({ block: 'start', behavior: 'smooth' });
}
)}
>
<TextInput
withAsterisk
label=""Your name""
placeholder=""Your name""
key={form.key('name')}
{...form.getInputProps('name')}
/>

<TextInput
withAsterisk
label=""Your email""
placeholder=""your@email.com""
mt=""md""
key={form.key('email')}
{...form.getInputProps('email')}
/>

<Group justify=""flex-end"" mt=""md"">
<Button type=""submit"">Submit</Button>
</Group>
</form>
);
}
```",0.007246376811594203,16,0
eval2_q005,How can I add a persistent top header area as part of the main application layout?,12d83b92-d7a0-47be-883a-b0eeb981be74,"Topic: LLMDocumentation
Section: Example prompts

Here are some example prompts you can use with AI tools:  
* ""Using Mantine v8, how do I create a dark mode toggle?""
* ""Show me how to use the AppShell component with a collapsible navbar""
* ""How can I customize the theme colors in MantineProvider?""
* ""Create a form with validation using Mantine's form hooks""
* ""How to align input with a button in a flex container?""",0.007142857142857143,17,0
eval2_q005,How can I add a persistent top header area as part of the main application layout?,7ea103d2-e561-4419-8305-aed0b4c9a010,"Topic: AppShell
Section: AppShell.Section component

`AppShell.Section` is used to create organized areas within `AppShell.Navbar` and `AppShell.Aside`.
Since these components are flexbox containers with `flex-direction: column`, the `AppShell.Section`
component with the `grow` prop will expand to fill available space and can be made scrollable by setting
`component={ScrollArea}`.  
In the following example:  
* The first and last sections (header and footer) take only the space needed for their content
* The middle section with `grow` takes all remaining space and becomes scrollable when content exceeds the available height  
```tsx
import { AppShell, ScrollArea } from '@mantine/core';

function Demo() {
return (
<AppShell navbar={{ width: 300, breakpoint: 0 }}>
<AppShell.Navbar>
<AppShell.Section>Navbar header</AppShell.Section>
<AppShell.Section grow component={ScrollArea}>
Navbar main section, it will
</AppShell.Section>
<AppShell.Section>
Navbar footer – always at the bottom
</AppShell.Section>
</AppShell.Navbar>
<AppShell.Main>Main</AppShell.Main>
</AppShell>
);
}
```",0.007142857142857143,18,0
eval2_q005,How can I add a persistent top header area as part of the main application layout?,769eedbb-a0ae-4965-ab9e-fb3bda5f71dc,"Topic: useHeadroom
Section: Usage

Use `use-headroom` hook to create headers that are hidden after user scrolls past the given distance in px.
The hook returns a boolean value that determines whether the element should be pinned or hidden.
Hook returns `true` when the current scroll position is less than the specified `fixedAt` value and
after user scrolled up.",0.007042253521126761,19,0
eval2_q005,How can I add a persistent top header area as part of the main application layout?,b32ffa27-06b9-446a-9806-eef2aea49934,"Topic: AppShell
Section: zIndex prop

The `zIndex` prop is available on `AppShell` and its associated sections: `AppShell.Header`, `AppShell.Navbar`, `AppShell.Aside`, and `AppShell.Footer`.
By default, all sections have a `z-index` of `100`.  
To change the `z-index` of all sections, set the `zIndex` prop on the `AppShell` component:  
```tsx
import { AppShell } from '@mantine/core';

// All sections will have z-index of 200
function Demo() {
return <AppShell zIndex={200}>{/* AppShell content */}</AppShell>;
}
```  
To change `z-index` of a specific section, set `zIndex` prop on that section:  
```tsx
import { AppShell } from '@mantine/core';

// AppShell.Header has z-index of 100
// AppShell.Navbar and AppShell.Aside have z-index of 300
function Demo() {
return (
<AppShell>
<AppShell.Header zIndex={100}>Header</AppShell.Header>
<AppShell.Navbar zIndex={300}>Navbar</AppShell.Navbar>
<AppShell.Aside zIndex={300}>Aside</AppShell.Aside>
</AppShell>
);
}
```",0.006944444444444444,20,1
eval2_q005,How can I add a persistent top header area as part of the main application layout?,bac1e4d3-d10a-4081-8a08-a9e7d360ce80,"Topic: General
Section: Overview

# How can I add hover styles to an element?
Learn how to add hover classes to an element with CSS modules, &:hover or @mixin hover",0.006944444444444444,21,0
eval2_q005,How can I add a persistent top header area as part of the main application layout?,368569a0-95a9-47a1-828c-e4872d1eadd7,"Topic: Affix
Section: Usage

`Affix` renders a div element with a fixed position inside the [Portal](https://mantine.dev/core/portal) component.
Use it to display elements fixed at any position on the screen, for example, scroll to top button:  
#### Example: usage  
```tsx
import { IconArrowUp } from '@tabler/icons-react';
import { useWindowScroll } from '@mantine/hooks';
import { Affix, Button, Text, Transition } from '@mantine/core';

function Demo() {
const [scroll, scrollTo] = useWindowScroll();",0.00684931506849315,22,0
eval2_q005,How can I add a persistent top header area as part of the main application layout?,abe16395-6325-49d4-a307-132341bb45ab,"Topic: GlobalStyles
Section: Add global styles in your application

It is recommended to use [CSS modules](https://mantine.dev/styles/css-modules) to apply styles to Mantine components
with `className` prop or with [Styles API](https://mantine.dev/styles/styles-api). CSS modules files names usually
end with `.module.css`, if you want to add global styles to your application, create a file with
`.css` extension but without `.module` part, for example `global.css`.  
In global `.css` files you can reference all Mantine [CSS variables](https://mantine.dev/styles/css-variables) and
change styles of `<body />`, `:root` and other elements. For example, to change body background-color:  
```css
body {
background-color: var(--mantine-color-red-filled);
}
```",0.00684931506849315,23,0
eval2_q005,How can I add a persistent top header area as part of the main application layout?,12002107-37e8-46ad-9cd2-ee751075eaa9,"Topic: General
Section: I want to add a custom color scheme. Can I do that?

No, Mantine does not support custom color schemes. If you attempt to do that,
most of the components will have broken styles. Instead of applying a custom
color scheme, customize colors with [theme](https://mantine.dev/theming/theme-object/).",0.006756756756756757,24,0
eval2_q005,How can I add a persistent top header area as part of the main application layout?,7dab88ae-e103-4521-9714-e87ae9441f5d,"Topic: General
Section: Overview

# How can I lock scroll in my application?
Use react-remove-scroll library to lock scroll in your application  
Mantine components use [react-remove-scroll](https://github.com/theKashey/react-remove-scroll)
library to lock scroll. You can use it in your application to lock scroll. For your
convenience, `@mantine/core` package exports `RemoveScroll` component:  
```tsx
import { RemoveScroll } from '@mantine/core';

function App() {
return (
<RemoveScroll>
<div>Content</div>
</RemoveScroll>
);
}
```  
The component supports all props that are supported by `react-remove-scroll` library,
you can find the full list of props in the [official documentation](https://github.com/theKashey/react-remove-scroll).",0.006756756756756757,25,0
eval2_q005,How can I add a persistent top header area as part of the main application layout?,6f416597-99b7-4f48-9f28-4e1d6221dd00,"Topic: General
Section: Overview

# How can I add fuzzy search to Select component?
Learn how to integrate third-party fuzzy search libraries with Mantine Select component",0.006666666666666667,26,0
eval2_q005,How can I add a persistent top header area as part of the main application layout?,7bc85b6a-c0eb-422f-8955-2ed49baa5b10,"Topic: Rich text editor
Section: Sticky toolbar

Set `sticky` prop on `RichTextEditor.Toolbar` component to make toolbar sticky,
control `top` property with `stickyOffset`. For example, on mantine.dev documentation
website there is a header with `var(--docs-header-height)` height, in this case we will need to
set `stickyOffset=""var(--docs-header-height)""` to make sticky position correctly with fixed positioned element.",0.006666666666666667,27,0
eval2_q007,How can I validate that two fields match in Mantine useForm while showing the error only on the second field?,5577cd1e-4ea5-40fe-a7a8-0970d40afd74,"Topic: formValidation
Section: Validation based on other form values

You can get all form values as a second rule function argument to perform field validation based on other
form values. For example, you can validate that password confirmation is the same as password:  
#### Example: password  
```tsx
import { useForm } from '@mantine/form';
import { PasswordInput, Group, Button, Box } from '@mantine/core';

function Demo() {
const form = useForm({
mode: 'uncontrolled',
initialValues: {
password: 'secret',
confirmPassword: 'sevret',
},

validate: {
confirmPassword: (value, values) =>
value !== values.password ? 'Passwords did not match' : null,
},
});

return (
<Box maw={340} mx=""auto"">
<form onSubmit={form.onSubmit((values) => console.log(values))}>
<PasswordInput
label=""Password""
placeholder=""Password""
key={form.key('password')}
{...form.getInputProps('password')}
/>

<PasswordInput
mt=""sm""
label=""Confirm password""
placeholder=""Confirm password""
key={form.key('confirmPassword')}
{...form.getInputProps('confirmPassword')}
/>

<Group justify=""flex-end"" mt=""md"">
<Button type=""submit"">Submit</Button>
</Group>
</form>
</Box>
);
}
```",0.01626123744050767,1,3
eval2_q007,How can I validate that two fields match in Mantine useForm while showing the error only on the second field?,35265d2f-8fbd-42d4-9ff5-6acc230b9cda,"Topic: formValidators
Section: matchesField

`matchesField` checks whether form value is the same as value in other form field.
Note that `matchesField` can only work with primitive values (arrays and objects cannot be compared).  
```tsx
import { matchesField, useForm } from '@mantine/form';

const form = useForm({
mode: 'uncontrolled',
initialValues: {
password: '',
confirmPassword: '',
},

validate: {
confirmPassword: matchesField(
'password',
'Passwords are not the same'
),
},
});
```",0.016001024065540194,2,3
eval2_q007,How can I validate that two fields match in Mantine useForm while showing the error only on the second field?,bad2b183-ba7c-49cf-924e-14434e8c9f7d,"Topic: formValidation
Section: Rule function arguments

Each form rule receives the following arguments:  
* `value` – value of field
* `values` – all form values
* `path` – field path, for example `user.email` or `cart.0.price`  
`path` argument can be used to get information about field location relative to other fields,
for example you can get index of array element:  
```tsx
import { useForm } from '@mantine/form';

const form = useForm({
mode: 'uncontrolled',
initialValues: { a: [{ b: 1 }, { b: 2 }] },
validate: {
a: {
b: (value, values, path) => (path === 'a.0.b' ? 'error' : null),
},
},
});
```",0.014863387978142076,3,0
eval2_q007,How can I validate that two fields match in Mantine useForm while showing the error only on the second field?,28739a24-9b19-43cb-ba4c-2c27c26a7b4f,"Topic: General
Section: Focus first input with error on form submit

`form.onSubmit` handler accepts two functions: the first function is called
with valid form values when validation passes, the second function is called
with form errors when validation fails. You can use the second function and
`form.getInputNode` to focus the first input with error:  
#### Example: FocusFirstInputWithError  
```tsx
function Demo() {
const form = useForm({
mode: 'uncontrolled',
initialValues: {
name: '',
email: '',
},

validate: {
name: isNotEmpty('Name is required'),
email: isEmail('Invalid email'),
},
});

return (
<form
onSubmit={form.onSubmit(
() => {},
(errors) => {
const firstErrorPath = Object.keys(errors)[0];
form.getInputNode(firstErrorPath)?.focus();
}
)}
>
<TextInput
withAsterisk
label=""Your name""
placeholder=""Your name""
key={form.key('name')}
{...form.getInputProps('name')}
/>

<TextInput
withAsterisk
label=""Your email""
placeholder=""your@email.com""
mt=""md""
key={form.key('email')}
{...form.getInputProps('email')}
/>

<Group justify=""flex-end"" mt=""md"">
<Button type=""submit"">Submit</Button>
</Group>
</form>
);
}
```",0.014541622760800843,4,0
eval2_q007,How can I validate that two fields match in Mantine useForm while showing the error only on the second field?,7fa6efc3-aa08-4fe2-8f07-e356f822e3fc,"Topic: formValidation
Section: Focus first invalid field

The second argument of the `form.onSubmit` function is a callback function that is called
with the [errors object](https://mantine.dev/form/errors) when form validation fails.
You can use this callback to focus the first invalid field or perform any other action.  
To get the DOM node of any input, use `form.getInputNode('path-to-field')`. Note that
in order for this feature to work, you need to spread `form.getInputProps('path-to-field')` to
the input element.  
#### Example: focusError  
```tsx
import { Button, Group, TextInput } from '@mantine/core';
import { isEmail, isNotEmpty, useForm } from '@mantine/form';

function Demo() {
const form = useForm({
mode: 'uncontrolled',
name: 'register-form',
initialValues: {
name: '',
email: '',
},

validate: {
name: isNotEmpty('Name is required'),
email: isEmail('Invalid email'),
},
});

return (
<form
onSubmit={form.onSubmit(
(values) => console.log(values),
(errors) => {
const firstErrorPath = Object.keys(errors)[0];
form.getInputNode(firstErrorPath)?.focus();
}
)}
>
<TextInput
withAsterisk
label=""Your name""
placeholder=""Your name""
key={form.key('name')}
{...form.getInputProps('name')}
/>

<TextInput
withAsterisk
label=""Your email""
placeholder=""your@email.com""
mt=""md""
key={form.key('email')}
{...form.getInputProps('email')}
/>

<Group justify=""flex-end"" mt=""md"">
<Button type=""submit"">Submit</Button>
</Group>
</form>
);
}
```",0.014407131011608624,5,0
eval2_q007,How can I validate that two fields match in Mantine useForm while showing the error only on the second field?,dbcfa01d-bf85-45f1-a696-38516043c0d1,"Topic: formValidation
Section: Function based validation

Another approach to handle validation is to provide a function to `validate`.
Function takes form values as single argument and should return object that contains
errors of corresponding fields. If field is valid or field validation is not required, you can either return null or simply omit it
from the validation results.  
#### Example: validateFunction  
```tsx
import { useForm } from '@mantine/form';
import { Box, TextInput, NumberInput, Button, Group } from '@mantine/core';

function Demo() {
const form = useForm<{ name: string; age: number | undefined }>({
mode: 'uncontrolled',
initialValues: { name: '', age: undefined },
validate: (values) => ({
name: values.name.length < 2 ? 'Too short name' : null,
age:
values.age === undefined
? 'Age is required'
: values.age < 18
? 'You must be at least 18'
: null,
}),
});

return (
<Box maw={340} mx=""auto"">
<form onSubmit={form.onSubmit((values) => console.log(values))}>
<TextInput
label=""Name""
placeholder=""Name""
key={form.key('name')}
{...form.getInputProps('name')}
/>
<NumberInput
mt=""sm""
label=""Age""
placeholder=""You age""
key={form.key('age')}
{...form.getInputProps('age')}
/>

<Group justify=""flex-end"" mt=""md"">
<Button type=""submit"">Submit</Button>
</Group>
</form>
</Box>
);
}
```",0.007936507936507936,6,1
eval2_q007,How can I validate that two fields match in Mantine useForm while showing the error only on the second field?,5ba13c70-aa34-42f3-9fe7-6dd1bf71b6ed,"Topic: formValidation
Section: Validation with rules object

To validate form with rules object, provide an object of functions which take field value as an argument
and return error message (any React node) or null if field is valid:  
#### Example: rulesValidation  
```tsx
import { useForm } from '@mantine/form';
import { NumberInput, TextInput, Button } from '@mantine/core';

function Demo() {
const form = useForm({
mode: 'uncontrolled',
initialValues: { name: '', email: '', age: 0 },

// functions will be used to validate values at corresponding key
validate: {
name: (value) => (value.length < 2 ? 'Name must have at least 2 letters' : null),
email: (value) => (/^\\S+@\\S+$/.test(value) ? null : 'Invalid email'),
age: (value) => (value < 18 ? 'You must be at least 18 to register' : null),
},
});

return (
<form onSubmit={form.onSubmit(console.log)}>
<TextInput
label=""Name""
placeholder=""Name""
key={form.key('name')}
{...form.getInputProps('name')}
/>
<TextInput
mt=""sm""
label=""Email""
placeholder=""Email""
key={form.key('email')}
{...form.getInputProps('email')}
/>
<NumberInput
mt=""sm""
label=""Age""
placeholder=""Age""
min={0}
max={99}
key={form.key('age')}
{...form.getInputProps('age')}
/>
<Button type=""submit"" mt=""sm"">
Submit
</Button>
</form>
);
}
```",0.0078125,7,1
eval2_q007,How can I validate that two fields match in Mantine useForm while showing the error only on the second field?,6c2c7fbc-05aa-4167-971a-fdbaa36a91bb,"Topic: formGetInputProps
Section: getInputProps handler

`form.getInputProps` returns an object with `value` (`defaultValue` for ""uncontrolled"" mode), `onChange`, `onFocus`, `onBlur`, `error`
and all props specified in `enhanceGetInputProps` function. Return value should be spread to the input component.  
You can pass the following options to `form.getInputProps` as second argument:  
* `type`: default `input`. Must be set to `checkbox` if the input requires `checked` prop instead of `value`.
* `withError`: default `type === 'input'`. Determines whether the returned object should contain an `error` property with
`form.errors[path]` value.
* `withFocus`: default `true`. Determines whether the returned object should contain an `onFocus` handler. If disabled, the touched
state will only change if value of the field has been changed.
* Any additional props that can be accessed with `enhanceGetInputProps` function. These props are not passed to the input.  
```tsx
import { Checkbox, TextInput } from '@mantine/core';
import { useForm } from '@mantine/form';

function Demo() {
const form = useForm({
mode: 'uncontrolled',
initialValues: { name: '', accepted: false },
validate: {
name: (value) => value.trim().length > 2,
},
});

return (
<>
<TextInput
key={form.key('name')}
{...form.getInputProps('name')}
/>
<Checkbox
key={form.key('accepted')}
{...form.getInputProps('accepted', { type: 'checkbox' })}
/>
</>
);
}
```",0.0078125,8,0
eval2_q007,How can I validate that two fields match in Mantine useForm while showing the error only on the second field?,c4e23ef0-77b3-43c4-95d6-4c270952a5ae,"Topic: use-form
Section: Validation

[Form validation guide](https://mantine.dev/form/validation/)  
```tsx
import { useForm } from '@mantine/form';

const form = useForm({
mode: 'uncontrolled',
initialValues: {
email: '',
user: {
firstName: '',
lastName: '',
},
},
validate: {
email: (value) => (value.length < 2 ? 'Invalid email' : null),
user: {
firstName: (value) =>
value.length < 2
? 'First name must have at least 2 letters'
: null,
},
},
});

// Validates all fields with specified `validate` function or schema, sets form.errors
form.validate();

// Validates single field at specified path, sets form.errors
form.validateField('user.firstName');

// Works the same way as form.validate but does not set form.errors
form.isValid();
form.isValid('user.firstName');
```",0.007692307692307693,9,0
eval2_q007,How can I validate that two fields match in Mantine useForm while showing the error only on the second field?,07d2e778-006a-4b73-a95a-95529c409a81,"Topic: General
Section: Why do I get hydration warning?

To fully understand this hydration warning, let's break it down how server-side rendering
works in React in general (Next.js, React Router, etc.):  
1. User navigates to the page in the browser.
2. The server renders the page and sends html code to the client.
3. html code is parsed by the browser and rendered on the screen (at this point, JavaScript has not been executed yet, uses has only html code).
4. JavaScript code is loaded and executed on the client.
5. Hydration process starts: React compares server-rendered html with client-rendered html and tries to match them.
If server-rendered html does not match client-rendered html, React will re-render the component on the client and
show a warning in the console (like the one above).  
Hydration mismatch error can happen in two cases:  
1. Server-rendered html does not match client-rendered html
2. Some code is executed on the client before React hydration starts and changes the html generated by the server  
In the example above, `ColorSchemeScript` component is used to change `data-mantine-color-scheme`
attribute on the `<html />` element before hydration, which causes the mismatch.
`ColorSchemeScript` component executes for following JavaScript code:  
```tsx
try {
var _colorScheme = window.localStorage.getItem(""mantine-color-scheme-value"");
var colorScheme = _colorScheme === ""light"" || _colorScheme === ""dark"" || _colorScheme === ""auto"" ? _colorScheme : ""light"";
var computedColorScheme = colorScheme !== ""auto"" ? colorScheme : window.matchMedia(""(prefers-color-scheme: dark)"").matches ? ""dark"" : ""light"";
document.documentElement.setAttribute(""data-mantine-color-scheme"", computedColorScheme);
} catch (e) {}
```  
This code is executed on the client before React hydration starts, which changes the html generated by the server and causes the warning.",0.007575757575757576,10,0
eval2_q007,How can I validate that two fields match in Mantine useForm while showing the error only on the second field?,34397b2e-8e33-4062-b376-57cfaf5b1d46,"Topic: formValidators
Section: Optional error

Last argument of all validator functions below is optional. If error is not set, then fields with failed validation will
only have invalid styles without error message:  
#### Example: validatorsEmpty  
```tsx
import { useForm, isNotEmpty, isEmail, isInRange, hasLength, matches } from '@mantine/form';
import { Button, Group, TextInput, NumberInput } from '@mantine/core';

function Demo() {
const form = useForm({
mode: 'uncontrolled',
initialValues: {
name: '',
job: '',
email: '',
favoriteColor: '',
age: 18,
},

validate: {
name: hasLength({ min: 2, max: 10 }),
job: isNotEmpty(),
email: isEmail(),
favoriteColor: matches(/^#([0-9a-f]{3}){1,2}$/),
age: isInRange({ min: 18, max: 99 }),
},
});

return (
<form onSubmit={form.onSubmit(() => {})}>
<TextInput
label=""Name""
placeholder=""Name""
withAsterisk
key={form.key('name')}
{...form.getInputProps('name')}
/>
<TextInput
label=""Your job""
placeholder=""Your job""
withAsterisk
mt=""md""
key={form.key('job')}
{...form.getInputProps('job')}
/>
<TextInput
label=""Your email""
placeholder=""Your email""
withAsterisk
mt=""md""
key={form.key('email')}
{...form.getInputProps('email')}
/>
<TextInput
label=""Your favorite color""
placeholder=""Your favorite color""
withAsterisk
mt=""md""
key={form.key('favoriteColor')}
{...form.getInputProps('favoriteColor')}
/>
<NumberInput
label=""Your age""
placeholder=""Your age""
withAsterisk
mt=""md""
key={form.key('age')}
{...form.getInputProps('age')}
/>

<Group justify=""flex-end"" mt=""md"">
<Button type=""submit"">Submit</Button>
</Group>
</form>
);
}
```",0.007575757575757576,11,0
eval2_q007,How can I validate that two fields match in Mantine useForm while showing the error only on the second field?,18e03aeb-b91b-4cc7-9d10-8abfce0d675e,"Topic: formNested
Section: Properties paths

Most of `form` handlers accept property path as the first argument.
Property path includes keys/indices of objects/arrays at which target property is contained:  
```tsx
import { useForm } from '@mantine/form';

const form = useForm({
mode: 'uncontrolled',
initialValues: {
user: {
firstName: 'John',
lastName: 'Doe',
},

fruits: [
{ name: 'Banana', available: true },
{ name: 'Orange', available: false },
],

deeply: {
nested: {
object: [{ item: 1 }, { item: 2 }],
},
},
},
});

// Props for input that is controlled by user object firstName field
form.getInputProps('user.firstName');

// Set value of `name` field that is contained in object at second position of fruits array:
form.setFieldValue('fruits.1.name', 'Carrot');

// Validate deeply nested field
form.validateField('deeply.nested.object.0.item');
```",0.007462686567164179,12,0
eval2_q007,How can I validate that two fields match in Mantine useForm while showing the error only on the second field?,3305166d-58db-4e4f-a251-6a4215a66aa6,"Topic: formValidation
Section: Clear field error on change

By default, field error is cleared when value changes. To change this, set `clearInputErrorOnChange` to `false`:  
```tsx
import { useForm } from '@mantine/form';

const form = useForm({
mode: 'uncontrolled',
clearInputErrorOnChange: false,
});
```  
#### Example: clearErrorOnChange  
```tsx
import { TextInput, Checkbox, Button, Group } from '@mantine/core';
import { useForm } from '@mantine/form';

function Demo() {
const form = useForm({
mode: 'uncontrolled',
clearInputErrorOnChange: false,
initialValues: {
email: '',
termsOfService: false,
},

validate: {
email: (value) => (/^\\S+@\\S+$/.test(value) ? null : 'Invalid email'),
},
});

return (
<form onSubmit={form.onSubmit((values) => console.log(values))}>
<TextInput
withAsterisk
label=""Email""
placeholder=""your@email.com""
key={form.key('email')}
{...form.getInputProps('email')}
/>

<Checkbox
mt=""md""
label=""I agree to sell my privacy""
key={form.key('termsOfService')}
{...form.getInputProps('termsOfService', { type: 'checkbox' })}
/>

<Group justify=""flex-end"" mt=""md"">
<Button type=""submit"">Submit</Button>
</Group>
</form>
);
}
```",0.007352941176470588,13,0
eval2_q007,How can I validate that two fields match in Mantine useForm while showing the error only on the second field?,ada84152-5deb-4822-980f-f919ec356bb5,"Topic: formNested
Section: Nested object values validation

```tsx
import { useForm } from '@mantine/form';

const form = useForm({
mode: 'uncontrolled',
initialValues: {
user: {
name: '',
occupation: '',
},
},

validate: {
user: {
name: (value) =>
value.length < 2 ? 'Name is too short' : null,
occupation: (value) =>
value.length < 2 ? 'Occupation is too short' : null,
},
},
});

form.validate();
form.errors; // -> { 'user.name': 'Name is too short', 'user.occupation': 'Occupation is too short' }
```",0.007352941176470588,14,0
eval2_q007,How can I validate that two fields match in Mantine useForm while showing the error only on the second field?,62c77b3f-b70c-40e4-a816-34ca7cb54a7a,"Topic: formValidation
Section: formRootRule

{fields}

{form.errors.employees && (
<Text c=""red"" size=""sm"" mt=""sm"">
{form.errors.employees}
</Text>
)}

<Group justify=""space-between"" mt=""md"">
<Button
variant=""default""
onClick={() => {
form.insertListItem('employees', { name: '', active: false, key: randomId() });
form.clearFieldError('employees');
}}
>
Add employee
</Button>
<Button type=""submit"">Submit</Button>
</Group>
</form>
);
}
```  
Another example is to validate an object fields combination:  
#### Example: rootRuleObject  
```tsx
import { Button, Text, TextInput } from '@mantine/core';
import { formRootRule, isNotEmpty, useForm } from '@mantine/form';

function Demo() {
const form = useForm({
mode: 'uncontrolled',
initialValues: {
user: {
firstName: '',
lastName: '',
},
},

validate: {
user: {
[formRootRule]: (value) =>
value.firstName.trim().length > 0 && value.firstName === value.lastName
? 'First name and last name cannot be the same'
: null,
firstName: isNotEmpty('First name is required'),
lastName: isNotEmpty('Last name is required'),
},
},
});

return (
<form onSubmit={form.onSubmit(() => {})}>
<TextInput
label=""First name""
placeholder=""First name""
{...form.getInputProps('user.firstName')}
/>
<TextInput
label=""Last name""
placeholder=""Last name""
mt=""md""
{...form.getInputProps('user.lastName')}
/>
{form.errors.user && (
<Text c=""red"" mt={5} fz=""sm"">
{form.errors.user}
</Text>
)}
<Button type=""submit"" mt=""lg"">
Submit
</Button>
</form>
);
}
```",0.007246376811594203,15,0
eval2_q007,How can I validate that two fields match in Mantine useForm while showing the error only on the second field?,c9052073-49f8-4783-b1d4-ce840bc66b98,"Topic: formStatus
Section: touchTrigger option

`touchTrigger` option allows customizing events that change touched state.
It accepts two options:  
* `change` (default) – field will be considered touched when its value changes or it has been focused
* `focus` – field will be considered touched only when it has been focused  
Example of using `focus` trigger:  
```tsx
import { useForm } from '@mantine/form';

const form = useForm({
mode: 'uncontrolled',
initialValues: { a: 1 },
touchTrigger: 'focus',
});

form.isTouched('a'); // -> false
form.setFieldValue('a', 2);
form.isTouched('a'); // -> false

// onFocus is called automatically when the user focuses the field
form.getInputProps('a').onFocus();
form.isTouched('a'); // -> true
```",0.007246376811594203,16,0
eval2_q007,How can I validate that two fields match in Mantine useForm while showing the error only on the second field?,2b2fb8e0-5f4b-43e5-9a0e-c2a5f6101772,"Topic: formValidation
Section: Validate fields on blur

To validate all fields on blur set `validateInputOnBlur` option to `true`:  
```tsx
import { useForm } from '@mantine/form';

const form = useForm({
mode: 'uncontrolled',
validateInputOnBlur: true,
});
```  
#### Example: blurValidation  
```tsx
import { useForm } from '@mantine/form';
import { NumberInput, TextInput, Button } from '@mantine/core';

function Demo() {
const form = useForm({
mode: 'uncontrolled',
validateInputOnBlur: true,
initialValues: { name: '', email: '', age: 0 },

// functions will be used to validate values at corresponding key
validate: {
name: (value) => (value.length < 2 ? 'Name must have at least 2 letters' : null),
email: (value) => (/^\\S+@\\S+$/.test(value) ? null : 'Invalid email'),
age: (value) => (value < 18 ? 'You must be at least 18 to register' : null),
},
});

return (
<form onSubmit={form.onSubmit(console.log)}>
<TextInput
label=""Name""
placeholder=""Name""
key={form.key('name')}
{...form.getInputProps('name')}
/>
<TextInput
mt=""sm""
label=""Email""
placeholder=""Email""
key={form.key('email')}
{...form.getInputProps('email')}
/>
<NumberInput
mt=""sm""
label=""Age""
placeholder=""Age""
min={0}
max={99}
key={form.key('age')}
{...form.getInputProps('age')}
/>
<Button type=""submit"" mt=""sm"">
Submit
</Button>
</form>
);
}
```  
You can also provide an array of fields paths to validate only those values:  
```tsx
import { FORM_INDEX, useForm } from '@mantine/form';

const form = useForm({
mode: 'uncontrolled',
validateInputOnBlur: ['name', 'email', `jobs.${FORM_INDEX}.title`],
});
```  
#### Example: blurFieldValidation  
```tsx
import { useForm, FORM_INDEX } from '@mantine/form';
import { NumberInput, TextInput, Button } from '@mantine/core';

function Demo() {
const form = useForm({
mode: 'uncontrolled',
validateInputOnBlur: [
'email',
'name',
// use FORM_INDEX to reference fields indices
`jobs.${FORM_INDEX}.title`,
],
initialValues: { name: '', email: '', age: 0, jobs: [{ title: '' }, { title: '' }] },",0.007142857142857143,17,0
eval2_q007,How can I validate that two fields match in Mantine useForm while showing the error only on the second field?,39f6d7bb-7ee0-4b68-aa2f-976215edf629,"Topic: formValidators
Section: matches

`matches` checks whether form value matches given regexp. If form value is not a string, validation will be failed.  
```tsx
import { matches, useForm } from '@mantine/form';

const form = useForm({
mode: 'uncontrolled',
initialValues: {
color: '',
},

validate: {
color: matches(/^#([0-9a-f]{3}){1,2}$/, 'Invalid color'),
},
});
```",0.007142857142857143,18,0
eval2_q007,How can I validate that two fields match in Mantine useForm while showing the error only on the second field?,778a3151-fbe2-4810-84ed-606274596ca7,"Topic: formValidation
Section: Validation in onSubmit handler

`form.onSubmit` accepts two arguments: first argument is `handleSubmit` function that will be called with form values, when validation
was completed without errors, second argument is `handleErrors` function, it is called with errors object when validation was completed with errors.  
You can use `handleErrors` function to perform certain actions when user tries to submit form without values,
for example, you can show a notification:  
#### Example: onSubmitErrors  
```tsx
import { useForm } from '@mantine/form';
import { TextInput, Button } from '@mantine/core';
import { notifications } from '@mantine/notifications';

function Demo() {
const form = useForm({
mode: 'uncontrolled',
initialValues: { name: '', email: '' },
validate: {
name: (value) => (value.length < 2 ? 'Name must have at least 2 letters' : null),
email: (value) => (/^\\S+@\\S+$/.test(value) ? null : 'Invalid email'),
},
});

const handleError = (errors: typeof form.errors) => {
if (errors.name) {
notifications.show({ message: 'Please fill name field', color: 'red' });
} else if (errors.email) {
notifications.show({ message: 'Please provide a valid email', color: 'red' });
}
};

return (
<form onSubmit={form.onSubmit(console.log, handleError)}>
<TextInput
label=""Name""
placeholder=""Name""
key={form.key('name')}
{...form.getInputProps('name')}
/>
<TextInput
mt=""sm""
label=""Email""
placeholder=""Email""
key={form.key('email')}
{...form.getInputProps('email')}
/>
<Button type=""submit"" mt=""sm"">
Submit
</Button>
</form>
);
}
```",0.007042253521126761,19,0
eval2_q007,How can I validate that two fields match in Mantine useForm while showing the error only on the second field?,8ceff6dd-40f7-4794-8cfa-3b0fc8691992,"Topic: formValidation
Section: Validate fields on change

To validate all fields on change set `validateInputOnChange` option to `true`:  
```tsx
import { useForm } from '@mantine/form';

const form = useForm({
mode: 'uncontrolled',
validateInputOnChange: true,
});
```  
#### Example: liveValidation  
```tsx
import { useForm } from '@mantine/form';
import { NumberInput, TextInput, Button, } from '@mantine/core';

function Demo() {
const form = useForm({
mode: 'uncontrolled',
validateInputOnChange: true,
initialValues: { name: '', email: '', age: 0 },

// functions will be used to validate values at corresponding key
validate: {
name: (value) => (value.length < 2 ? 'Name must have at least 2 letters' : null),
email: (value) => (/^\\S+@\\S+$/.test(value) ? null : 'Invalid email'),
age: (value) => (value < 18 ? 'You must be at least 18 to register' : null),
},
});

return (
<form onSubmit={form.onSubmit(console.log)}>
<TextInput
label=""Name""
placeholder=""Name""
key={form.key('name')}
{...form.getInputProps('name')}
/>
<TextInput
mt=""sm""
label=""Email""
placeholder=""Email""
key={form.key('email')}
{...form.getInputProps('email')}
/>
<NumberInput
mt=""sm""
label=""Age""
placeholder=""Age""
min={0}
max={99}
key={form.key('age')}
{...form.getInputProps('age')}
/>
<Button type=""submit"" mt=""sm"">
Submit
</Button>
</form>
);
}
```  
You can also provide an array of fields paths to validate only those values:  
```tsx
import { FORM_INDEX, useForm } from '@mantine/form';

const form = useForm({
mode: 'uncontrolled',
validateInputOnChange: [
'name',
'email',
`jobs.${FORM_INDEX}.title`,
],
});
```  
#### Example: liveFieldValidation  
```tsx
import { useForm, FORM_INDEX } from '@mantine/form';
import { NumberInput, TextInput, Button } from '@mantine/core';

function Demo() {
const form = useForm({
mode: 'uncontrolled',
validateInputOnChange: [
'email',
'name',
// use FORM_INDEX to reference fields indices
`jobs.${FORM_INDEX}.title`,
],
initialValues: { name: '', email: '', age: 0, jobs: [{ title: '' }, { title: '' }] },",0.007042253521126761,20,0
eval2_q007,How can I validate that two fields match in Mantine useForm while showing the error only on the second field?,e1e2f91d-155c-4950-af91-9eb6d003f74e,"Topic: formValidation
Section: Validate fields on change

function Demo() {
const form = useForm({
mode: 'uncontrolled',
validateInputOnChange: [
'email',
'name',
// use FORM_INDEX to reference fields indices
`jobs.${FORM_INDEX}.title`,
],
initialValues: { name: '', email: '', age: 0, jobs: [{ title: '' }, { title: '' }] },

// functions will be used to validate values at corresponding key
validate: {
name: (value) => (value.length < 2 ? 'Name must have at least 2 letters' : null),
email: (value) => (/^\\S+@\\S+$/.test(value) ? null : 'Invalid email'),
age: (value) => (value < 18 ? 'You must be at least 18 to register' : null),
jobs: {
title: (value) => (value.length < 2 ? 'Job must have at least 2 letters' : null),
},
},
});

return (
<form onSubmit={form.onSubmit(console.log)}>
<TextInput
label=""Name""
placeholder=""Name""
key={form.key('name')}
{...form.getInputProps('name')}
/>
<TextInput
mt=""sm""
label=""Email""
placeholder=""Email""
key={form.key('email')}
{...form.getInputProps('email')}
/>
<NumberInput
mt=""sm""
label=""Age""
placeholder=""Age""
min={0}
max={99}
key={form.key('age')}
{...form.getInputProps('age')}
/>
<TextInput
mt=""sm""
label=""Job 1""
placeholder=""Job 1""
key={form.key('jobs.0.title')}
{...form.getInputProps('jobs.0.title')}
/>
<TextInput
mt=""sm""
label=""Job 2""
placeholder=""Job 2""
key={form.key('jobs.1.title')}
{...form.getInputProps('jobs.1.title')}
/>
<Button type=""submit"" mt=""sm"">
Submit
</Button>
</form>
);
}
```",0.006944444444444444,21,0
eval2_q007,How can I validate that two fields match in Mantine useForm while showing the error only on the second field?,c6e895d7-bf6e-45af-bcc7-eb8ec9d272dc,"Topic: formSchemaValidation
Section: valibot

Installation:  
```bash
yarn add valibot mantine-form-valibot-resolver
```  
```bash
npm install valibot mantine-form-valibot-resolver
```  
Basic fields validation:  
```tsx
import { valibotResolver } from 'mantine-form-valibot-resolver';
import * as v from 'valibot';
import { useForm } from '@mantine/form';

const schema = v.object({
name: v.pipe(
v.string(),
v.minLength(2, 'Name should have at least 2 letters')
),
email: v.pipe(v.string(), v.email('Invalid email')),
age: v.pipe(
v.number(),
v.minValue(18, 'You must be at least 18 to create an account')
),
});

const form = useForm({
initialValues: {
name: '',
email: '',
age: 16,
},
validate: valibotResolver(schema),
});

form.validate();
form.errors;
// -> {
//  name: 'Name should have at least 2 letters',
//  email: 'Invalid email',
//  age: 'You must be at least 18 to create an account'
// }
```  
Nested fields validation:  
```tsx
import { valibotResolver } from 'mantine-form-valibot-resolver';
import * as v from 'valibot';
import { useForm } from '@mantine/form';

const nestedSchema = v.object({
nested: v.object({
field: v.pipe(
v.string(),
v.minLength(2, 'Field should have at least 2 letters')
),
}),
});

const form = useForm({
initialValues: {
nested: {
field: '',
},
},
validate: valibotResolver(nestedSchema),
});

form.validate();
form.errors;
// -> {
//  'nested.field': 'Field should have at least 2 letters',
// }
```  
List fields validation:  
```tsx
import { valibotResolver } from 'mantine-form-valibot-resolver';
import * as v from 'valibot';
import { useForm } from '@mantine/form';

const listSchema = v.object({
list: v.array(
v.object({
name: v.pipe(
v.string(),
v.minLength(2, 'Name should have at least 2 letters')
),
})
),
});

const form = useForm({
initialValues: {
list: [{ name: '' }],
},
validate: valibotResolver(listSchema),
});",0.00684931506849315,22,0
eval2_q007,How can I validate that two fields match in Mantine useForm while showing the error only on the second field?,0a94b730-b6ba-41a5-8c17-7c397caf8048,"Topic: use-field
Section: use-field API

`use-field` hook accepts the following options object as a single argument:  
```tsx
interface UseFieldInput<T> {
/** Field mode, controlled by default */
mode?: 'controlled' | 'uncontrolled';

/** Initial field value */
initialValue: T;

/** Initial touched value */
initialTouched?: boolean;

/** Initial field error message */
initialError?: React.ReactNode;

/** Called with updated value when the field value changes */
onValueChange?: (value: T) => void;

/** Determines whether the field should be validated when value changes, false by default */
validateOnChange?: boolean;

/** Determines whether the field should be validated when it loses focus, false by default */
validateOnBlur?: boolean;

/** Determines whether the field should clear error message when value changes, true by default */
clearErrorOnChange?: boolean;

/** A function to validate field value, can be sync or async */
validate?: (value: T) => React.ReactNode | Promise<React.ReactNode>;

/** Field type, input by default */
type?: 'input' | 'checkbox';

/** A function to resolve validation error from the result returned from validate function, should return react node */
resolveValidationError?: (error: unknown) => React.ReactNode;
}
```  
And returns the following object:  
```tsx
export interface UseFieldReturnType<ValueType> {
/** Returns props to pass to the input element */
getInputProps: () => {
/* props for input component */
};

/** Returns current input value */
getValue: () => ValueType;

/** Sets input value to the given value */
setValue: (value: ValueType) => void;

/** Resets field value to initial state, sets touched state to false, sets error to null */
reset: () => void;

/** Validates current input value when called */
validate: () => Promise<React.ReactNode | void>;

/** Set to true when async validate function is called, stays true until the returned promise resolves */
isValidating: boolean;

/** Current error message */
error: React.ReactNode;",0.006756756756756757,23,0
eval2_q007,How can I validate that two fields match in Mantine useForm while showing the error only on the second field?,14ca02ed-07aa-4da1-b5b9-52156b0ca147,"Topic: General
Section: What should I do instead?

If you are building a form that requires usage of Mantine inputs
with custom UI, you should validate form data after it has been
submitted. You can use [@mantine/form](https://mantine.dev/form/use-form) package
to perform form validation on submit.",0.006756756756756757,24,0
eval2_q007,How can I validate that two fields match in Mantine useForm while showing the error only on the second field?,c53f699a-b484-457f-aafc-2c58fa0741ea,"Topic: formUncontrolled
Section: form.getInputProps

[form.getInputProps](https://mantine.dev/form/get-input-props/) returns different props for controlled
and uncontrolled modes. In controlled mode, the returned object has `value` prop,
while in uncontrolled mode it has `defaultValue` prop.  
Uncontrolled mode relies on `key` returned from `form.key()` to update
components when `form.setFieldValue` or `form.setValues` are called. You should
set `key` supplied by `form.key()` to the input component to ensure that it has
updated value:  
```tsx
import { useForm } from '@mantine/form';

function Demo() {
const form = useForm({
mode: 'uncontrolled',
initialValues: { text: '' },
});

return (
<input {...form.getInputProps('text')} key={form.key('text')} />
);
}
```  
In case you need to have a [list of fields](https://mantine.dev/form/nested/#nested-arrays),
do not pass `key` to the input component directly, instead add a wrapper
element and pass `key` to it:  
```tsx
import { useForm } from '@mantine/form';
import { randomId } from '@mantine/hooks';

// ❌ Incorrect: Do not override key prop, even in lists
function Demo() {
const form = useForm({
mode: 'uncontrolled',
initialValues: {
jobs: [{ company: 'Google' }, { company: 'Facebook' }],
},
});

const fields = form.getValues().jobs.map((_, index) => (
<input
{...form.getInputProps(`jobs.${index}.company`)}
key={index}
/>
));

return <form>{fields}</form>;
}

// ✅ Correct: Add wrapper element and pass key to it
function Demo() {
const form = useForm({
mode: 'uncontrolled',
initialValues: {
jobs: [
{ company: 'Google', key: randomId() },
{ company: 'Facebook', key: randomId() },
],
},
});

const fields = form.getValues().jobs.map((item, index) => (
<div key={item.key}>
<input
{...form.getInputProps(`jobs.${index}.company`)}
key={form.key(`jobs.${index}.company`)}
/>
</div>
));

return <form>{fields}</form>;
}
```",0.006666666666666667,25,0
eval2_q009,How do I set up MantineProvider in Next.js App Router (app/layout.tsx)?,0b3ccb37-a5b3-4812-9110-b180a2bf88ed,"Topic: NextJs
Section: Setup with app router

Add [MantineProvider](https://mantine.dev/theming/mantine-provider), [ColorSchemeScript](https://mantine.dev/theming/color-schemes)
and styles imports to the `app/layout.tsx` file:  
```tsx
// Import styles of packages that you've installed.
// All packages except `@mantine/hooks` require styles imports
import '@mantine/core/styles.css';

import { ColorSchemeScript, MantineProvider, mantineHtmlProps } from '@mantine/core';

export const metadata = {
title: 'My Mantine app',
description: 'I have followed setup instructions carefully',
};

export default function RootLayout({
children,
}: {
children: React.ReactNode;
}) {
return (
<html lang=""en"" {...mantineHtmlProps}>
<head>
<ColorSchemeScript />
</head>
<body>
<MantineProvider>{children}</MantineProvider>
</body>
</html>
);
}
```  
All set! Start development server:  
```bash
npm run dev
```",0.01639344262295082,1,3
eval2_q009,How do I set up MantineProvider in Next.js App Router (app/layout.tsx)?,4ea3f15c-81d1-4d57-8401-666532d7fd53,"Topic: Emotion
Section: Usage with Next.js app router

useServerInsertedHTML(() => {
const names = flush();
if (names.length === 0) return null;
let styles = '';
for (const name of names) {
styles += cache.inserted[name];
}
return (
<style
data-emotion={`${cache.key} ${names.join(' ')}`}
dangerouslySetInnerHTML={{
__html: styles,
}}
/>
);
});

return <CacheProvider value={cache}>{children}</CacheProvider>;
}
```  
Add `RootStyleRegistry`, `MantineEmotionProvider` and `emotionTransform` to `app/layout.tsx`.
It should look something like this:  
```tsx
import '@mantine/core/styles.css';

import { ColorSchemeScript, MantineProvider } from '@mantine/core';
import {
emotionTransform,
MantineEmotionProvider,
} from '@mantine/emotion';
import { RootStyleRegistry } from './EmotionRootStyleRegistry';

export const metadata = {
title: 'Mantine Next.js template',
description: 'I am using Mantine with Next.js!',
};

export default function RootLayout({ children }: { children: any }) {
return (
<html lang=""en"">
<head>
<ColorSchemeScript />
<link rel=""shortcut icon"" href=""/favicon.svg"" />
<meta
name=""viewport""
content=""minimum-scale=1, initial-scale=1, width=device-width, user-scalable=no""
/>
</head>
<body>
<RootStyleRegistry>
<MantineEmotionProvider>
<MantineProvider stylesTransform={emotionTransform}>
{children}
</MantineProvider>
</MantineEmotionProvider>
</RootStyleRegistry>
</body>
</html>
);
}
```  
Done! You can now use `sx`, `styles` props and `createStyles` in your application.
Note that `'use client'` is required in most components that use `sx`, `styles` or `createStyles`:  
```tsx
'use client';

import { Box } from '@mantine/core';

export default function HomePage() {
return (
<Box
sx={(theme, u) => ({
padding: 40,

[u.light]: {
backgroundColor: theme.colors.blue[0],
color: theme.colors.blue[9],

'&:hover': {
backgroundColor: theme.colors.blue[1],
},
},
})}
>
Box with emotion sx prop
</Box>
);
}
```",0.015877016129032258,2,2
eval2_q009,How do I set up MantineProvider in Next.js App Router (app/layout.tsx)?,c6a14a91-ab0d-4bf5-b409-20a2aebe9cf0,"Topic: NextJs
Section: app + pages router together

If you use both app and pages router in one application, you need to setup both `pages/_app.tsx`
and `app/layout.tsx` files as described above.",0.015417457305502846,3,0
eval2_q009,How do I set up MantineProvider in Next.js App Router (app/layout.tsx)?,43525368-8d04-4c5e-9dd6-178bc8467a73,"Topic: ReactRouter
Section: Setup

Add styles imports, [MantineProvider](https://mantine.dev/theming/mantine-provider/) and [ColorSchemeScript](https://mantine.dev/theming/color-schemes) to `app/root.tsx`:  
```tsx
// Import styles of packages that you've installed.
// All packages except `@mantine/hooks` require styles imports
import '@mantine/core/styles.css';

import {
Links,
Meta,
Outlet,
Scripts,
ScrollRestoration,
} from ""react-router"";
import { ColorSchemeScript, MantineProvider, mantineHtmlProps } from '@mantine/core';

export function Layout({ children }: { children: React.ReactNode }) {
return (
<html lang=""en"" {...mantineHtmlProps}>
<head>
<meta charSet=""utf-8"" />
<meta name=""viewport"" content=""width=device-width, initial-scale=1"" />
<ColorSchemeScript />
<Meta />
<Links />
</head>
<body>
<MantineProvider>{children}</MantineProvider>
<ScrollRestoration />
<Scripts />
</body>
</html>
);
}

// ... other app/root.tsx content
```  
All set! Start development server:  
```bash
npm run dev
```",0.014603174603174604,4,0
eval2_q009,How do I set up MantineProvider in Next.js App Router (app/layout.tsx)?,5cdf75c6-2aa1-43c8-8d9e-f9027b0c7c62,"Topic: General
Section: How to fix hydration warning?

To fix the hydration warning, spread `mantineHtmlProps` on the `<html />` element:  
```tsx
// app/layout.tsx
import { ColorSchemeScript, MantineProvider, mantineHtmlProps } from '@mantine/core';

export default function RootLayout({ children }: { children: any }) {
return (
<html lang=""en"" {...mantineHtmlProps}>
<head>
<ColorSchemeScript />
<link rel=""shortcut icon"" href=""/favicon.svg"" />
<meta
name=""viewport""
content=""minimum-scale=1, initial-scale=1, width=device-width, user-scalable=no""
/>
</head>
<body>
<MantineProvider>{children}</MantineProvider>
</body>
</html>
);
}
```",0.014495798319327732,5,0
eval2_q009,How do I set up MantineProvider in Next.js App Router (app/layout.tsx)?,35757784-53a9-43fc-94ef-4a55b380263a,"Topic: NextJs
Section: app router tree shaking

To enable tree shaking with app router, enable experimental `optimizePackageImports` feature in
your `next.config.mjs`:  
```tsx
export default {
// ...other configuration
experimental: {
optimizePackageImports: ['@mantine/core', '@mantine/hooks'],
},
};
```",0.013708920187793428,6,0
eval2_q009,How do I set up MantineProvider in Next.js App Router (app/layout.tsx)?,b928b659-8d55-46bf-82c5-855ba3ab32ba,"Topic: ColorSchemes
Section: With disabled JavaScript

If you need to support users with disabled JavaScript, you need to set `data-mantine-color-scheme`
attribute on the `<html />` element manually.  
Example with Next.js app router that supports disabled JavaScript:  
```tsx
import '@mantine/core/styles.css';

import { ColorSchemeScript, MantineProvider } from '@mantine/core';

export const metadata = {
title: 'My Mantine app',
description: 'I have followed setup instructions carefully',
};

export default function RootLayout({
children,
}: {
children: React.ReactNode;
}) {
return (
<html lang=""en"" data-mantine-color-scheme=""light"">
<head>
<ColorSchemeScript />
</head>
<body>
<MantineProvider>{children}</MantineProvider>
</body>
</html>
);
}
```",0.007936507936507936,7,0
eval2_q009,How do I set up MantineProvider in Next.js App Router (app/layout.tsx)?,0f2122dc-847c-406e-a18a-bbb7ce358b61,"Topic: Emotion
Section: Usage with Next.js app router

[View example repository with full setup](https://github.com/mantinedev/next-app-min-template/tree/emotion)  
Install dependencies:  
```bash
yarn add @mantine/emotion @emotion/react @emotion/cache @emotion/serialize @emotion/utils @emotion/server
```  
```bash
npm install @mantine/emotion @emotion/react @emotion/cache @emotion/serialize @emotion/utils @emotion/server
```  
Create `app/emotion.d.ts` file with the following content:  
```tsx
import '@mantine/core';

import type { EmotionStyles, EmotionSx } from '@mantine/emotion';

declare module '@mantine/core' {
export interface BoxProps {
sx?: EmotionSx;
styles?: EmotionStyles;
}
}
```  
Create `app/EmotionRootStyleRegistry.tsx` file with the following content:  
```tsx
'use client';

import { useState } from 'react';
import { useServerInsertedHTML } from 'next/navigation';
import createCache from '@emotion/cache';
import { CacheProvider } from '@emotion/react';

export function RootStyleRegistry({
children,
}: {
children: React.ReactNode;
}) {
const [{ cache, flush }] = useState(() => {
const cache = createCache({ key: 'my' });
cache.compat = true;
const prevInsert = cache.insert;
let inserted: string[] = [];
cache.insert = (...args) => {
const serialized = args[1];
if (cache.inserted[serialized.name] === undefined) {
inserted.push(serialized.name);
}
return prevInsert(...args);
};
const flush = () => {
const prevInserted = inserted;
inserted = [];
return prevInserted;
};
return { cache, flush };
});

useServerInsertedHTML(() => {
const names = flush();
if (names.length === 0) return null;
let styles = '';
for (const name of names) {
styles += cache.inserted[name];
}
return (
<style
data-emotion={`${cache.key} ${names.join(' ')}`}
dangerouslySetInnerHTML={{
__html: styles,
}}
/>
);
});",0.0078125,8,1
eval2_q009,How do I set up MantineProvider in Next.js App Router (app/layout.tsx)?,1a02fa1a-7eb6-475e-9793-9a1d24774260,"Topic: GettingStartedDates
Section: Localization and server components

To add localization you must import `import 'dayjs/locale/x';` in your application (`x` is locale name)
and set `locale` either on `DatesProvider` or on each component individually.  
Example of setting locale on DatesProvider:  
```tsx
import 'dayjs/locale/ru';

import { DatesProvider } from '@mantine/dates';

function Demo() {
return (
<DatesProvider settings={{ locale: 'ru' }}>
{/* Your app  */}
</DatesProvider>
);
}
```  
The code above works in all environments, except Next.js app router.
If you are using Next.js app router, you must add `'use client';` to the
top of the file where you are importing `dayjs/locale/x` – locale data
is required both on client and server.  
```tsx
'use client';

import 'dayjs/locale/ru';

import { DatesProvider } from '@mantine/dates';

function Demo() {
return (
<DatesProvider settings={{ locale: 'ru' }}>
{/* Your app  */}
</DatesProvider>
);
}
```",0.007692307692307693,9,0
eval2_q009,How do I set up MantineProvider in Next.js App Router (app/layout.tsx)?,7f857570-58da-4041-b4ec-6b610d11892b,"Topic: NextJs
Section: Setup with pages router

Add styles imports and [MantineProvider](https://mantine.dev/theming/mantine-provider) to the `pages/_app.tsx` file:  
```tsx
// Import styles of packages that you've installed.
// All packages except `@mantine/hooks` require styles imports
import '@mantine/core/styles.css';

import type { AppProps } from 'next/app';
import { createTheme, MantineProvider } from '@mantine/core';

const theme = createTheme({
/** Put your mantine theme override here */
});

export default function App({ Component, pageProps }: AppProps) {
return (
<MantineProvider theme={theme}>
<Component {...pageProps} />
</MantineProvider>
);
}
```  
Create `pages/_document.tsx` file with [ColorSchemeScript](https://mantine.dev/theming/color-schemes) component.
Note that it is required even if you use only one color scheme in your application.  
```tsx
import { Head, Html, Main, NextScript } from 'next/document';
import { ColorSchemeScript, mantineHtmlProps } from '@mantine/core';

export default function Document() {
return (
<Html lang=""en"" {...mantineHtmlProps}>
<Head>
<ColorSchemeScript defaultColorScheme=""auto"" />
</Head>
<body>
<Main />
<NextScript />
</body>
</Html>
);
}
```  
All set! Start development server:  
```bash
npm run dev
```",0.007692307692307693,10,0
eval2_q009,How do I set up MantineProvider in Next.js App Router (app/layout.tsx)?,83e5a116-3c93-4ddc-ad9a-0e2ed3a79b43,"Topic: General
Section: Overview

# MantineProvider was not found in component tree. What should I do?
Learn how to resolve MantineProvider issues  
<ErrorMessage error=""@mantine/core: MantineProvider was not found in component tree, make sure you have it in your app."" />  
The error above occurs in the following cases:  
* You do not have `MantineProvider` in your app at all
* You are rendering Mantine components outside of `MantineProvider` context
* You have different versions of `@mantine/*` packages in your application.
For example, you have `@mantine/core@7.0.0` and `@mantine/dates@7.1.0` installed.
* There was an issue during packages installation. Usually this happens with pnpm.
* Your app has multiple instances of `@mantine/core` package in the bundle. This may
happen if your project is a monorepo and you have multiple node\_modules folders.  
Steps to resolve the issue:  
* Make sure that you have `MantineProvider` in your app and it wraps all Mantine components.
* Make sure that you have only one version of `@mantine/core` in your app. If you are using
monorepo, make sure all packages depend on the same version of `@mantine/core`.
* Reinstall dependencies by removing `node_modules` folder and running `npm install` or
`yarn install` again.
* If you still have issues, you can use [one of the official templates](https://mantine.dev/getting-started/#get-started-with-a-template) as reference.",0.007575757575757576,11,0
eval2_q009,How do I set up MantineProvider in Next.js App Router (app/layout.tsx)?,deaaf237-2224-453d-8777-f16563b6beaa,"Topic: Emotion
Section: Usage with Next.js pages router

import Head from 'next/head';
import { MantineProvider } from '@mantine/core';
import {
emotionTransform,
MantineEmotionProvider,
} from '@mantine/emotion';
import { emotionCache } from '../emotion/cache';

export default function App({ Component, pageProps }: any) {
return (
<MantineEmotionProvider cache={emotionCache}>
<MantineProvider stylesTransform={emotionTransform}>
<Head>
<title>Mantine Template</title>
<meta
name=""viewport""
content=""minimum-scale=1, initial-scale=1, width=device-width, user-scalable=no""
/>
<link rel=""shortcut icon"" href=""/favicon.svg"" />
</Head>
<Component {...pageProps} />
</MantineProvider>
</MantineEmotionProvider>
);
}
```  
Done! You can now use `sx`, `styles` props and `createStyles` in your application:  
```tsx
import { Box } from '@mantine/core';

function Demo() {
return (
<Box
sx={(theme, u) => ({
padding: 40,

[u.light]: {
backgroundColor: theme.colors.blue[0],
color: theme.colors.blue[9],

'&:hover': {
backgroundColor: theme.colors.blue[1],
},
},
})}
>
Box with emotion sx prop
</Box>
);
}
```",0.007575757575757576,12,1
eval2_q009,How do I set up MantineProvider in Next.js App Router (app/layout.tsx)?,0675135d-5dc6-4456-890a-0e9e3de3d521,"Topic: MantineProvider
Section: Usage

```tsx
import { createTheme, MantineProvider } from '@mantine/core';

const theme = createTheme({
/** Your theme override here */
});

function Demo() {
return (
<MantineProvider theme={theme}>
{/* Your app here */}
</MantineProvider>
);
}
```",0.007462686567164179,13,1
eval2_q009,How do I set up MantineProvider in Next.js App Router (app/layout.tsx)?,911d9b4e-93d2-4cf0-8fbe-fc1931fb7c24,"Topic: NextJs
Section: Troubleshooting

If you have any issues with Mantine in your Next.js application, please check
[Help Center article](https://help.mantine.dev/q/server-components) that covers
most common issues with app router and server components.",0.007462686567164179,14,0
eval2_q009,How do I set up MantineProvider in Next.js App Router (app/layout.tsx)?,299c2690-956e-4dfb-87fe-266a7fc85ab2,"Topic: GettingStarted
Section: Get started without framework

const theme = createTheme({
/** Put your mantine theme override here */
});

function Demo() {
return (
<MantineProvider theme={theme}>
{/* Your app here */}
</MantineProvider>
);
}
```  
If your application has server side rendering, add [ColorSchemeScript](https://mantine.dev/theming/color-schemes)
to the `<head />` of your application and spread `mantineHtmlProps` on the `<html />` element
to [avoid seeing a hydration warning](https://help.mantine.dev/q/color-scheme-hydration-warning):  
```tsx
import { ColorSchemeScript, mantineHtmlProps } from '@mantine/core';

function Demo() {
return (
<html lang=""en"" {...mantineHtmlProps}>
<head>
<meta charSet=""UTF-8"" />
<meta
name=""viewport""
content=""width=device-width, initial-scale=1.0""
/>
<title>My awesome app</title>

<ColorSchemeScript />
</head>
<body>{/* Your app here */}</body>
</html>
);
}
```  
All set! You can now use Mantine components in your application.",0.007246376811594203,15,1
eval2_q009,How do I set up MantineProvider in Next.js App Router (app/layout.tsx)?,fe8cb5a5-ea31-43b0-9a7f-e15ebe33bddd,"Topic: GettingStarted
Section: Can I use Mantine with create-react-app?

[Create React App](https://create-react-app.dev/) was deprecated in early 2023 ([comment from maintainers](https://github.com/reactjs/react.dev/pull/5487#issuecomment-1409720741)).
It is not recommended to use it for new projects. It is recommended to use [Vite](https://vitejs.dev/) or [Next.js](https://nextjs.org/) instead.
Starting from version 7.0, certain Mantine styling features are no longer officially supported in Create React App.
If you still prefer to use Create React App, follow [this guide](https://help.mantine.dev/q/can-i-use-mantine-with-cra).",0.007246376811594203,16,0
eval2_q009,How do I set up MantineProvider in Next.js App Router (app/layout.tsx)?,dabc39c6-97eb-481d-9019-513e05263071,"Topic: General
Section: Example hydration warning

<ErrorMessage error=""Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used. > -data-mantine-color-scheme='light'"" />  
Minimal Next.js code that has this warning (Next.js used as an example, the same logic can be applied to any other framework with server-side rendering):  
```tsx
// app/layout.tsx
import { ColorSchemeScript, MantineProvider } from '@mantine/core';

export default function RootLayout({ children }: { children: any }) {
return (
<html lang=""en"">
<head>
<ColorSchemeScript />
<link rel=""shortcut icon"" href=""/favicon.svg"" />
<meta
name=""viewport""
content=""minimum-scale=1, initial-scale=1, width=device-width, user-scalable=no""
/>
</head>
<body>
<MantineProvider>{children}</MantineProvider>
</body>
</html>
);
}
```",0.007142857142857143,17,0
eval2_q009,How do I set up MantineProvider in Next.js App Router (app/layout.tsx)?,a80e23cc-2239-4797-9c00-d68306b49b6f,"Topic: Modals manager
Section: Setup ModalsProvider

Wrap your app with `ModalsProvider` component:  
```tsx
import { MantineProvider } from '@mantine/core';
import { ModalsProvider } from '@mantine/modals';

function Demo() {
return (
<MantineProvider>
<ModalsProvider>{/* Your app here */}</ModalsProvider>
</MantineProvider>
);
}
```",0.007042253521126761,18,0
eval2_q009,How do I set up MantineProvider in Next.js App Router (app/layout.tsx)?,5cdf8b15-6457-43e0-9c22-1b7b75d8c081,"Topic: MantineProvider
Section: Overview

# MantineProvider  
`MantineProvider` provides a [theme object](https://mantine.dev/theming/theme-object) context value, manages color scheme
changes and injects [CSS variables](https://mantine.dev/styles/css-variables/). It must be rendered at the root of your
application and should be used only once.",0.006944444444444444,19,0
eval2_q009,How do I set up MantineProvider in Next.js App Router (app/layout.tsx)?,8e5aca3f-fba9-4054-9a31-5a3e2832a6f2,"Topic: Emotion
Section: Caveats and support

[Emotion](https://emotion.sh/) is a runtime CSS-in-JS library – styles are generated
and injected into the DOM at runtime. This approach has some limitations:  
* **Limited server-side rendering support** – modern frameworks like Next.js with app router
do not fully support emotion or require additional configuration.
* **Runtime overhead** – styles are generated and injected at runtime, which can lead to
performance issues on pages with a lot of components.
* **Additional bundle size** – your bundle will include `@emotion/react` (21.2kB minified),
`@mantine/emotion` (~2kb minified) and all styles that you use in your components.  
`@mantine/emotion` package can be used with the following frameworks:  
* **Vite** and **CRA** with basic setup
* **Next.js with pages router** with additional setup for server side rendering provided by the package
* **Next.js with app router** with additional setup for server side rendering provided by Emotion
* Any other framework that does not require server-side rendering with basic setup  
There is no official support (the package probably can be used but it's not tested and documentation is not provided) for:  
* **React Router**
* **Gatsby**
* **Redwood**
* Any other framework that has server-side rendering  
Note that Emotion is not recommended for new projects, if you are starting a new project with Mantine,
consider using [CSS modules](https://mantine.dev/styles/css-modules/) instead.",0.006944444444444444,20,0
eval2_q009,How do I set up MantineProvider in Next.js App Router (app/layout.tsx)?,3fb18099-53d9-42f0-bc40-dcae97b4842d,"Topic: SevenToEight
Section: CodeHighlight usage

[@mantine/code-highlight](https://mantine.dev/x/code-highlight) package no longer depends on [highlight.js](https://highlightjs.org).
You can follow the [updated documentation](https://mantine.dev/x/code-highlight/) to set up syntax highlighting with [shiki](https://shiki.matsu.io/).  
If you want to continue using [highlight.js](https://highlightjs.org/), in your application,
install `highlight.js` package:  
```bash
yarn add highlight.js
```  
```bash
npm install highlight.js
```  
Then wrap your app with `CodeHighlightAdapterProvider` and provide `createHighlightJsAdapter` as `adapter` prop:  
```tsx
import { MantineProvider } from '@mantine/core';
import { CodeHighlightAdapterProvider, createHighlightJsAdapter } from '@mantine/code-highlight';
import hljs from 'highlight.js/lib/core';
import tsLang from 'highlight.js/lib/languages/typescript';

hljs.registerLanguage('typescript', tsLang);

const highlightJsAdapter = createHighlightJsAdapter(hljs);

function App() {
return (
<MantineProvider>
<CodeHighlightAdapterProvider adapter={highlightJsAdapter}>
{/* Your app here */}
</CodeHighlightAdapterProvider>
</MantineProvider>
);
}
```  
Then you need to add styles of one of the highlight.js themes to your application.
You can do that by importing css file from `highlight.js` package or adding it via
CDN link to the head of your application:  
```html
<link
rel=""stylesheet""
href=""https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css""
/>
```  
After that, you can use `CodeHighlight` component in your application the same way you did in 7.x version.",0.00684931506849315,21,0
eval2_q009,How do I set up MantineProvider in Next.js App Router (app/layout.tsx)?,4fbdd9c8-39d2-4f08-8642-87ea3c08c774,"Topic: Redwood
Section: Setup

Add styles imports, [MantineProvider](https://mantine.dev/theming/mantine-provider) and [ColorSchemeScript](https://mantine.dev/theming/color-schemes)
to `web/src/App.tsx` file:  
```tsx
// Import styles of packages that you've installed.
// All packages except `@mantine/hooks` require styles imports
import '@mantine/core/styles.css';

import { FatalErrorBoundary, RedwoodProvider } from '@redwoodjs/web';
import { RedwoodApolloProvider } from '@redwoodjs/web/apollo';
import FatalErrorPage from 'src/pages/FatalErrorPage';
import Routes from 'src/Routes';
import { ColorSchemeScript, MantineProvider } from '@mantine/core';

const App = () => (
<FatalErrorBoundary page={FatalErrorPage}>
<RedwoodProvider titleTemplate=""%PageTitle | %AppTitle"">
<ColorSchemeScript />
<MantineProvider>
<RedwoodApolloProvider>
<Routes />
</RedwoodApolloProvider>
</MantineProvider>
</RedwoodProvider>
</FatalErrorBoundary>
);

export default App;
```  
All set! Start development server:  
```bash
yarn rw dev
```",0.00684931506849315,22,0
eval2_q009,How do I set up MantineProvider in Next.js App Router (app/layout.tsx)?,092378dc-9185-4fbf-8afb-cb7ea1ce589a,"Topic: General
Section: How can I customize colors with theme?

You can define custom colors in the [theme object](https://mantine.dev/theming/theme-object).  
```tsx
import { createTheme, MantineProvider } from '@mantine/core';

const theme = createTheme({
colors: {
sepia: [
'#F4ECD8',
'#EAD8B7',
'#DFC29A',
'#D4AC7E',
'#C99862',
'#BD8447',
'#B2702D',
'#A55C15',
'#924908',
'#7A3704',
],
},
});

function Demo() {
return (
<MantineProvider theme={theme}>
<App />
</MantineProvider>
);
}
```  
Then you can reference these values in components and `.css` files:  
```scss
body {
background-color: var(--mantine-color-sepia-0);
color: var(--mantine-color-sepia-9);
}
```",0.006756756756756757,23,0
eval2_q009,How do I set up MantineProvider in Next.js App Router (app/layout.tsx)?,a5324f81-ed2f-4155-8508-ec1008490fd0,"Topic: Vite
Section: Setup

Add styles imports and [MantineProvider](https://mantine.dev/theming/mantine-provider/) to your application root component (usually `App.tsx`):  
```tsx
// Import styles of packages that you've installed.
// All packages except `@mantine/hooks` require styles imports
import '@mantine/core/styles.css';

import { MantineProvider } from '@mantine/core';

export default function App() {
return <MantineProvider>{/* Your app here */}</MantineProvider>;
}
```  
All set! Start development server:  
```bash
npm run dev
```",0.006756756756756757,24,0
eval2_q010,"In Mantine, which styling approach is most performant at runtime, and why?",885a82e5-dfd3-42d4-af0b-f1040ec1881e,"Topic: StylesPerformance
Section: CSS modules

[CSS modules](https://mantine.dev/styles/css-modules) is the most performant way to apply styles –
this approach generates static CSS that is never re-evaluated. 99% of Mantine components
styles are generated with CSS modules – components are optimized out of the box.  
In most cases, it is recommended to use [CSS modules](https://mantine.dev/styles/css-modules) to style your components as well.
You can apply styles to HTML elements with `className` prop and to Mantine components with `className`,
`classNames` props.  
Applying styles with `className`:  
#### Example: className  
```tsx
import { Box } from '@mantine/core';
import classes from './Demo.module.css';

function Demo() {
return (
<Box className={classes.box}>
Box component with <span className={classes.highlight}>some styles</span>
</Box>
);
}
```  
Applying styles with `classNames` (see [Styles API guide](https://mantine.dev/styles/styles-api) to learn more):  
#### Example: classNames  
```tsx
import { useState } from 'react';
import { TextInput } from '@mantine/core';
import classes from './Demo.module.css';

function Demo() {
const [value, setValue] = useState('');
const [focused, setFocused] = useState(false);
const floating = focused || value.length > 0 || undefined;

return (
<TextInput
label=""Floating label input""
labelProps={{ 'data-floating': floating }}
classNames={{
root: classes.root,
input: classes.input,
label: classes.label,
}}
onFocus={() => setFocused(true)}
onBlur={() => setFocused(false)}
value={value}
onChange={(event) => setValue(event.currentTarget.value)}
/>
);
}
```",0.016009221311475412,1,3
eval2_q010,"In Mantine, which styling approach is most performant at runtime, and why?",216f4ddd-3eb2-4e31-a0e0-78d1511bf630,"Topic: General
Section: Why nested inline styles are not supported?

Mantine does not use CSS-in-JS library for styling – all styles are either in CSS files
or inline in the `style` attribute which does not support nested styles. Mantine does not
use CSS-in-JS to keep bundle size small, provide support for server-side rendering and
improve performance. You can learn more about performance [in the styles performance guide](https://mantine.dev/styles/styles-performance/).",0.015527202696196438,2,0
eval2_q010,"In Mantine, which styling approach is most performant at runtime, and why?",89f2d1ed-dc31-40ce-a078-cb5cc6a2108c,"Topic: StylesOverview
Section: CSS modules

[CSS modules](https://mantine.dev/styles/css-modules/) is the recommended way of applying most of the styles to Mantine components.
CSS modules are the most performant and flexible way of styling components.  
```scss
// Demo.module.css

.root {
padding-right: 100px;

&[data-collapsed] {
padding-right: 40px;

& .control {
max-width: 200px;
}
}
}

.control {
background-color: var(--mantine-color-blue-1);
color: var(--mantine-color-blue-filled);
padding: var(--mantine-spacing-xl);
margin-left: 40px;

@media (max-width: $mantine-breakpoint-sm) {
margin-left: 0;
margin-top: var(--mantine-spacing-md);
}

@mixin hover {
background-color: light-dark(
var(--mantine-color-blue-1),
var(--mantine-color-blue-9)
);
}
}
```  
```tsx
// Demo.tsx
import classes from './Demo.module.css';

function Demo({ collapsed }: { collapsed: boolean }) {
return (
<div
className={classes.root}
data-collapsed={collapsed || undefined}
>
<button type=""button"" className={classes.control}>
Control
</button>
</div>
);
}
```",0.015512265512265512,3,3
eval2_q010,"In Mantine, which styling approach is most performant at runtime, and why?",5f15a21f-9221-4611-8ee3-debcac680a45,"Topic: StylesPerformance
Section: Inline styles

Inline styles (`style` and `styles` props) are less performant than CSS modules, but still
performant enough to be used in most cases if it is your preferred way of styling in your project.  
Inline styles caveats:  
* Styles are not reused between components, each component will generate its own styles, for example,
if you have 100 buttons with the same styles, CSS modules will generate 1 class for all of them,
inline styles will generate 100 `style` attributes
* If inline styles are overused, it can increase bundle size and output HTML size
* *Not performance related*: inline styles have higher specificity than CSS modules, so if you want
to override inline styles you will have to use `!important` or use another inline styles  
Example of inline styles:  
#### Example: styles  
```tsx
import { Button } from '@mantine/core';

function Demo() {
const gradient =
'linear-gradient(45deg, var(--mantine-color-pink-filled) 0%, var(--mantine-color-orange-filled) 50%, var(--mantine-color-yellow-filled) 100%)';

return (
<Button
radius=""md""
styles={{
root: {
padding: 2,
border: 0,
backgroundImage: gradient,
},

inner: {
background: 'var(--mantine-color-body)',
color: 'var(--mantine-color-text)',
borderRadius: 'calc(var(--button-radius) - 2px)',
paddingLeft: 'var(--mantine-spacing-md)',
paddingRight: 'var(--mantine-spacing-md)',
},

label: {
backgroundImage: gradient,
WebkitBackgroundClip: 'text',
WebkitTextFillColor: 'transparent',
},
}}
>
Gradient button
</Button>
);
}
```",0.015268065268065269,4,1
eval2_q010,"In Mantine, which styling approach is most performant at runtime, and why?",bed4dcb3-fb72-44c2-98c2-c6efe732c529,"Topic: StylesOverview
Section: Style prop

[Style prop](https://mantine.dev/styles/style/) is supported by all Mantine components and allows setting
CSS properties as well as CSS variables. It is useful in the following cases:  
* You want to apply a single CSS property to a component:  
```tsx
import { Button, Flex } from '@mantine/core';

function Demo() {
return (
<Flex>
<Button style={{ flex: 1 }}>Large button</Button>
<Button>Small button</Button>
</Flex>
);
}
```  
* You want to set a CSS variable based on component prop:  
```tsx
import { Box } from '@mantine/core';

function Demo({ color }: { color: string }) {
// Later you will be able to use var(--my-color) in any nested element
return <Box style={{ '--my-color': color }}>My box</Box>;
}
```  
[Style prop](https://mantine.dev/styles/style/) works the same way as React `style` prop. It is not
recommended to use it as a primary way of styling components. In most cases, it is
better to create a separate file with styles – it will be easier to maintain and
will be more [performant](https://mantine.dev/styles/styles-performance/).",0.014734561213434454,5,0
eval2_q010,"In Mantine, which styling approach is most performant at runtime, and why?",3b9b2596-d93c-4ba2-afbb-54873bb3aa63,"Topic: CSSModules
Section: Overview

# CSS modules  
All Mantine components use CSS modules for styling.
It is recommended to use CSS modules in your project as well, but it is not required –
Mantine components are fully compatible with any third-party styling solution and native CSS.",0.014095691880087354,6,0
eval2_q010,"In Mantine, which styling approach is most performant at runtime, and why?",8e5aca3f-fba9-4054-9a31-5a3e2832a6f2,"Topic: Emotion
Section: Caveats and support

[Emotion](https://emotion.sh/) is a runtime CSS-in-JS library – styles are generated
and injected into the DOM at runtime. This approach has some limitations:  
* **Limited server-side rendering support** – modern frameworks like Next.js with app router
do not fully support emotion or require additional configuration.
* **Runtime overhead** – styles are generated and injected at runtime, which can lead to
performance issues on pages with a lot of components.
* **Additional bundle size** – your bundle will include `@emotion/react` (21.2kB minified),
`@mantine/emotion` (~2kb minified) and all styles that you use in your components.  
`@mantine/emotion` package can be used with the following frameworks:  
* **Vite** and **CRA** with basic setup
* **Next.js with pages router** with additional setup for server side rendering provided by the package
* **Next.js with app router** with additional setup for server side rendering provided by Emotion
* Any other framework that does not require server-side rendering with basic setup  
There is no official support (the package probably can be used but it's not tested and documentation is not provided) for:  
* **React Router**
* **Gatsby**
* **Redwood**
* Any other framework that has server-side rendering  
Note that Emotion is not recommended for new projects, if you are starting a new project with Mantine,
consider using [CSS modules](https://mantine.dev/styles/css-modules/) instead.",0.00819672131147541,7,0
eval2_q010,"In Mantine, which styling approach is most performant at runtime, and why?",122d2af6-a201-4988-b561-ba9df67dba97,"Topic: StylesPerformance
Section: Responsive style props

Responsive [style props](https://mantine.dev/styles/style-props) have worse performance than regular style props
because they require injecting `<style />` tag next to the component. It is fine to use responsive
style props to apply styles to several components, but it is not recommended to use
them in large lists of components, for example, if you have 1000 inputs with responsive margins,
it is better to refactor to use `classNames` prop:  
```tsx
import { TextInput } from '@mantine/core';

// Ok, style props are used to apply margin-top property to several components
function StyleProps() {
return (
<>
<TextInput label=""Input 1"" />
<TextInput label=""Input 2"" mt={{ base: 10, md: 20 }} />
<TextInput label=""Input 3"" mt={{ base: 10, md: 20 }} />
</>
);
}

// Worse, 1000 separate `<style />` tags will be generated
// Better to refactor to use className prop
function StylePropsArray() {
const inputs = Array(1000)
.fill(0)
.map((_, index) => (
<TextInput
key={index}
label={`Input ${index}`}
mt={{ base: 10, md: 20 }}
/>
));

return <>{inputs}</>;
}
```",0.008064516129032258,8,1
eval2_q010,"In Mantine, which styling approach is most performant at runtime, and why?",784bc571-bdd4-4ede-b3f7-c954992ccee8,"Topic: StylesPerformance
Section: Overview

# Styles performance",0.007936507936507936,9,0
eval2_q010,"In Mantine, which styling approach is most performant at runtime, and why?",7f321abb-3271-4e76-8c59-0e1ec7fbe94b,"Topic: StylesPerformance
Section: Style props

[Style props](https://mantine.dev/styles/style-props) transform component props into inline styles. Style props have
the same caveats as inline styles, it is not recommended to use them as the primary means of styling
your components. Usually, style props are used to apply 1–3 styles to a component – using them
this way does not impact performance.",0.0078125,10,0
eval2_q010,"In Mantine, which styling approach is most performant at runtime, and why?",956aca0f-2877-4d22-964a-c559584555fa,"Topic: General
Section: Why my buttons are transparent?

If your buttons are transparent and the background is visible only on hover, you have installed a third-party library that overrides Mantine styles.
Tailwind CSS is the most common library that causes this issue.",0.007462686567164179,11,0
eval2_q010,"In Mantine, which styling approach is most performant at runtime, and why?",18e03aeb-b91b-4cc7-9d10-8abfce0d675e,"Topic: formNested
Section: Properties paths

Most of `form` handlers accept property path as the first argument.
Property path includes keys/indices of objects/arrays at which target property is contained:  
```tsx
import { useForm } from '@mantine/form';

const form = useForm({
mode: 'uncontrolled',
initialValues: {
user: {
firstName: 'John',
lastName: 'Doe',
},

fruits: [
{ name: 'Banana', available: true },
{ name: 'Orange', available: false },
],

deeply: {
nested: {
object: [{ item: 1 }, { item: 2 }],
},
},
},
});

// Props for input that is controlled by user object firstName field
form.getInputProps('user.firstName');

// Set value of `name` field that is contained in object at second position of fruits array:
form.setFieldValue('fruits.1.name', 'Carrot');

// Validate deeply nested field
form.validateField('deeply.nested.object.0.item');
```",0.007352941176470588,12,0
eval2_q010,"In Mantine, which styling approach is most performant at runtime, and why?",eaa06e91-737f-4bd3-8ffa-fd376bec5cc4,"Topic: StylesPerformance
Section: Components responsive props

Some components, like [SimpleGrid](https://mantine.dev/core/simple-grid) and [Grid](https://mantine.dev/core/grid)
rely on the same mechanism as responsive style props to apply styles. The limitations are the same
– it is fine to use these several of these components on a page, but it is not recommended to use
them in large lists of components.",0.007352941176470588,13,0
eval2_q010,"In Mantine, which styling approach is most performant at runtime, and why?",0c1b3056-616a-4197-be68-5bd91cea9d5c,"Topic: General
Section: I prefer a third-party styles solution, can I use Mantine with it?

All Mantine components are fully compatible with any third-party styling solution and native CSS.
There are two main strategies to apply styles with a third-party library:  
* `className`, `classNames`, `style` and `styles` props
* with static selectors, for example `.mantine-Text-root`  
Example of applying styles with a utility CSS library:  
```tsx
import { TextInput } from '@mantine/core';

function Demo() {
return (
<TextInput
classNames={{
root: 'mt-4',
input: 'bg-red-500 text-white',
}}
/>
);
}
```  
Example of applying styles with global CSS:  
```css
/* styles.css */

/* Note that these styles are not scoped and
will be applied to all TextInput components */
.mantine-TextInput-root {
margin-top: 0.8rem;
}

.mantine-TextInput-input {
background-color: var(--mantine-color-red-filled);
color: var(--mantine-color-white);
}
```  
You can combine both approaches to achieve desired results, for example,
`@emotion/styled` and `styled-components` packages will pass `className` prop to
a given component, and you can use static selectors to style inner elements:  
```tsx
import styled from '@emotion/styled';
import { Slider } from '@mantine/core';

const StyledSlider = styled(Slider)`
& .mantine-Slider-bar {
background-color: var(--mantine-color-pink-5);
}

& .mantine-Slider-thumb {
border-color: var(--mantine-color-pink-5);
background-color: white;
width: 1.5rem;
height: 1.5rem;
}
`;

function Demo() {
return <StyledSlider defaultValue={40} />;
}
```",0.007246376811594203,14,0
eval2_q010,"In Mantine, which styling approach is most performant at runtime, and why?",e7c2fab6-b9bf-4ad6-b28d-0b467ca41b8c,"Topic: CSSModules
Section: Styling Mantine components without CSS modules

All Mantine components are fully compatible with any third-party styling solution and native CSS.
There are two main strategies to apply styles with a third-party library:  
* `className`, `classNames`, `style` and `styles` props
* with static selectors, for example `.mantine-Text-root`  
Example of applying styles with a utility CSS library:  
```tsx
import { TextInput } from '@mantine/core';

function Demo() {
return (
<TextInput
classNames={{
root: 'mt-4',
input: 'bg-red-500 text-white',
}}
/>
);
}
```  
Example of applying styles with global CSS:  
```css
/* styles.css */

/* Note that these styles are not scoped and
will be applied to all TextInput components */
.mantine-TextInput-root {
margin-top: 0.8rem;
}

.mantine-TextInput-input {
background-color: var(--mantine-color-red-filled);
color: var(--mantine-color-white);
}
```  
You can combine both approaches to achieve desired results, for example,
`@emotion/styled` and `styled-components` packages will pass `className` prop to
a given component, and you can use static selectors to style inner elements:  
```tsx
import styled from '@emotion/styled';
import { Slider } from '@mantine/core';

const StyledSlider = styled(Slider)`
& .mantine-Slider-bar {
background-color: var(--mantine-color-pink-5);
}

& .mantine-Slider-thumb {
border-color: var(--mantine-color-pink-5);
background-color: white;
width: 1.5rem;
height: 1.5rem;
}
`;",0.007142857142857143,15,0
eval2_q010,"In Mantine, which styling approach is most performant at runtime, and why?",f773e7a3-d1b5-4535-99e4-06674d6f9f20,"Topic: General
Section: Why Text component is not automatically imported?

VSCode cannot automatically import [Text](https://mantine.dev/core/text) component
because it confuses it with the native [Text](https://developer.mozilla.org/en-US/docs/Web/API/Text/Text) constructor
which always appears as a first type reference in the editor.  
<Image src={textConstructorImage.src} maw={800} />",0.007142857142857143,16,0
eval2_q010,"In Mantine, which styling approach is most performant at runtime, and why?",b8c8613c-7ea3-4597-ac04-43d19255e401,"Topic: StylesOverview
Section: Style props

[Style props](https://mantine.dev/styles/style-props/) work similar to component specific props, but with several differences:  
* Style props are not component specific, they can be used with any component.
* Style props always control a single CSS property. For example, `c` prop controls CSS `color` property, while `color` prop controls a set of properties: `color`, `background-color` and `border-color`.
* Style props are set in `style` attribute. It is not possible to override them with CSS without using `!important`.  
[Style props](https://mantine.dev/styles/style-props/) are useful when you need to change a single CSS property without creating a separate file for styles.
Some of the most common use cases are:  
* Changing text color and font-size  
```tsx
import { Text } from '@mantine/core';

function Demo() {
return (
<div>
<Text c=""blue.8"" fz=""lg"">
Card title
</Text>
<Text c=""dimmed"" fz=""sm"">
Card description
</Text>
</div>
);
}
```  
* Applying margins to inputs inside a form:  
```tsx
import { TextInput } from '@mantine/core';

function Demo() {
return (
<form>
<TextInput label=""First name"" />
<TextInput label=""Last name"" mt=""md"" />
<TextInput label=""Email"" mt=""md"" />
</form>
);
}
```  
* Adding padding to various elements:  
```tsx
import { Paper } from '@mantine/core';

function Demo() {
return <Paper p=""xl"">My custom card</Paper>;
}
```  
Note that [style props](https://mantine.dev/styles/style-props/) were never intended to be used
as a primary way of styling components. In most cases, it is better to limit
the number of style props used per component to 3-4. If you find yourself using
more than 4 style props, consider creating a separate file with styles – it
will be easier to maintain and will be more [performant](https://mantine.dev/styles/styles-performance/).",0.007042253521126761,17,0
eval2_q010,"In Mantine, which styling approach is most performant at runtime, and why?",1b370aa6-f18f-4d7b-9c81-5639a6896cac,"Topic: General
Section: Overview

# Why my notifications are displayed at a wrong position?
Because you did not import styles  
If your notifications have incorrect position on the screen and look like this:  
<Image src={image.src} maw={800} />  
It means that you did not import styles for `@mantine/notifications` package like
it is described in [installation](https://mantine.dev/x/notifications/#installation)
instructions.  
Add styles import to your application:  
```bash
import '@mantine/core/styles.css';
import '@mantine/notifications/styles.css';
```",0.006944444444444444,18,0
eval2_q010,"In Mantine, which styling approach is most performant at runtime, and why?",ea2c2c86-73f0-414f-ae0d-b47ba0b5126f,"Topic: General
Section: Inline styles

If the value that controls dynamic styles is not represented by a known union
of values (for example, value can be any valid CSS color), then you can use
inline styles or [style props](https://mantine.dev/styles/style-props/):  
```tsx
import { Box } from '@mantine/core';

interface DemoProps {
fontFamily: string;
color: string;
}

function Demo({ fontFamily, color }: DemoProps) {
return (
<Box style={{ backgroundColor: color }} ff={fontFamily}>
My demo
</Box>
);
}
```  
If you need to customize a deeply nested element, use [styles](https://mantine.dev/styles/styles-api/#styles-prop)
prop instead:  
```tsx
import { Button } from '@mantine/core';

interface DemoProps {
color: string;
}

function Demo({ color }: DemoProps) {
return (
<Button styles={{ label: { backgroundColor: color } }}>
My demo
</Button>
);
}
```  
Note that, it is not possible use pseudo-classes (for example, `:hover`, `:first-of-type`)
and media queries inside the `styles` prop. For this purpose, use CSS variables
with [classNames](https://mantine.dev/styles/styles-api/#classnames-prop) prop.",0.006944444444444444,19,0
eval2_q010,"In Mantine, which styling approach is most performant at runtime, and why?",07d2e778-006a-4b73-a95a-95529c409a81,"Topic: General
Section: Why do I get hydration warning?

To fully understand this hydration warning, let's break it down how server-side rendering
works in React in general (Next.js, React Router, etc.):  
1. User navigates to the page in the browser.
2. The server renders the page and sends html code to the client.
3. html code is parsed by the browser and rendered on the screen (at this point, JavaScript has not been executed yet, uses has only html code).
4. JavaScript code is loaded and executed on the client.
5. Hydration process starts: React compares server-rendered html with client-rendered html and tries to match them.
If server-rendered html does not match client-rendered html, React will re-render the component on the client and
show a warning in the console (like the one above).  
Hydration mismatch error can happen in two cases:  
1. Server-rendered html does not match client-rendered html
2. Some code is executed on the client before React hydration starts and changes the html generated by the server  
In the example above, `ColorSchemeScript` component is used to change `data-mantine-color-scheme`
attribute on the `<html />` element before hydration, which causes the mismatch.
`ColorSchemeScript` component executes for following JavaScript code:  
```tsx
try {
var _colorScheme = window.localStorage.getItem(""mantine-color-scheme-value"");
var colorScheme = _colorScheme === ""light"" || _colorScheme === ""dark"" || _colorScheme === ""auto"" ? _colorScheme : ""light"";
var computedColorScheme = colorScheme !== ""auto"" ? colorScheme : window.matchMedia(""(prefers-color-scheme: dark)"").matches ? ""dark"" : ""light"";
document.documentElement.setAttribute(""data-mantine-color-scheme"", computedColorScheme);
} catch (e) {}
```  
This code is executed on the client before React hydration starts, which changes the html generated by the server and causes the warning.",0.00684931506849315,20,0
eval2_q010,"In Mantine, which styling approach is most performant at runtime, and why?",aa753b14-9a18-41f1-8447-0dda757036ed,"Topic: useHeadroom
Section: Definition

```tsx
interface UseHeadroomOptions {
/** Number in px at which element should be fixed */
fixedAt?: number;

/** Called when element is pinned */
onPin?: () => void;

/** Called when element is at fixed position */
onFix?: () => void;

/** Called when element is unpinned */
onRelease?: () => void;
}

function useHeadroom(input?: UseHeadroomOptions): boolean;
```",0.006756756756756757,21,0
eval2_q010,"In Mantine, which styling approach is most performant at runtime, and why?",f57d97ef-6fa4-4c3f-a9db-a878fcd563bb,"Topic: General
Section: How Mantine styles work

All `@mantine/*` packages that include styles export `@mantine/*/styles.css`
file which includes all the styles for the package.
These files are handled by your framework/build tool (Next.js, Vite, React Router, etc.)
and included in the final bundle.  
Most of Mantine styles (99%+) have low specificity (class selectors) to allow
easy customization and overrides.",0.006756756756756757,22,0
eval2_q010,"In Mantine, which styling approach is most performant at runtime, and why?",15823fe6-a0c6-4c02-bbb4-942b066a3857,"Topic: StylesApi
Section: styles prop

The `styles` prop works the same way as `classNames`, but applies inline styles. Note that inline
styles have higher specificity than classes, so you will not be able to override them with classes
without using `!important`. You cannot use pseudo-classes (for example, `:hover`, `:first-of-type`)
and media queries inside the `styles` prop.  
#### Example: styles  
```tsx
import { Button } from '@mantine/core';

function Demo() {
const gradient =
'linear-gradient(45deg, var(--mantine-color-pink-filled) 0%, var(--mantine-color-orange-filled) 50%, var(--mantine-color-yellow-filled) 100%)';

return (
<Button
radius=""md""
styles={{
root: {
padding: 2,
border: 0,
backgroundImage: gradient,
},

inner: {
background: 'var(--mantine-color-body)',
color: 'var(--mantine-color-text)',
borderRadius: 'calc(var(--button-radius) - 2px)',
paddingLeft: 'var(--mantine-spacing-md)',
paddingRight: 'var(--mantine-spacing-md)',
},

label: {
backgroundImage: gradient,
WebkitBackgroundClip: 'text',
WebkitTextFillColor: 'transparent',
},
}}
>
Gradient button
</Button>
);
}
```  
> **styles prop usage**
>
> Some examples and demos in the documentation use the `styles` prop for convenience, but it is not
> recommended to use the `styles` prop as the primary means of styling components, as the `classNames`
> prop is more flexible and has [better performance](https://mantine.dev/styles/styles-performance).",0.006666666666666667,23,0
eval2_q010,"In Mantine, which styling approach is most performant at runtime, and why?",b04df484-61f4-4803-8a22-08d9420b50cc,"Topic: useThrottledCallback
Section: Usage

`useThrottledCallback` accepts a function and a wait time in milliseconds.
It returns a throttled version of the function that will only be called at most once every `wait` milliseconds.",0.006666666666666667,24,0
eval2_q012,How do I render a stacked BarChart in Mantine Charts with multiple data series?,b6b3c8b5-f5ad-4e74-ba3a-7770d42879f0,"Topic: BarChart
Section: Stacked bar chart

Set `type=""stacked""` to render a stacked bar chart. In this type of bar chart
stacking is applied along the vertical axis, allowing you to see the overall trend
as well as the contribution of each individual series to the total.  
#### Example: stacked  
```tsx
// Demo.tsx
import { BarChart } from '@mantine/charts';
import { data } from './data';

function Demo() {
return (
<BarChart
h={300}
data={data}
dataKey=""month""
type=""stacked""
series={[
{ name: 'Smartphones', color: 'violet.6' },
{ name: 'Laptops', color: 'blue.6' },
{ name: 'Tablets', color: 'teal.6' },
]}
/>
);
}

// data.ts
export const data = [
{ month: 'January', Smartphones: 1200, Laptops: 900, Tablets: 200 },
{ month: 'February', Smartphones: 1900, Laptops: 1200, Tablets: 400 },
{ month: 'March', Smartphones: 400, Laptops: 1000, Tablets: 200 },
{ month: 'April', Smartphones: 1000, Laptops: 200, Tablets: 800 },
{ month: 'May', Smartphones: 800, Laptops: 1400, Tablets: 1200 },
{ month: 'June', Smartphones: 750, Laptops: 600, Tablets: 1000 },
];
```",0.01639344262295082,1,3
eval2_q012,How do I render a stacked BarChart in Mantine Charts with multiple data series?,5c7da916-acdc-47c6-8e6f-7181d95dda78,"Topic: BarChart
Section: Mixed stacked bar chart

You can control how series are stacked by setting `stackId` property in series object:  
#### Example: mixedStack  
```tsx
// Demo.tsx
import { BarChart } from '@mantine/charts';
import { data } from './data';

function Demo() {
return (
<BarChart
h={300}
data={data}
dataKey=""month""
series={[
{ name: 'Smartphones', color: 'violet.6', stackId: 'a' },
{ name: 'Laptops', color: 'blue.6', stackId: 'b' },
{ name: 'Tablets', color: 'teal.6', stackId: 'b' },
]}
/>
);
}

// data.ts
export const data = [
{ month: 'January', Smartphones: 1200, Laptops: 500, Tablets: 800 },
{ month: 'February', Smartphones: 1900, Laptops: 1200, Tablets: 400 },
{ month: 'March', Smartphones: 1800, Laptops: 1000, Tablets: 200 },
{ month: 'April', Smartphones: 1000, Laptops: 200, Tablets: 800 },
{ month: 'May', Smartphones: 800, Laptops: 200, Tablets: 700 },
{ month: 'June', Smartphones: 800, Laptops: 500, Tablets: 200 },
];
```",0.016129032258064516,2,2
eval2_q012,How do I render a stacked BarChart in Mantine Charts with multiple data series?,a0816700-09c0-46c8-bd2f-9db23c0c6990,"Topic: BarChart
Section: Usage

Use `BarChart` component without `type` prop to render a regular bar chart.
In a regular bar chart, each data series is plotted on its own and does
not interact with other series.  
#### Example: usage  
```tsx
// Demo.tsx
import { BarChart } from '@mantine/charts';
import { data } from './data';


function Demo() {
return (
<BarChart
h={300}
data={data}
dataKey=""month""
series={[
{ name: 'Smartphones', color: 'violet.6' },
{ name: 'Laptops', color: 'blue.6' },
{ name: 'Tablets', color: 'teal.6' },
]}

/>
);
}

// data.ts
export const data = [
{ month: 'January', Smartphones: 1200, Laptops: 900, Tablets: 200 },
{ month: 'February', Smartphones: 1900, Laptops: 1200, Tablets: 400 },
{ month: 'March', Smartphones: 400, Laptops: 1000, Tablets: 200 },
{ month: 'April', Smartphones: 1000, Laptops: 200, Tablets: 800 },
{ month: 'May', Smartphones: 800, Laptops: 1400, Tablets: 1200 },
{ month: 'June', Smartphones: 750, Laptops: 600, Tablets: 1000 },
];
```",0.015873015873015872,3,0
eval2_q012,How do I render a stacked BarChart in Mantine Charts with multiple data series?,96c62719-0510-4312-bc0a-2dc3ec7b8ff2,"Topic: BarChart
Section: Series labels

By default, series `name` is used as a label. To change it, set `label`
property in `series` object:  
#### Example: seriesLabels  
```tsx
// Demo.tsx
import { BarChart } from '@mantine/charts';
import { data } from './data';

function Demo() {
return (
<BarChart
h={300}
data={data}
dataKey=""month""
type=""stacked""
withLegend
legendProps={{ verticalAlign: 'bottom' }}
series={[
{ name: 'Smartphones', label: 'Smartphones sales', color: 'violet.6' },
{ name: 'Laptops', label: 'Laptops sales', color: 'blue.6' },
{ name: 'Tablets', label: 'Tablets sales', color: 'teal.6' },
]}
/>
);
}

// data.ts
export const data = [
{ month: 'January', Smartphones: 1200, Laptops: 900, Tablets: 200 },
{ month: 'February', Smartphones: 1900, Laptops: 1200, Tablets: 400 },
{ month: 'March', Smartphones: 400, Laptops: 1000, Tablets: 200 },
{ month: 'April', Smartphones: 1000, Laptops: 200, Tablets: 800 },
{ month: 'May', Smartphones: 800, Laptops: 1400, Tablets: 1200 },
{ month: 'June', Smartphones: 750, Laptops: 600, Tablets: 1000 },
];
```",0.015384615384615385,4,1
eval2_q012,How do I render a stacked BarChart in Mantine Charts with multiple data series?,c4c40882-8aa1-4f94-ad7c-a4d577463af0,"Topic: AreaChart
Section: Stacked area chart

Set `type=""stacked""` to render a stacked area chart. In this type of area chart
stacking is applied along the vertical axis, allowing you to see the overall trend
as well as the contribution of each individual series to the total.  
#### Example: stacked  
```tsx
// Demo.tsx
import { AreaChart } from '@mantine/charts';
import { data } from './data';

function Demo() {
return (
<AreaChart
h={300}
data={data}
dataKey=""date""
type=""stacked""
series={[
{ name: 'Apples', color: 'indigo.6' },
{ name: 'Oranges', color: 'blue.6' },
{ name: 'Tomatoes', color: 'teal.6' },
]}
/>
);
}

// data.ts
export const data = [
{
date: 'Mar 22',
Apples: 2890,
Oranges: 2338,
Tomatoes: 2452,
},
{
date: 'Mar 23',
Apples: 2756,
Oranges: 2103,
Tomatoes: 2402,
},
{
date: 'Mar 24',
Apples: 3322,
Oranges: 986,
Tomatoes: 1821,
},
{
date: 'Mar 25',
Apples: 3470,
Oranges: 2108,
Tomatoes: 2809,
},
{
date: 'Mar 26',
Apples: 3129,
Oranges: 1726,
Tomatoes: 2290,
},
];
```",0.015165441176470588,5,0
eval2_q012,How do I render a stacked BarChart in Mantine Charts with multiple data series?,c19878a1-13df-4fd9-b8f5-109cb7575494,"Topic: BarChart
Section: Vertical orientation

Set `orientation=""vertical""` to render a vertical bar chart:  
#### Example: vertical  
```tsx
// Demo.tsx
import { BarChart } from '@mantine/charts';
import { data } from './data';

function Demo() {
return (
<BarChart
h={300}
data={data}
dataKey=""month""
type=""stacked""
orientation=""vertical""
yAxisProps={{ width: 80 }}
series={[
{ name: 'Smartphones', color: 'violet.6' },
{ name: 'Laptops', color: 'blue.6' },
{ name: 'Tablets', color: 'teal.6' },
]}
/>
);
}

// data.ts
export const data = [
{ month: 'January', Smartphones: 1200, Laptops: 900, Tablets: 200 },
{ month: 'February', Smartphones: 1900, Laptops: 1200, Tablets: 400 },
{ month: 'March', Smartphones: 400, Laptops: 1000, Tablets: 200 },
{ month: 'April', Smartphones: 1000, Laptops: 200, Tablets: 800 },
{ month: 'May', Smartphones: 800, Laptops: 1400, Tablets: 1200 },
{ month: 'June', Smartphones: 750, Laptops: 600, Tablets: 1000 },
];
```",0.015058876811594204,6,1
eval2_q012,How do I render a stacked BarChart in Mantine Charts with multiple data series?,f849f978-d6b4-4610-98ca-36a8653e3e8b,"Topic: BarChart
Section: Waterfall bar chart

Set `type=""waterfall""` to render a waterfall bar chart. This chart type illustrates how an
initial value is influenced by subsequent positive or negative values,
with each bar starting where the previous one ended.
Use the `color` prop inside data to color each bar individually. Note that the series color gets overwritten for this specific bar.
Use the `standalone` prop inside data to decouple the bar from the flow.  
#### Example: waterfall  
```tsx
// Demo.tsx
import { BarChart } from '@mantine/charts';
import { data } from './data';


function Demo() {
return (
<BarChart
h={300}
data={data}
dataKey=""item""
type=""waterfall""
series={[{ name: 'Effective tax rate in %', color: 'blue' }]}
withLegend
/>
);
}

// data.ts
export const data =
[
{ item: 'TaxRate', 'Effective tax rate in %': 21, color: 'blue' },
{ item: 'Foreign inc.', 'Effective tax rate in %': -15.5, color: 'teal' },
{ item: 'Perm. diff.', 'Effective tax rate in %': -3, color: 'teal' },
{ item: 'Credits', 'Effective tax rate in %': -3, color: 'teal' },
{ item: 'Loss carryf. ', 'Effective tax rate in %': -2, color: 'teal' },
{ item: 'Law changes', 'Effective tax rate in %': 2, color: 'red' },
{ item: 'Reven. adj.', 'Effective tax rate in %': 4, color: 'red' },
{ item: 'ETR', 'Effective tax rate in %': 3.5, color: 'blue', standalone: true },
];
```",0.01482213438735178,7,0
eval2_q012,How do I render a stacked BarChart in Mantine Charts with multiple data series?,07c91b10-6c8f-4101-aa4f-3f133f3d4a8f,"Topic: BarChart
Section: Percent bar chart

Set `type=""percent""` to render a percent bar chart. In this type of bar chart
the y-axis scale is always normalized to 100%, making it easier to compare the
contribution of each series in terms of percentages.  
#### Example: percent  
```tsx
// Demo.tsx
import { BarChart } from '@mantine/charts';
import { data } from './data';

function Demo() {
return (
<BarChart
h={300}
data={data}
dataKey=""month""
type=""percent""
series={[
{ name: 'Smartphones', color: 'violet.6' },
{ name: 'Laptops', color: 'blue.6' },
{ name: 'Tablets', color: 'teal.6' },
]}
/>
);
}

// data.ts
export const data = [
{ month: 'January', Smartphones: 1200, Laptops: 900, Tablets: 200 },
{ month: 'February', Smartphones: 1900, Laptops: 1200, Tablets: 400 },
{ month: 'March', Smartphones: 400, Laptops: 1000, Tablets: 200 },
{ month: 'April', Smartphones: 1000, Laptops: 200, Tablets: 800 },
{ month: 'May', Smartphones: 800, Laptops: 1400, Tablets: 1200 },
{ month: 'June', Smartphones: 750, Laptops: 600, Tablets: 1000 },
];
```",0.014285714285714285,8,0
eval2_q012,How do I render a stacked BarChart in Mantine Charts with multiple data series?,dd81e5f3-931f-46a2-bf21-b0512d599007,"Topic: BarChart
Section: Overview

Package: @mantine/charts
Import: import { BarChart } from '@mantine/charts';
Description: Bar chart component with stacked and percent variants",0.007575757575757576,9,0
eval2_q012,How do I render a stacked BarChart in Mantine Charts with multiple data series?,60298455-ae88-4ea8-aa12-1d66d4e6da12,"Topic: BarChart
Section: Bar overlays

#### Example: overlay  
```tsx
// Demo.tsx
import { BarChart } from '@mantine/charts';
import classes from './Demo.module.css';
import { data } from './data';

function Demo() {
const bigBarWidth = useMediaQuery('(min-width: 48em)') ? 42 : 26;
const ratio = 0.5;
const smallBarWidth = bigBarWidth * ratio;
const barGap = (bigBarWidth + smallBarWidth) / -2;

return (
<BarChart
h={300}
data={overlayData}
dataKey=""index""
barChartProps={{ barGap }}
barProps={(data) => ({ barSize: data.name === 'you' ? bigBarWidth : smallBarWidth })}
classNames={classes}
series={[
{ name: 'you', color: 'var(--you-bar-color)' },
{ name: 'average', color: 'var(--average-bar-color)' },
]}
/>
);
}

// Demo.module.css
.root {
@mixin light {
--average-bar-color: var(--mantine-color-dark-8);
--you-bar-color: var(--mantine-color-blue-3);
}

@mixin dark {
--you-bar-color: var(--mantine-color-blue-8);
--average-bar-color: var(--mantine-color-gray-4);
}
}

.bar {
transform: translateX(-1.5px);
}",0.007462686567164179,10,0
eval2_q012,How do I render a stacked BarChart in Mantine Charts with multiple data series?,82e04b83-0726-4653-87a5-c9ea9046e72f,"Topic: BarChart
Section: Sync multiple BarCharts

You can pass props down to recharts [BarChart](https://recharts.org/en-US/api/BarChart)
component with `barChartProps` prop. For example, setting `barChartProps={{ syncId: 'any-id' }}`
will sync tooltip of multiple `BarChart` components with the same `syncId` prop.  
#### Example: sync  
```tsx
// Demo.tsx
import { Text } from '@mantine/core';
import { BarChart } from '@mantine/charts';
import { data } from './data';

function Demo() {
return (
<>
<Text mb=""md"" pl=""md"">
Smartphones sales:
</Text>

<BarChart
h={180}
data={data}
dataKey=""month""
series={[{ name: 'Smartphones', color: 'violet.6' }]}
barChartProps={{ syncId: 'tech' }}
/>

<Text mb=""md"" pl=""md"" mt=""xl"">
Laptops sales:
</Text>

<BarChart
h={180}
data={data}
dataKey=""month""
barChartProps={{ syncId: 'tech' }}
series={[{ name: 'Laptops', color: 'teal.6' }]}
/>
</>
);
}

// data.ts
export const data = [
{ month: 'January', Smartphones: 1200, Laptops: 900, Tablets: 200 },
{ month: 'February', Smartphones: 1900, Laptops: 1200, Tablets: 400 },
{ month: 'March', Smartphones: 400, Laptops: 1000, Tablets: 200 },
{ month: 'April', Smartphones: 1000, Laptops: 200, Tablets: 800 },
{ month: 'May', Smartphones: 800, Laptops: 1400, Tablets: 1200 },
{ month: 'June', Smartphones: 750, Laptops: 600, Tablets: 1000 },
];
```",0.007462686567164179,11,0
eval2_q012,How do I render a stacked BarChart in Mantine Charts with multiple data series?,8077933d-bf49-4bf7-a03d-5a969783c880,"Topic: ScatterChart
Section: Multiple series

#### Example: multipleSeries  
```tsx
// Demo.tsx
import { ScatterChart } from '@mantine/charts';
import { data } from './data';

function Demo() {
return (
<ScatterChart
h={350}
data={data}
dataKey={{ x: 'age', y: 'BMI' }}
xAxisLabel=""Age""
yAxisLabel=""BMI""
/>
);
}

// data.ts
export const data = [
{
color: 'blue.5',
name: 'Group 1',
data: [
{ age: 25, BMI: 20 },
{ age: 30, BMI: 22 },
{ age: 35, BMI: 18 },
{ age: 40, BMI: 25 },
{ age: 45, BMI: 30 },
{ age: 28, BMI: 15 },
{ age: 22, BMI: 12 },
{ age: 50, BMI: 28 },
{ age: 32, BMI: 19 },
{ age: 48, BMI: 31 },
{ age: 26, BMI: 24 },
{ age: 38, BMI: 27 },
{ age: 42, BMI: 29 },
{ age: 29, BMI: 16 },
{ age: 34, BMI: 23 },
{ age: 44, BMI: 33 },
{ age: 23, BMI: 14 },
{ age: 37, BMI: 26 },
{ age: 49, BMI: 34 },
{ age: 27, BMI: 17 },
{ age: 41, BMI: 32 },
{ age: 31, BMI: 21 },
{ age: 46, BMI: 35 },
{ age: 24, BMI: 13 },
{ age: 33, BMI: 22 },
{ age: 39, BMI: 28 },
{ age: 47, BMI: 30 },
{ age: 36, BMI: 25 },
{ age: 43, BMI: 29 },
{ age: 21, BMI: 11 },
],
},
{
color: 'red.5',
name: 'Group 2',
data: [
{ age: 26, BMI: 21 },
{ age: 31, BMI: 24 },
{ age: 37, BMI: 19 },
{ age: 42, BMI: 27 },
{ age: 29, BMI: 32 },
{ age: 35, BMI: 18 },
{ age: 40, BMI: 23 },
{ age: 45, BMI: 30 },
{ age: 27, BMI: 15 },
{ age: 33, BMI: 20 },
{ age: 38, BMI: 25 },
{ age: 43, BMI: 29 },
{ age: 30, BMI: 16 },
{ age: 36, BMI: 22 },
{ age: 41, BMI: 28 },
{ age: 46, BMI: 33 },
{ age: 28, BMI: 17 },
{ age: 34, BMI: 22 },
{ age: 39, BMI: 26 },
{ age: 44, BMI: 31 },
{ age: 32, BMI: 18 },
{ age: 38, BMI: 23 },
{ age: 43, BMI: 28 },
{ age: 48, BMI: 35 },
{ age: 25, BMI: 14 },
{ age: 31, BMI: 20 },
{ age: 36, BMI: 25 },
{ age: 41, BMI: 30 },
{ age: 29, BMI: 16 },
],
},
];
```",0.007352941176470588,12,0
eval2_q012,How do I render a stacked BarChart in Mantine Charts with multiple data series?,49362e48-ae62-4e20-bae4-3df1b569da51,"Topic: BarChart
Section: SVG pattern as bar fill

You can use SVG patterns as bar fill. To do so, set `fill` property in series object to
a url of the SVG pattern that is defined in the `defs` section of the chart `children`.  
Example of using diagonal stripes and crosshatch patterns as bar fill:  
#### Example: stripes  
```tsx
// Demo.tsx
import { BarChart } from '@mantine/charts';
import { data } from './data';

function Demo() {
return (
<BarChart
h={300}
data={mixedStackData}
dataKey=""month""
series={[
{ name: 'Smartphones', color: 'url(#crosshatch)', stackId: 'a' },
{ name: 'Laptops', color: 'blue.6', stackId: 'b' },
{ name: 'Tablets', color: 'url(#diagonalStripes)', stackId: 'b' },
]}
>
<defs>
<pattern
id=""diagonalStripes""
patternUnits=""userSpaceOnUse""
width={6}
height={8}
patternTransform=""rotate(45)""
>
<rect
width=""2""
height=""8""
transform=""translate(0,0)""
fill=""color-mix(in lch, var(--mantine-color-teal-6) 70%, rgba(0,0,0,0))""
/>
</pattern>

<pattern id=""crosshatch"" patternUnits=""userSpaceOnUse"" width={8} height={8}>
<path
d=""M 0 0 L 8 0 L 8 8 L 0 8 Z""
fill=""none""
stroke=""color-mix(in lch, var(--mantine-color-indigo-6) 70%, rgba(0,0,0,0))""
strokeWidth=""1""
/>
<path
d=""M 0 0 L 8 8""
stroke=""color-mix(in lch, var(--mantine-color-indigo-6) 70%, rgba(0,0,0,0))""
strokeWidth=""1""
/>
<path
d=""M 8 0 L 0 8""
stroke=""color-mix(in lch, var(--mantine-color-indigo-6) 70%, rgba(0,0,0,0))""
strokeWidth=""1""
/>
</pattern>
</defs>
</BarChart>
);
}

// data.ts
export const data = [
{ month: 'January', Smartphones: 1200, Laptops: 500, Tablets: 800 },
{ month: 'February', Smartphones: 1900, Laptops: 1200, Tablets: 400 },
{ month: 'March', Smartphones: 1800, Laptops: 1000, Tablets: 200 },
{ month: 'April', Smartphones: 1000, Laptops: 200, Tablets: 800 },
{ month: 'May', Smartphones: 800, Laptops: 200, Tablets: 700 },
{ month: 'June', Smartphones: 800, Laptops: 500, Tablets: 200 },
];
```",0.007042253521126761,13,0
eval2_q012,How do I render a stacked BarChart in Mantine Charts with multiple data series?,aaaa2652-88e4-491d-9687-a7ffc12bb30b,"Topic: BarChart
Section: Grid and text colors

Use `--chart-grid-color` and `--chart-text-color` to change colors of
grid lines and text within the chart. With [CSS modules](https://mantine.dev/styles/css-modules/), you can change colors
depending on color scheme:  
#### Example: gridColor  
```tsx
// Demo.module.css
.root {
@mixin light {
--chart-grid-color: alpha(var(--mantine-color-black), 0.15);
--chart-text-color: var(--mantine-color-gray-7);
}

@mixin dark {
--chart-grid-color: alpha(var(--mantine-color-white), 0.15);
--chart-text-color: var(--mantine-color-dark-0);
}
}

// Demo.tsx
import { BarChart } from '@mantine/charts';
import { data } from './data';
import classes from './Demo.module.css';

function Demo() {
return (
<BarChart
h={300}
data={data}
dataKey=""date""
type=""stacked""
className={classes.root}
series={[
{ name: 'Smartphones', color: 'violet.6' },
{ name: 'Laptops', color: 'blue.6' },
{ name: 'Tablets', color: 'teal.6' },
]}
/>
);
}

// data.ts
export const data = [
{ month: 'January', Smartphones: 1200, Laptops: 900, Tablets: 200 },
{ month: 'February', Smartphones: 1900, Laptops: 1200, Tablets: 400 },
{ month: 'March', Smartphones: 400, Laptops: 1000, Tablets: 200 },
{ month: 'April', Smartphones: 1000, Laptops: 200, Tablets: 800 },
{ month: 'May', Smartphones: 800, Laptops: 1400, Tablets: 1200 },
{ month: 'June', Smartphones: 750, Laptops: 600, Tablets: 1000 },
];
```  
If your application has only one color scheme, you can use `gridColor` and `textColor`
props instead of CSS variables:  
```tsx
import { BarChart } from '@mantine/charts';
import { data } from './data';

function Demo() {
return (
<BarChart
h={300}
data={data}
dataKey=""date""
type=""stacked""
gridColor=""gray.5""
textColor=""gray.9""
series={[
{ name: 'Smartphones', color: 'violet.6' },
{ name: 'Laptops', color: 'blue.6' },
{ name: 'Tablets', color: 'teal.6' },
]}
/>
);
}
```",0.007042253521126761,14,0
eval2_q012,How do I render a stacked BarChart in Mantine Charts with multiple data series?,7b218a1c-a30a-4c3f-a968-590f94cfc3c8,"Topic: BarChart
Section: Units

Set `unit` prop to render a unit label next to the y-axis ticks and tooltip values:  
#### Example: unit  
```tsx
// Demo.tsx
import { BarChart } from '@mantine/charts';
import { data } from './data';

function Demo() {
return (
<BarChart
h={300}
data={data}
dataKey=""month""
unit=""$""
series={[
{ name: 'Smartphones', color: 'violet.6' },
{ name: 'Laptops', color: 'blue.6' },
{ name: 'Tablets', color: 'teal.6' },
]}
/>
);
}

// data.ts
export const data = [
{ month: 'January', Smartphones: 1200, Laptops: 900, Tablets: 200 },
{ month: 'February', Smartphones: 1900, Laptops: 1200, Tablets: 400 },
{ month: 'March', Smartphones: 400, Laptops: 1000, Tablets: 200 },
{ month: 'April', Smartphones: 1000, Laptops: 200, Tablets: 800 },
{ month: 'May', Smartphones: 800, Laptops: 1400, Tablets: 1200 },
{ month: 'June', Smartphones: 750, Laptops: 600, Tablets: 1000 },
];
```",0.006944444444444444,15,0
eval2_q012,How do I render a stacked BarChart in Mantine Charts with multiple data series?,af0102ac-e3ec-48d0-8f6a-ae64fe67d02f,"Topic: RadarChart
Section: Multiple series

You can display multiple series on the same radar chart:  
#### Example: multiple  
```tsx
// Demo.tsx
import { RadarChart } from '@mantine/charts';
import { data } from './data';

function Demo() {
return (
<RadarChart
h={300}
data={data}
dataKey=""product""
withPolarRadiusAxis
series={[
{ name: 'Sales January', color: 'lime.4', opacity: 0.1 },
{ name: 'Sales February', color: 'cyan.4', opacity: 0.1 },
]}
/>
);
}

// data.ts
export const data = [
{
product: 'Apples',
'Sales January': 120,
'Sales February': 100,
},
{
product: 'Oranges',
'Sales January': 98,
'Sales February': 90,
},
{
product: 'Tomatoes',
'Sales January': 86,
'Sales February': 70,
},
{
product: 'Grapes',
'Sales January': 99,
'Sales February': 80,
},
{
product: 'Bananas',
'Sales January': 85,
'Sales February': 120,
},
{
product: 'Lemons',
'Sales January': 65,
'Sales February': 150,
},
];
```",0.006944444444444444,16,0
eval2_q012,How do I render a stacked BarChart in Mantine Charts with multiple data series?,12d83b92-d7a0-47be-883a-b0eeb981be74,"Topic: LLMDocumentation
Section: Example prompts

Here are some example prompts you can use with AI tools:  
* ""Using Mantine v8, how do I create a dark mode toggle?""
* ""Show me how to use the AppShell component with a collapsible navbar""
* ""How can I customize the theme colors in MantineProvider?""
* ""Create a form with validation using Mantine's form hooks""
* ""How to align input with a button in a flex container?""",0.00684931506849315,17,0
eval2_q012,How do I render a stacked BarChart in Mantine Charts with multiple data series?,2587962a-e3f7-4632-8775-59a302ff760f,"Topic: CompositeChart
Section: Usage

`CompositeChart` allows using `Line`, `Area` and `Bar` charts together in a single
chart:  
#### Example: usage  
```tsx
// Demo.tsx
import { CompositeChart } from '@mantine/charts';
import { data } from './data';


function Demo() {
return (
<CompositeChart
h={300}
data={data}
dataKey=""date""
maxBarWidth={30}
series={[
{ name: 'Tomatoes', color: 'rgba(18, 120, 255, 0.2)', type: 'bar' },
{ name: 'Apples', color: 'red.8', type: 'line' },
{ name: 'Oranges', color: 'yellow.8', type: 'area' },
]}

/>
);
}

// data.ts
export const data = [
{
date: 'Mar 22',
Apples: 2890,
Oranges: 2338,
Tomatoes: 2452,
},
{
date: 'Mar 23',
Apples: 2756,
Oranges: 2103,
Tomatoes: 2402,
},
{
date: 'Mar 24',
Apples: 3322,
Oranges: 986,
Tomatoes: 1821,
},
{
date: 'Mar 25',
Apples: 3470,
Oranges: 2108,
Tomatoes: 2809,
},
{
date: 'Mar 26',
Apples: 3129,
Oranges: 1726,
Tomatoes: 2290,
},
];
```",0.00684931506849315,18,0
eval2_q012,How do I render a stacked BarChart in Mantine Charts with multiple data series?,2a5ebe1d-d0cf-4f05-8d76-5ec3aab9461e,"Topic: BarChart
Section: Stroke dash array

Set `strokeDasharray` prop to control the stroke dash array of the grid and cursor
lines. The value represent the lengths of alternating dashes and gaps. For example,
`strokeDasharray=""10 5""` will render a dashed line with 10px dashes and 5px gaps.  
#### Example: strokeDasharray  
```tsx
// Demo.tsx
import { BarChart } from '@mantine/charts';
import { data } from './data';

function Demo() {
return (
<BarChart
h={300}
data={data}
dataKey=""month""
strokeDasharray=""15 15""
series={[
{ name: 'Smartphones', color: 'violet.6' },
{ name: 'Laptops', color: 'blue.6' },
{ name: 'Tablets', color: 'teal.6' },
]}
/>
);
}

// data.ts
export const data = [
{ month: 'January', Smartphones: 1200, Laptops: 900, Tablets: 200 },
{ month: 'February', Smartphones: 1900, Laptops: 1200, Tablets: 400 },
{ month: 'March', Smartphones: 400, Laptops: 1000, Tablets: 200 },
{ month: 'April', Smartphones: 1000, Laptops: 200, Tablets: 800 },
{ month: 'May', Smartphones: 800, Laptops: 1400, Tablets: 1200 },
{ month: 'June', Smartphones: 750, Laptops: 600, Tablets: 1000 },
];
```",0.006756756756756757,19,0
eval2_q012,How do I render a stacked BarChart in Mantine Charts with multiple data series?,2ff9a6b3-2ca6-4803-8790-63ef66a1a7ef,"Topic: BarChart
Section: Legend

To display chart legend, set `withLegend` prop. When one of the items in the legend
is hovered, the corresponding data series is highlighted in the chart.  
#### Example: legend  
```tsx
// Demo.tsx
import { BarChart } from '@mantine/charts';
import { data } from './data';

function Demo() {
return (
<BarChart
h={300}
data={data}
dataKey=""month""
withLegend
series={[
{ name: 'Smartphones', color: 'violet.6' },
{ name: 'Laptops', color: 'blue.6' },
{ name: 'Tablets', color: 'teal.6' },
]}
/>
);
}

// data.ts
export const data = [
{ month: 'January', Smartphones: 1200, Laptops: 900, Tablets: 200 },
{ month: 'February', Smartphones: 1900, Laptops: 1200, Tablets: 400 },
{ month: 'March', Smartphones: 400, Laptops: 1000, Tablets: 200 },
{ month: 'April', Smartphones: 1000, Laptops: 200, Tablets: 800 },
{ month: 'May', Smartphones: 800, Laptops: 1400, Tablets: 1200 },
{ month: 'June', Smartphones: 750, Laptops: 600, Tablets: 1000 },
];
```",0.006756756756756757,20,0
eval2_q012,How do I render a stacked BarChart in Mantine Charts with multiple data series?,13fa71e9-3acb-4aea-a395-0c096e0ccbda,"Topic: BarChart
Section: Bar props

You can pass props down to recharts [Bar](https://recharts.org/en-US/api/Bar)
component with `barProps` prop. `barProps` accepts either an object with props
or a function that receives series data as an argument and returns an object with
props.  
#### Example: barProps  
```tsx
// Demo.tsx
import { BarChart } from '@mantine/charts';
import { data } from './data';

function Demo() {
return (
<BarChart
h={200}
data={data}
dataKey=""month""
orientation=""vertical""
yAxisProps={{ width: 80 }}
barProps={{ radius: 10 }}
series={[{ name: 'Smartphones', color: 'blue.6' }]}
/>
);
}

// data.ts
export const data = [
{ month: 'January', Smartphones: 1200, Laptops: 900, Tablets: 200 },
{ month: 'February', Smartphones: 1900, Laptops: 1200, Tablets: 400 },
{ month: 'March', Smartphones: 400, Laptops: 1000, Tablets: 200 },
{ month: 'April', Smartphones: 1000, Laptops: 200, Tablets: 800 },
{ month: 'May', Smartphones: 800, Laptops: 1400, Tablets: 1200 },
{ month: 'June', Smartphones: 750, Laptops: 600, Tablets: 1000 },
];
```",0.006666666666666667,21,0
eval2_q012,How do I render a stacked BarChart in Mantine Charts with multiple data series?,5b61f258-57f8-40d2-87b6-1bdc373eecdf,"Topic: BarChart
Section: Bar overlays

// data.ts
export const data = [
{ you: 5, average: 3, index: '1' },
{ you: 7, average: 9, index: '2' },
{ you: 8, average: 5, index: '3' },
{ you: 3, average: 6, index: '4' },
{ you: 2, average: 4, index: '5' },
{ you: 6, average: 8, index: '6' },
{ you: 4, average: 7, index: '7' },
{ you: 9, average: 2, index: '8' },
];
```  
#### Props  
| Prop | Type | Default | Description |
|------|------|---------|-------------|
| barChartProps | Omit<CategoricalChartProps & RefAttributes<{ readonly eventEmitterSymbol: Symbol; clipPathId: string; accessibilityManager: AccessibilityManager; ... 65 more ...; UNSAFE_componentWillUpdate?(nextProps: Readonly<...>, nextState: Readonly<...>, nextContext: any): void; }>, ""ref""> | - | Props passed down to recharts <code>BarChart</code> component |
| barLabelColor | MantineColor | - | Controls color of the bar label, by default the value is determined by the chart orientation |
| barProps | ((series: BarChartSeries) => Partial<Omit<Props, ""ref"">>) | Partial<Omit<Props, ""ref"">> | - | Props passed down to recharts <code>Bar</code> component |
| children | React.ReactNode | - | Additional components that are rendered inside recharts <code>BarChart</code> component |
| cursorFill | MantineColor | - | Fill of hovered bar section, by default value is based on color scheme |
| data | Record<string, any>[] | required | Data used to display chart. |
| dataKey | string | required | Key of the <code>data</code> object for x-axis values |
| fillOpacity | number | - | Controls fill opacity of all bars |
| getBarColor | (value: number, series: BarChartSeries) => DefaultMantineColor | - | A function to assign dynamic bar color based on its value |
| gridAxis | ""none"" | ""x"" | ""y"" | ""xy"" | - | Specifies which lines should be displayed in the grid, <code>'x'</code> by default |
| gridColor | MantineColor | - | Color of the grid and cursor lines, by default depends on color scheme |
| gridProps | RechartsProps | - | Props passed down to the",0.006666666666666667,22,0
eval2_q014,"Does Mantine provide a built-in way to synchronize state across browser tabs (e.g., theme/color scheme), and how do I use it?",31d9d91f-10af-4732-81cd-5bcdcd57f1f3,"Topic: useLocalStorage
Section: Browser tabs synchronization

`use-local-storage` subscribes to [storage event](https://developer.mozilla.org/en-US/docs/Web/API/Window/storage_event).
When state changes in one tab, it automatically updates the value in all other opened browser tabs.
You can test this feature by opening 2 tabs with Mantine docs side by side and changing the color scheme
(button on the top right or `⌘ + J` on MacOS and `Ctrl + J` on Windows and Linux).",0.01639344262295082,1,2
eval2_q014,"Does Mantine provide a built-in way to synchronize state across browser tabs (e.g., theme/color scheme), and how do I use it?",f15de2c4-0a90-4192-8b5a-52b7cae48a46,"Topic: useLocalStorage
Section: Usage

`use-local-storage` allows using value from the `localStorage` as react state.
The hook works the same way as `useState`, but also writes the value to the `localStorage`:  
```tsx
import { useLocalStorage } from '@mantine/hooks';

// The hook will read value from localStorage.getItem('color-scheme')
// If localStorage is not available or value at a given key does not exist
// 'dark' will be assigned to value variable
const [value, setValue] = useLocalStorage({
key: 'color-scheme',
defaultValue: 'dark',
});

// Value is set both to state and localStorage at 'color-scheme'
setValue('light');

// You can also use callback like in useState hook to set value
setValue((current) => (current === 'dark' ? 'light' : 'dark'));
```",0.014389233954451346,2,1
eval2_q014,"Does Mantine provide a built-in way to synchronize state across browser tabs (e.g., theme/color scheme), and how do I use it?",0a20c0d1-515a-42ac-9279-0d6fb1bcb0bd,"Topic: General
Section: Overview

# How can I get current color scheme value in JavaScript?
How to use useMantineColorScheme and useComputedColorScheme hooks to get current color scheme value in JavaScript",0.014019607843137254,3,0
eval2_q014,"Does Mantine provide a built-in way to synchronize state across browser tabs (e.g., theme/color scheme), and how do I use it?",12002107-37e8-46ad-9cd2-ee751075eaa9,"Topic: General
Section: I want to add a custom color scheme. Can I do that?

No, Mantine does not support custom color schemes. If you attempt to do that,
most of the components will have broken styles. Instead of applying a custom
color scheme, customize colors with [theme](https://mantine.dev/theming/theme-object/).",0.008064516129032258,4,0
eval2_q014,"Does Mantine provide a built-in way to synchronize state across browser tabs (e.g., theme/color scheme), and how do I use it?",1f8d572a-ee0d-4501-9c75-98b2a38302d8,"Topic: ColorSchemes
Section: Color scheme manager

return {
get: (defaultValue) => {
if (typeof window === 'undefined') {
return defaultValue;
}

try {
return (
(window.localStorage.getItem(key) as MantineColorScheme) ||
defaultValue
);
} catch {
return defaultValue;
}
},

set: (value) => {
try {
window.localStorage.setItem(key, value);
} catch (error) {
// eslint-disable-next-line no-console
console.warn(
'[@mantine/core] Local storage color scheme manager was unable to save color scheme.',
error
);
}
},

subscribe: (onUpdate) => {
handleStorageEvent = (event) => {
if (
event.storageArea === window.localStorage &&
event.key === key
) {
isMantineColorScheme(event.newValue) &&
onUpdate(event.newValue);
}
};

window.addEventListener('storage', handleStorageEvent);
},

unsubscribe: () => {
window.removeEventListener('storage', handleStorageEvent);
},

clear: () => {
window.localStorage.removeItem(key);
},
};
}
```  
Then custom color scheme manager can be passed to [MantineProvider](https://mantine.dev/theming/mantine-provider):  
```tsx
import { MantineProvider } from '@mantine/core';
import { localStorageColorSchemeManager } from './localStorageColorSchemeManager';

const colorSchemeManager = localStorageColorSchemeManager({
key: 'my-color-scheme',
});

function Demo() {
return (
<MantineProvider colorSchemeManager={colorSchemeManager}>
{/* Your app here */}
</MantineProvider>
);
}
```",0.008064516129032258,5,3
eval2_q014,"Does Mantine provide a built-in way to synchronize state across browser tabs (e.g., theme/color scheme), and how do I use it?",0ea8c15d-6398-4c66-8931-38c613fc91de,"Topic: General
Section: Overview

# I get hydration warning about data-mantine-color-scheme attribute, what does it mean?
Learn how hydration works and how to fix warnings",0.007936507936507936,6,0
eval2_q014,"Does Mantine provide a built-in way to synchronize state across browser tabs (e.g., theme/color scheme), and how do I use it?",4acb898e-becb-40dc-95ac-1899087ffa1f,"Topic: ColorSchemes
Section: Color scheme manager

By default, color scheme value is stored in local storage, but you can implement your own
color scheme manager to store the value in any other external storage.  
Color scheme manager must have the following methods:  
```tsx
interface MantineColorSchemeManager {
/** Function to retrieve color scheme value from external storage, for example window.localStorage */
get: (defaultValue: MantineColorScheme) => MantineColorScheme;

/** Function to set color scheme value in external storage, for example window.localStorage */
set: (value: MantineColorScheme) => void;

/** Function to subscribe to color scheme changes triggered by external events */
subscribe: (
onUpdate: (colorScheme: MantineColorScheme) => void
) => void;

/** Function to unsubscribe from color scheme changes triggered by external events */
unsubscribe: () => void;

/** Function to clear value from external storage */
clear: () => void;
}
```  
Usually, it is better to wrap color scheme manager in a creator function to provide a way to
configure it. Default local storage based color scheme manager example:  
```tsx
import {
isMantineColorScheme,
MantineColorScheme,
MantineColorSchemeManager,
} from '@mantine/core';

export interface LocalStorageColorSchemeManagerOptions {
/** Local storage key used to retrieve value with `localStorage.getItem(key)`, `mantine-color-scheme` by default */
key?: string;
}

export function localStorageColorSchemeManager({
key = 'mantine-color-scheme',
}: LocalStorageColorSchemeManagerOptions = {}): MantineColorSchemeManager {
let handleStorageEvent: (event: StorageEvent) => void;

return {
get: (defaultValue) => {
if (typeof window === 'undefined') {
return defaultValue;
}

try {
return (
(window.localStorage.getItem(key) as MantineColorScheme) ||
defaultValue
);
} catch {
return defaultValue;
}
},",0.007936507936507936,7,1
eval2_q014,"Does Mantine provide a built-in way to synchronize state across browser tabs (e.g., theme/color scheme), and how do I use it?",2a5ccfc0-fb9c-4a02-afaf-8686b6a53cb0,"Topic: General
Section: Overview

# Native browser validation does not work in some components, what should I do?
Learn why native browser validation does not work in some components",0.0078125,8,0
eval2_q014,"Does Mantine provide a built-in way to synchronize state across browser tabs (e.g., theme/color scheme), and how do I use it?",7f21a50c-d2d3-42db-8282-6a0e72eafc0b,"Topic: MantineProvider
Section: colorSchemeManager

`colorSchemeManager` is used to retrieve and set color scheme value in external storage. By default,
`MantineProvider` uses `window.localStorage` to store color scheme value, but you can pass your own
implementation to `colorSchemeManager` prop. You can learn more about color scheme management in the
[color schemes guide](https://mantine.dev/theming/color-schemes).  
```tsx
import {
localStorageColorSchemeManager,
MantineProvider,
} from '@mantine/core';

const colorSchemeManager = localStorageColorSchemeManager({
key: 'my-app-color-scheme',
});

function Demo() {
return (
<MantineProvider colorSchemeManager={colorSchemeManager}>
{/* Your app here */}
</MantineProvider>
);
}
```",0.0078125,9,0
eval2_q014,"Does Mantine provide a built-in way to synchronize state across browser tabs (e.g., theme/color scheme), and how do I use it?",07d2e778-006a-4b73-a95a-95529c409a81,"Topic: General
Section: Why do I get hydration warning?

To fully understand this hydration warning, let's break it down how server-side rendering
works in React in general (Next.js, React Router, etc.):  
1. User navigates to the page in the browser.
2. The server renders the page and sends html code to the client.
3. html code is parsed by the browser and rendered on the screen (at this point, JavaScript has not been executed yet, uses has only html code).
4. JavaScript code is loaded and executed on the client.
5. Hydration process starts: React compares server-rendered html with client-rendered html and tries to match them.
If server-rendered html does not match client-rendered html, React will re-render the component on the client and
show a warning in the console (like the one above).  
Hydration mismatch error can happen in two cases:  
1. Server-rendered html does not match client-rendered html
2. Some code is executed on the client before React hydration starts and changes the html generated by the server  
In the example above, `ColorSchemeScript` component is used to change `data-mantine-color-scheme`
attribute on the `<html />` element before hydration, which causes the mismatch.
`ColorSchemeScript` component executes for following JavaScript code:  
```tsx
try {
var _colorScheme = window.localStorage.getItem(""mantine-color-scheme-value"");
var colorScheme = _colorScheme === ""light"" || _colorScheme === ""dark"" || _colorScheme === ""auto"" ? _colorScheme : ""light"";
var computedColorScheme = colorScheme !== ""auto"" ? colorScheme : window.matchMedia(""(prefers-color-scheme: dark)"").matches ? ""dark"" : ""light"";
document.documentElement.setAttribute(""data-mantine-color-scheme"", computedColorScheme);
} catch (e) {}
```  
This code is executed on the client before React hydration starts, which changes the html generated by the server and causes the warning.",0.007692307692307693,10,0
eval2_q014,"Does Mantine provide a built-in way to synchronize state across browser tabs (e.g., theme/color scheme), and how do I use it?",0d6b8b9c-30b7-4848-b777-6346400f4930,"Topic: ColorSchemes
Section: Color scheme value caveats

By default, the color scheme value is stored in local storage, and its value is saved in state
before the component is mounted to avoid flash of inaccurate color scheme. This means that
color scheme value can be different on client and server, as server does not have access
to local storage and always uses the default value.  
If you have server side rendering in your application (for example, if you use [Next.js](https://mantine.dev/guides/next) or [React Router](https://mantine.dev/guides/react-router)), then you cannot use `colorScheme`
value in your application to avoid hydration issues. Instead, you can use `dark` and `light`
mixins from [postcss-preset-mantine](https://mantine.dev/styles/postcss-preset) to generate styles that will
hide elements based on color scheme value:  
#### Example: colorSchemeControl  
```tsx
import { ActionIcon, useMantineColorScheme, useComputedColorScheme } from '@mantine/core';
import { IconSun, IconMoon } from '@tabler/icons-react';
import cx from 'clsx';
import classes from './Demo.module.css';

function Demo() {
const { setColorScheme } = useMantineColorScheme();
const computedColorScheme = useComputedColorScheme('light', { getInitialValueInEffect: true });

return (
<ActionIcon
onClick={() => setColorScheme(computedColorScheme === 'light' ? 'dark' : 'light')}
variant=""default""
size=""xl""
aria-label=""Toggle color scheme""
>
<IconSun className={cx(classes.icon, classes.light)} stroke={1.5} />
<IconMoon className={cx(classes.icon, classes.dark)} stroke={1.5} />
</ActionIcon>
);
}
```  
> **colorScheme for client only applications**
>
> You can safely use `colorScheme` value in client only applications (for example, Vite or create-react-app applications).
> In this case, there is no hydration, and thus hydration error cannot occur.",0.007692307692307693,11,0
eval2_q014,"Does Mantine provide a built-in way to synchronize state across browser tabs (e.g., theme/color scheme), and how do I use it?",12d83b92-d7a0-47be-883a-b0eeb981be74,"Topic: LLMDocumentation
Section: Example prompts

Here are some example prompts you can use with AI tools:  
* ""Using Mantine v8, how do I create a dark mode toggle?""
* ""Show me how to use the AppShell component with a collapsible navbar""
* ""How can I customize the theme colors in MantineProvider?""
* ""Create a form with validation using Mantine's form hooks""
* ""How to align input with a button in a flex container?""",0.007575757575757576,12,0
eval2_q014,"Does Mantine provide a built-in way to synchronize state across browser tabs (e.g., theme/color scheme), and how do I use it?",50fd4fa7-4f7a-4be0-abdb-b3518de6faa3,"Topic: General
Section: Get color scheme value in component

To get color scheme value in component use `useMantineColorScheme` hook:  
```tsx
import { useMantineColorScheme } from '@mantine/core';

function Demo() {
// colorScheme is `'dark' | 'light' | 'auto'`
const { colorScheme } = useMantineColorScheme();
}
```  
If you want to get computed color scheme, use `useComputedColorScheme` hook instead.
It will resolve `auto` value to `dark` or `light` based on user preferences:  
```tsx
import { useComputedColorScheme } from '@mantine/core';

function Demo() {
// colorScheme is `'dark' | 'light'`
const colorScheme = useComputedColorScheme();
}
```  
Note that both hooks are using `localStorage` to store color scheme value.
It is not possible to get color scheme value on the server side – the value
will always fallback to `light` during SSR.",0.007575757575757576,13,0
eval2_q014,"Does Mantine provide a built-in way to synchronize state across browser tabs (e.g., theme/color scheme), and how do I use it?",1b6b2f3b-58fd-492d-a7d6-a1e2017fbebb,"Topic: General
Section: Can I get color scheme value in JavaScript?

If your application does not have server-side rendering, you can get color scheme value
with `useMantineColorScheme` hook:  
```tsx
import { useMantineColorScheme } from '@mantine/core';

function MyComponent() {
const { colorScheme } = useMantineColorScheme();

// ✅ Works in Vite and other client-side bundlers/frameworks
// ❌ Hydration mismatch in Next.js, React Router, and other server-side rendering frameworks
return <div>Color scheme is {colorScheme}</div>;
}
```  
If you have server-side rendering in your application (Next.js, React Router, etc.), you should
not rely on JavaScript to get color scheme value – conditional rendering based on color
scheme value will produce hydration mismatch. In this case, the only option is to use
styles to hide/show elements based on the color scheme value.",0.007462686567164179,14,0
eval2_q014,"Does Mantine provide a built-in way to synchronize state across browser tabs (e.g., theme/color scheme), and how do I use it?",d7787c2f-e1a9-4b44-be1a-e16b898f8e04,"Topic: General
Section: Overview

# Is there a way to add mask to Mantine input?
Learn how to integrate mask libraries with Mantine inputs  
Mantine does not provide built-in mask functionality, but you can easily integrate any mask library with Mantine inputs.
The recommended library is [react-imask](https://www.npmjs.com/package/react-imask):  
<InstallScript packages=""react-imask"" />  
You can use it with [InputBase](https://mantine.dev/core/input/#inputbase-component) component
to create custom input with mask:  
#### Example: InputMask  
```tsx
import { IMaskInput } from 'react-imask';
import { InputBase } from '@mantine/core';

function Demo() {
return (
<InputBase
label=""Your phone""
component={IMaskInput}
mask=""+7 (000) 000-0000""
placeholder=""Your phone""
/>
);
}
```",0.007462686567164179,15,0
eval2_q014,"Does Mantine provide a built-in way to synchronize state across browser tabs (e.g., theme/color scheme), and how do I use it?",db4c26bb-ff2d-402e-9502-9cece1bbc931,"Topic: useLocalStorage
Section: Example

Example of a color scheme toggle button that uses `use-local-storage` hook
to store current color scheme in the `localStorage`:  
```tsx
import { IconMoonStars, IconSun } from '@tabler/icons-react';
import { ActionIcon } from '@mantine/core';
import { useLocalStorage } from '@mantine/hooks';

function ColorSchemeToggle() {
const [colorScheme, setColorScheme] = useLocalStorage<
'light' | 'dark'
>({
key: 'color-scheme',
defaultValue: 'light',
});

const toggleColorScheme = () =>
setColorScheme((current) =>
current === 'dark' ? 'light' : 'dark'
);

return (
<ActionIcon onClick={toggleColorScheme}>
{colorScheme === 'dark' ? <IconSun /> : <IconMoonStars />}
</ActionIcon>
);
}
```",0.007352941176470588,16,1
eval2_q014,"Does Mantine provide a built-in way to synchronize state across browser tabs (e.g., theme/color scheme), and how do I use it?",47d04ab4-7516-42e6-b12a-6aee0aa55d7c,"Topic: General
Section: Overview

# How can I change component color prop value depending on the color scheme?
Learn how to use CSS variables resolver to change color value depending on the color scheme  
`color` prop in all components uses Mantine [CSS variables](https://mantine.dev/styles/css-variables)
to resolve color value depending on the color scheme. You can define these variables with `virtualColor` function:  
#### Example: ColorSchemeColor  
```tsx
import { virtualColor, createTheme, MantineProvider } from '@mantine/core';

const theme = createTheme({
colors: {
primary: virtualColor({ name: 'primary', light: 'blue', dark: 'red' }),
},
});

function App() {
return (
<MantineProvider theme={theme}>
<YourApp />
</MantineProvider>
);
}
```",0.007246376811594203,17,0
eval2_q014,"Does Mantine provide a built-in way to synchronize state across browser tabs (e.g., theme/color scheme), and how do I use it?",5cdf8b15-6457-43e0-9c22-1b7b75d8c081,"Topic: MantineProvider
Section: Overview

# MantineProvider  
`MantineProvider` provides a [theme object](https://mantine.dev/theming/theme-object) context value, manages color scheme
changes and injects [CSS variables](https://mantine.dev/styles/css-variables/). It must be rendered at the root of your
application and should be used only once.",0.007142857142857143,18,0
eval2_q014,"Does Mantine provide a built-in way to synchronize state across browser tabs (e.g., theme/color scheme), and how do I use it?",3852ed4c-9e90-40d3-8c99-1a757ac6a8d2,"Topic: useDebouncedState
Section: Differences from use-debounce-value

* You do not have direct access to the non-debounced value.
* It is used for uncontrolled inputs (`defaultValue` prop instead of `value`), for example does not render with every state change like a character typed in an input.
* It does not work with custom state providers or props, and it uses `useState` internally.",0.007042253521126761,19,0
eval2_q014,"Does Mantine provide a built-in way to synchronize state across browser tabs (e.g., theme/color scheme), and how do I use it?",e86180bf-1d8c-428e-a45d-48eef2272940,"Topic: General
Section: Get color scheme value outside of component

To get color scheme value outside of component, create an utility function
that will parse color scheme value from `data-mantine-color-scheme` attribute:  
```tsx
import { MantineColorScheme } from '@mantine/core';

export function getColorScheme() {
return document.documentElement.getAttribute(
'data-mantine-color-scheme'
) as MantineColorScheme;
}
```  
Then use it in any place of your application:  
```tsx
import { getColorScheme } from './getColorScheme';

const colorScheme = getColorScheme();
```  
Note that this approach will not work on the server side.",0.007042253521126761,20,0
eval2_q014,"Does Mantine provide a built-in way to synchronize state across browser tabs (e.g., theme/color scheme), and how do I use it?",53646216-8541-4af5-bacd-c080c3390460,"Topic: General
Section: Is there a way to add hover styles inline in jsx?

Mantine does not provide a way to add hover styles inline in jsx as a library feature.
However, in your project you can use any third-party styling library that supports
inline styles, for example [styled-components](https://styled-components.com/)
or [emotion](https://emotion.sh/).",0.006944444444444444,21,0
eval2_q014,"Does Mantine provide a built-in way to synchronize state across browser tabs (e.g., theme/color scheme), and how do I use it?",9fc70b96-d1a7-466b-b969-3daf1d8a81fc,"Topic: General
Section: Overview

# use-local-storage hook returns real value only after mounting, is it a bug?
Learn how Mantine retrieves local storage value",0.006944444444444444,22,0
eval2_q014,"Does Mantine provide a built-in way to synchronize state across browser tabs (e.g., theme/color scheme), and how do I use it?",af04e459-6e24-426c-b3e2-2dafc94825f2,"Topic: Tabs
Section: Usage with Next.js router

```tsx
// For file /tabs/[activeTab].tsx
import { useRouter } from 'next/router';
import { Tabs } from '@mantine/core';

function Demo() {
const router = useRouter();

return (
<Tabs
value={router.query.activeTab as string}
onChange={(value) => router.push(`/tabs/${value}`)}
>
<Tabs.List>
<Tabs.Tab value=""first"">First tab</Tabs.Tab>
<Tabs.Tab value=""second"">Second tab</Tabs.Tab>
</Tabs.List>
</Tabs>
);
}
```  
#### Example: stylesApi  
```tsx
import { Tabs } from '@mantine/core';

function Demo() {
return (
<Tabs defaultValue=""gallery"">
<Tabs.List>
<Tabs.Tab value=""gallery"" leftSection={<IconPhoto size={12} />}>
Gallery
</Tabs.Tab>
<Tabs.Tab value=""messages"" leftSection={<IconMessageCircle size={12} />}>
Messages
</Tabs.Tab>
<Tabs.Tab value=""settings"" rightSection={<IconSettings size={12} />}>
Settings
</Tabs.Tab>
</Tabs.List>

<Tabs.Panel value=""gallery"" pt=""xs"">
Gallery tab content
</Tabs.Panel>

<Tabs.Panel value=""messages"" pt=""xs"">
Messages tab content
</Tabs.Panel>

<Tabs.Panel value=""settings"" pt=""xs"">
Settings tab content
</Tabs.Panel>
</Tabs>
);
}
```  
Example of Styles API usage to customize tab styles:  
#### Example: customize  
```tsx
// Demo.module.css
.tab {
position: relative;
border: 1px solid light-dark(var(--mantine-color-gray-2), var(--mantine-color-dark-4));
background-color: light-dark(var(--mantine-color-white), var(--mantine-color-dark-6));

&:first-of-type {
border-radius: 4px 0 0 4px;

@mixin rtl {
border-radius: 0 4px 4px 0;
}
}

&:last-of-type {
border-radius: 0 4px 4px 0;

@mixin rtl {
border-radius: 4px 0 0 4px;
}
}

& + & {
border-left-width: 0;

@mixin rtl {
border-right-width: 0;
border-left-width: 1px;
}
}

@mixin hover {
background-color: light-dark(var(--mantine-color-gray-0), var(--mantine-color-dark-5));
}

&[data-active] {
z-index: 1;
background-color: var(--mantine-color-blue-filled);
border-color: var(--mantine-color-blue-filled);
color: var(--mantine-color-white);",0.00684931506849315,23,0
eval2_q014,"Does Mantine provide a built-in way to synchronize state across browser tabs (e.g., theme/color scheme), and how do I use it?",e08a2d85-8a49-4d0f-92f3-2e9552bade60,"Topic: General
Section: Is there anything I need to do on my side to make my app accessible?

Of course! While Mantine components provide a solid foundation for accessible applications,
there are still things that you need to do to ensure that your app is fully accessible.
If the component requires props to make it accessible, it will be mentioned in the component
documentation.  
Things to look out for while building accessible applications:  
* Use semantic HTML elements where possible: use `<button>` for buttons, `<a>` for links, etc.
* Provide proper labels for inputs
* Use `aria-label` attribute where necessary
* Ensure that your app is fully navigable with a keyboard
* Ensure that all elements in your app have proper color contrast
* And more  
If you are interested in learning more about web accessibility, you can check out these
free courses:  
* [Web Accessibility on Udacity](https://www.udacity.com/course/web-accessibility--ud891)
* [Develop Accessible Web Apps with React on Egghead](https://egghead.io/courses/develop-accessible-web-apps-with-react)",0.00684931506849315,24,0
eval2_q014,"Does Mantine provide a built-in way to synchronize state across browser tabs (e.g., theme/color scheme), and how do I use it?",39793647-c59b-4ee5-8810-27bf1dbdc1fc,"Topic: General
Section: Overview

# Can I have different primary color for light and dark color schemes?
Learn how to use virtual color with primary color in theme object",0.006756756756756757,25,0
eval2_q014,"Does Mantine provide a built-in way to synchronize state across browser tabs (e.g., theme/color scheme), and how do I use it?",8e777a70-5289-4770-ad83-f206be449423,"Topic: ColorSchemes
Section: Overview

# Color schemes  
[MantineProvider](https://mantine.dev/theming/mantine-provider/) manages color scheme context in your application.
You can configure the default color scheme value with `defaultColorScheme` prop, possible values are `light`,
`dark` and `auto` (system color scheme is used). The default value is `light`.  
```tsx
import { MantineProvider } from '@mantine/core';

function Demo() {
return (
<MantineProvider defaultColorScheme=""dark"">
{/* Your app here */}
</MantineProvider>
);
}
```",0.006756756756756757,26,0
eval2_q014,"Does Mantine provide a built-in way to synchronize state across browser tabs (e.g., theme/color scheme), and how do I use it?",7455370d-2940-4e6d-8482-80020b597851,"Topic: General
Section: Overview

# How can I display different elements in light and dark color schemes?
Learn how to hide/show elements based on color scheme",0.006666666666666667,27,0
eval2_q016,How can I attach a custom validation rule to a single field using Mantine useForm?,dbcfa01d-bf85-45f1-a696-38516043c0d1,"Topic: formValidation
Section: Function based validation

Another approach to handle validation is to provide a function to `validate`.
Function takes form values as single argument and should return object that contains
errors of corresponding fields. If field is valid or field validation is not required, you can either return null or simply omit it
from the validation results.  
#### Example: validateFunction  
```tsx
import { useForm } from '@mantine/form';
import { Box, TextInput, NumberInput, Button, Group } from '@mantine/core';

function Demo() {
const form = useForm<{ name: string; age: number | undefined }>({
mode: 'uncontrolled',
initialValues: { name: '', age: undefined },
validate: (values) => ({
name: values.name.length < 2 ? 'Too short name' : null,
age:
values.age === undefined
? 'Age is required'
: values.age < 18
? 'You must be at least 18'
: null,
}),
});

return (
<Box maw={340} mx=""auto"">
<form onSubmit={form.onSubmit((values) => console.log(values))}>
<TextInput
label=""Name""
placeholder=""Name""
key={form.key('name')}
{...form.getInputProps('name')}
/>
<NumberInput
mt=""sm""
label=""Age""
placeholder=""You age""
key={form.key('age')}
{...form.getInputProps('age')}
/>

<Group justify=""flex-end"" mt=""md"">
<Button type=""submit"">Submit</Button>
</Group>
</form>
</Box>
);
}
```",0.01575682382133995,1,3
eval2_q016,How can I attach a custom validation rule to a single field using Mantine useForm?,bad2b183-ba7c-49cf-924e-14434e8c9f7d,"Topic: formValidation
Section: Rule function arguments

Each form rule receives the following arguments:  
* `value` – value of field
* `values` – all form values
* `path` – field path, for example `user.email` or `cart.0.price`  
`path` argument can be used to get information about field location relative to other fields,
for example you can get index of array element:  
```tsx
import { useForm } from '@mantine/form';

const form = useForm({
mode: 'uncontrolled',
initialValues: { a: [{ b: 1 }, { b: 2 }] },
validate: {
a: {
b: (value, values, path) => (path === 'a.0.b' ? 'error' : null),
},
},
});
```",0.015640273704789834,2,0
eval2_q016,How can I attach a custom validation rule to a single field using Mantine useForm?,5577cd1e-4ea5-40fe-a7a8-0970d40afd74,"Topic: formValidation
Section: Validation based on other form values

You can get all form values as a second rule function argument to perform field validation based on other
form values. For example, you can validate that password confirmation is the same as password:  
#### Example: password  
```tsx
import { useForm } from '@mantine/form';
import { PasswordInput, Group, Button, Box } from '@mantine/core';

function Demo() {
const form = useForm({
mode: 'uncontrolled',
initialValues: {
password: 'secret',
confirmPassword: 'sevret',
},

validate: {
confirmPassword: (value, values) =>
value !== values.password ? 'Passwords did not match' : null,
},
});

return (
<Box maw={340} mx=""auto"">
<form onSubmit={form.onSubmit((values) => console.log(values))}>
<PasswordInput
label=""Password""
placeholder=""Password""
key={form.key('password')}
{...form.getInputProps('password')}
/>

<PasswordInput
mt=""sm""
label=""Confirm password""
placeholder=""Confirm password""
key={form.key('confirmPassword')}
{...form.getInputProps('confirmPassword')}
/>

<Group justify=""flex-end"" mt=""md"">
<Button type=""submit"">Submit</Button>
</Group>
</form>
</Box>
);
}
```",0.015504807692307693,3,0
eval2_q016,How can I attach a custom validation rule to a single field using Mantine useForm?,c4e23ef0-77b3-43c4-95d6-4c270952a5ae,"Topic: use-form
Section: Validation

[Form validation guide](https://mantine.dev/form/validation/)  
```tsx
import { useForm } from '@mantine/form';

const form = useForm({
mode: 'uncontrolled',
initialValues: {
email: '',
user: {
firstName: '',
lastName: '',
},
},
validate: {
email: (value) => (value.length < 2 ? 'Invalid email' : null),
user: {
firstName: (value) =>
value.length < 2
? 'First name must have at least 2 letters'
: null,
},
},
});

// Validates all fields with specified `validate` function or schema, sets form.errors
form.validate();

// Validates single field at specified path, sets form.errors
form.validateField('user.firstName');

// Works the same way as form.validate but does not set form.errors
form.isValid();
form.isValid('user.firstName');
```",0.015399194503672116,4,2
eval2_q016,How can I attach a custom validation rule to a single field using Mantine useForm?,14ca02ed-07aa-4da1-b5b9-52156b0ca147,"Topic: General
Section: What should I do instead?

If you are building a form that requires usage of Mantine inputs
with custom UI, you should validate form data after it has been
submitted. You can use [@mantine/form](https://mantine.dev/form/use-form) package
to perform form validation on submit.",0.013799010277883519,5,0
eval2_q016,How can I attach a custom validation rule to a single field using Mantine useForm?,12d83b92-d7a0-47be-883a-b0eeb981be74,"Topic: LLMDocumentation
Section: Example prompts

Here are some example prompts you can use with AI tools:  
* ""Using Mantine v8, how do I create a dark mode toggle?""
* ""Show me how to use the AppShell component with a collapsible navbar""
* ""How can I customize the theme colors in MantineProvider?""
* ""Create a form with validation using Mantine's form hooks""
* ""How to align input with a button in a flex container?""",0.00819672131147541,6,0
eval2_q016,How can I attach a custom validation rule to a single field using Mantine useForm?,5ba13c70-aa34-42f3-9fe7-6dd1bf71b6ed,"Topic: formValidation
Section: Validation with rules object

To validate form with rules object, provide an object of functions which take field value as an argument
and return error message (any React node) or null if field is valid:  
#### Example: rulesValidation  
```tsx
import { useForm } from '@mantine/form';
import { NumberInput, TextInput, Button } from '@mantine/core';

function Demo() {
const form = useForm({
mode: 'uncontrolled',
initialValues: { name: '', email: '', age: 0 },

// functions will be used to validate values at corresponding key
validate: {
name: (value) => (value.length < 2 ? 'Name must have at least 2 letters' : null),
email: (value) => (/^\\S+@\\S+$/.test(value) ? null : 'Invalid email'),
age: (value) => (value < 18 ? 'You must be at least 18 to register' : null),
},
});

return (
<form onSubmit={form.onSubmit(console.log)}>
<TextInput
label=""Name""
placeholder=""Name""
key={form.key('name')}
{...form.getInputProps('name')}
/>
<TextInput
mt=""sm""
label=""Email""
placeholder=""Email""
key={form.key('email')}
{...form.getInputProps('email')}
/>
<NumberInput
mt=""sm""
label=""Age""
placeholder=""Age""
min={0}
max={99}
key={form.key('age')}
{...form.getInputProps('age')}
/>
<Button type=""submit"" mt=""sm"">
Submit
</Button>
</form>
);
}
```",0.00819672131147541,7,3
eval2_q016,How can I attach a custom validation rule to a single field using Mantine useForm?,cc225b5c-dc27-4216-b4a4-998be3ebdc6b,"Topic: formStatus
Section: isTouched and isDirty functions

```tsx
import { useForm } from '@mantine/form';

const form = useForm({
mode: 'uncontrolled',
initialValues: { a: 1, nested: { field: '' } },
});

// Provide path as first argument to get state of single field
form.isTouched('a'); // -> was field 'a' focused or changed?
form.isDirty('a'); // -> was field 'a' modified?
form.isDirty('nested.field'); // -> nested fields are also supported

// If field path is not provided,
// then functions will return form state instead
form.isTouched(); // -> was any field in form focused or changed?
form.isDirty(); // -> was any field in form modified?
```",0.007936507936507936,8,0
eval2_q016,How can I attach a custom validation rule to a single field using Mantine useForm?,62c77b3f-b70c-40e4-a816-34ca7cb54a7a,"Topic: formValidation
Section: formRootRule

{fields}

{form.errors.employees && (
<Text c=""red"" size=""sm"" mt=""sm"">
{form.errors.employees}
</Text>
)}

<Group justify=""space-between"" mt=""md"">
<Button
variant=""default""
onClick={() => {
form.insertListItem('employees', { name: '', active: false, key: randomId() });
form.clearFieldError('employees');
}}
>
Add employee
</Button>
<Button type=""submit"">Submit</Button>
</Group>
</form>
);
}
```  
Another example is to validate an object fields combination:  
#### Example: rootRuleObject  
```tsx
import { Button, Text, TextInput } from '@mantine/core';
import { formRootRule, isNotEmpty, useForm } from '@mantine/form';

function Demo() {
const form = useForm({
mode: 'uncontrolled',
initialValues: {
user: {
firstName: '',
lastName: '',
},
},

validate: {
user: {
[formRootRule]: (value) =>
value.firstName.trim().length > 0 && value.firstName === value.lastName
? 'First name and last name cannot be the same'
: null,
firstName: isNotEmpty('First name is required'),
lastName: isNotEmpty('Last name is required'),
},
},
});

return (
<form onSubmit={form.onSubmit(() => {})}>
<TextInput
label=""First name""
placeholder=""First name""
{...form.getInputProps('user.firstName')}
/>
<TextInput
label=""Last name""
placeholder=""Last name""
mt=""md""
{...form.getInputProps('user.lastName')}
/>
{form.errors.user && (
<Text c=""red"" mt={5} fz=""sm"">
{form.errors.user}
</Text>
)}
<Button type=""submit"" mt=""lg"">
Submit
</Button>
</form>
);
}
```",0.0078125,9,0
eval2_q016,How can I attach a custom validation rule to a single field using Mantine useForm?,4f7d59f5-ce64-4b54-ab0b-b3608e05be27,"Topic: formSchemaValidation
Section: superstruct

Installation:  
```bash
yarn add superstruct mantine-form-superstruct-resolver
```  
```bash
npm install superstruct mantine-form-superstruct-resolver
```  
Basic fields validation:  
```tsx
import isEmail from 'is-email';
import { superstructResolver } from 'mantine-form-superstruct-resolver';
import * as s from 'superstruct';

const emailString = s.define('email', isEmail);

const schema = s.object({
name: s.size(s.string(), 2, 30),
email: emailString,
age: s.min(s.number(), 18),
});

const form = useForm({
mode: 'uncontrolled',
initialValues: {
name: '',
email: '',
age: 16,
},
validate: superstructResolver(schema),
});

form.validate();
form.errors;
// -> {
//   name: 'name: Expected a string with a length between `2` and `30` but received one with a length of `0`',
//   email: 'email: Expected a value of type `email`, but received: `""""`',
//   age: 'age: Expected a number greater than or equal to 18 but received `16`',
// }
```  
Nested fields validation:  
```tsx
import { superstructResolver } from 'mantine-form-superstruct-resolver';
import * as s from 'superstruct';
import { useForm } from '@mantine/form';

const nestedSchema = s.object({
nested: s.object({
field: s.size(s.string(), 2, 30),
}),
});

const form = useForm({
mode: 'uncontrolled',
initialValues: {
nested: {
field: '',
},
},
validate: superstructResolver(nestedSchema),
});

form.validate();
form.errors;
// -> {
//  'nested.field': 'nested field: Expected a string with a length between `2` and `30` but received one with a length of `0`',
// }
```  
List fields validation:  
```tsx
import { superstructResolver } from 'mantine-form-superstruct-resolver';
import * as s from 'superstruct';
import { useForm } from '@mantine/form';

const listSchema = s.object({
list: s.array(
s.object({
name: s.size(s.string(), 2, 30),
})
),
});

const form = useForm({
mode: 'uncontrolled',
initialValues: {
list: [{ name: '' }],
},
validate: superstructResolver(listSchema),
});",0.007575757575757576,10,0
eval2_q016,How can I attach a custom validation rule to a single field using Mantine useForm?,15b25006-677e-4da4-9986-7c6e414a6b10,"Topic: formValidation
Section: formRootRule

`formRootRule` is a special rule path that can be used to validate objects and arrays
alongside with their nested fields. For example, it is useful when you want to capture
a list of values, validate each value individually and then validate the list itself
to not be empty:  
#### Example: rootRuleArray  
```tsx
import { IconTrash } from '@tabler/icons-react';
import { ActionIcon, Button, Group, Switch, Text, TextInput } from '@mantine/core';
import { formRootRule, isNotEmpty, useForm } from '@mantine/form';
import { randomId } from '@mantine/hooks';

function Demo() {
const form = useForm({
mode: 'uncontrolled',
initialValues: {
employees: [{ name: '', active: false, key: randomId() }],
},
validate: {
employees: {
[formRootRule]: isNotEmpty('At least one employee is required'),
name: isNotEmpty('Name is required'),
},
},
});

const fields = form.getValues().employees.map((item, index) => (
<Group key={item.key} mt=""xs"">
<TextInput
placeholder=""John Doe""
withAsterisk
style={{ flex: 1 }}
key={form.key(`employees.${index}.name`)}
{...form.getInputProps(`employees.${index}.name`)}
/>
<Switch
label=""Active""
key={form.key(`employees.${index}.active`)}
{...form.getInputProps(`employees.${index}.active`, { type: 'checkbox' })}
/>
<ActionIcon color=""red"" onClick={() => form.removeListItem('employees', index)}>
<IconTrash size={16} />
</ActionIcon>
</Group>
));

return (
<form onSubmit={form.onSubmit(() => {})}>
{fields.length > 0 ? (
<Group mb=""xs"">
<Text fw={500} size=""sm"" style={{ flex: 1 }}>
Name
</Text>
<Text fw={500} size=""sm"" pr={90}>
Status
</Text>
</Group>
) : (
<Text c=""dimmed"" ta=""center"">
No one here...
</Text>
)}

{fields}

{form.errors.employees && (
<Text c=""red"" size=""sm"" mt=""sm"">
{form.errors.employees}
</Text>
)}",0.007462686567164179,11,0
eval2_q016,How can I attach a custom validation rule to a single field using Mantine useForm?,ada84152-5deb-4822-980f-f919ec356bb5,"Topic: formNested
Section: Nested object values validation

```tsx
import { useForm } from '@mantine/form';

const form = useForm({
mode: 'uncontrolled',
initialValues: {
user: {
name: '',
occupation: '',
},
},

validate: {
user: {
name: (value) =>
value.length < 2 ? 'Name is too short' : null,
occupation: (value) =>
value.length < 2 ? 'Occupation is too short' : null,
},
},
});

form.validate();
form.errors; // -> { 'user.name': 'Name is too short', 'user.occupation': 'Occupation is too short' }
```",0.007352941176470588,12,0
eval2_q016,How can I attach a custom validation rule to a single field using Mantine useForm?,c9052073-49f8-4783-b1d4-ce840bc66b98,"Topic: formStatus
Section: touchTrigger option

`touchTrigger` option allows customizing events that change touched state.
It accepts two options:  
* `change` (default) – field will be considered touched when its value changes or it has been focused
* `focus` – field will be considered touched only when it has been focused  
Example of using `focus` trigger:  
```tsx
import { useForm } from '@mantine/form';

const form = useForm({
mode: 'uncontrolled',
initialValues: { a: 1 },
touchTrigger: 'focus',
});

form.isTouched('a'); // -> false
form.setFieldValue('a', 2);
form.isTouched('a'); // -> false

// onFocus is called automatically when the user focuses the field
form.getInputProps('a').onFocus();
form.isTouched('a'); // -> true
```",0.007352941176470588,13,0
eval2_q016,How can I attach a custom validation rule to a single field using Mantine useForm?,639fd17d-4fca-48ca-b6a4-e1e8a56a3659,"Topic: General
Section: Overview

# How can I load fonts in Vite?
A guide to load custom fonts in Vite",0.007246376811594203,14,0
eval2_q016,How can I attach a custom validation rule to a single field using Mantine useForm?,7fa6efc3-aa08-4fe2-8f07-e356f822e3fc,"Topic: formValidation
Section: Focus first invalid field

The second argument of the `form.onSubmit` function is a callback function that is called
with the [errors object](https://mantine.dev/form/errors) when form validation fails.
You can use this callback to focus the first invalid field or perform any other action.  
To get the DOM node of any input, use `form.getInputNode('path-to-field')`. Note that
in order for this feature to work, you need to spread `form.getInputProps('path-to-field')` to
the input element.  
#### Example: focusError  
```tsx
import { Button, Group, TextInput } from '@mantine/core';
import { isEmail, isNotEmpty, useForm } from '@mantine/form';

function Demo() {
const form = useForm({
mode: 'uncontrolled',
name: 'register-form',
initialValues: {
name: '',
email: '',
},

validate: {
name: isNotEmpty('Name is required'),
email: isEmail('Invalid email'),
},
});

return (
<form
onSubmit={form.onSubmit(
(values) => console.log(values),
(errors) => {
const firstErrorPath = Object.keys(errors)[0];
form.getInputNode(firstErrorPath)?.focus();
}
)}
>
<TextInput
withAsterisk
label=""Your name""
placeholder=""Your name""
key={form.key('name')}
{...form.getInputProps('name')}
/>

<TextInput
withAsterisk
label=""Your email""
placeholder=""your@email.com""
mt=""md""
key={form.key('email')}
{...form.getInputProps('email')}
/>

<Group justify=""flex-end"" mt=""md"">
<Button type=""submit"">Submit</Button>
</Group>
</form>
);
}
```",0.007246376811594203,15,0
eval2_q016,How can I attach a custom validation rule to a single field using Mantine useForm?,1cdad156-a6e5-4ba6-b1f1-7c59027ad4bc,"Topic: formValidators
Section: Usage

`@mantine/form` package exports several functions that can be used in [validation rules object](https://mantine.dev/form/validation/#validation-with-rules-object).
Validation functions are tiny in size and provide basic validation, if you have complex validation requirements, use other types of [validation](https://mantine.dev/form/validation/).  
#### Example: validators  
```tsx
import { useForm, isNotEmpty, isEmail, isInRange, hasLength, matches } from '@mantine/form';
import { Button, Group, TextInput, NumberInput } from '@mantine/core';

function Demo() {
const form = useForm({
mode: 'uncontrolled',
initialValues: {
name: '',
job: '',
email: '',
favoriteColor: '',
age: 18,
},

validate: {
name: hasLength({ min: 2, max: 10 }, 'Name must be 2-10 characters long'),
job: isNotEmpty('Enter your current job'),
email: isEmail('Invalid email'),
favoriteColor: matches(/^#([0-9a-f]{3}){1,2}$/, 'Enter a valid hex color'),
age: isInRange({ min: 18, max: 99 }, 'You must be 18-99 years old to register'),
},
});

return (
<form onSubmit={form.onSubmit(() => {})}>
<TextInput
label=""Name""
placeholder=""Name""
withAsterisk
key={form.key('name')}
{...form.getInputProps('name')}
/>
<TextInput
label=""Your job""
placeholder=""Your job""
withAsterisk
mt=""md""
key={form.key('job')}
{...form.getInputProps('job')}
/>
<TextInput
label=""Your email""
placeholder=""Your email""
withAsterisk
mt=""md""
key={form.key('email')}
{...form.getInputProps('email')}
/>
<TextInput
label=""Your favorite color""
placeholder=""Your favorite color""
withAsterisk
mt=""md""
key={form.key('favoriteColor')}
{...form.getInputProps('favoriteColor')}
/>
<NumberInput
label=""Your age""
placeholder=""Your age""
withAsterisk
mt=""md""
key={form.key('age')}
{...form.getInputProps('age')}
/>

<Group justify=""flex-end"" mt=""md"">
<Button type=""submit"">Submit</Button>
</Group>
</form>
);
}
```",0.007142857142857143,16,0
eval2_q016,How can I attach a custom validation rule to a single field using Mantine useForm?,9cc4f652-947d-4bc7-86c9-46edafb76af8,"Topic: use-field
Section: Usage

`use-field` hook is a simpler alternative to [use-form](https://mantine.dev/form/use-form), it can be used to
manage state of a single input without the need to create a form:",0.007142857142857143,17,0
eval2_q016,How can I attach a custom validation rule to a single field using Mantine useForm?,52273f35-41a7-44aa-9e02-09ca6e66490c,"Topic: General
Section: Overview

# How can I load fonts in React Router?
A guide to load custom fonts in React Router",0.007042253521126761,18,0
eval2_q016,How can I attach a custom validation rule to a single field using Mantine useForm?,5de224a1-1f29-4ea9-b17f-95fb7a5d7d16,"Topic: formSchemaValidation
Section: joi

const listSchema = Joi.object({
list: Joi.array().items(
Joi.object({
name: Joi.string().min(2).messages({
'string.min': 'Name should have at least 2 letters',
'string.empty': 'Name should have at least 2 letters',
}),
})
),
});

const form = useForm({
mode: 'uncontrolled',
initialValues: {
list: [{ name: '' }],
},
validate: joiResolver(listSchema),
});

form.validate();
form.errors;
// -> {
//  'list.0.name': 'Name should have at least 2 letters',
// }
```",0.006944444444444444,19,0
eval2_q016,How can I attach a custom validation rule to a single field using Mantine useForm?,b67d297a-80dd-4d74-aedc-43beac0fc905,"Topic: General
Section: Overview

# How can I load fonts in Next.js?
A guide to load custom fonts in Next.js with CSS and next/font package",0.006944444444444444,20,0
eval2_q016,How can I attach a custom validation rule to a single field using Mantine useForm?,7761cdd0-b8d4-4573-8228-ae72bdd22b32,"Topic: formSchemaValidation
Section: valibot

const listSchema = v.object({
list: v.array(
v.object({
name: v.pipe(
v.string(),
v.minLength(2, 'Name should have at least 2 letters')
),
})
),
});

const form = useForm({
initialValues: {
list: [{ name: '' }],
},
validate: valibotResolver(listSchema),
});

form.validate();
form.errors;
// -> {
//  'list.0.name': 'Name should have at least 2 letters',
// }
```  
With TypeScript:  
You can use the `InferInput` type from the `valibot` library to get the type of the form data.  
```tsx
import { valibotResolver } from 'mantine-form-valibot-resolver';
import * as v from 'valibot';
import { useForm } from '@mantine/form';

export const userSchema = v.object({
email: v.pipe(v.string(), v.email()),
});

type FormData = v.InferInput<typeof userSchema>;

const form = useForm<FormData>({
initialValues: {
email: '',
},
validate: valibotResolver(userSchema),
});
```",0.00684931506849315,21,0
eval2_q016,How can I attach a custom validation rule to a single field using Mantine useForm?,f0c22a49-3a10-4694-b048-3dc8bd9bdf42,"Topic: use-form
Section: Values

[Form values guide](https://mantine.dev/form/values/)  
```tsx
// get current form values
form.getValues();

// Set all form values
form.setValues(values);

// Set all form values using the previous state
form.setValues((prev) => ({ ...prev, ...values }));

// Set value of single field
form.setFieldValue('path', value);

// Set value of nested field
form.setFieldValue('user.firstName', 'Jane');

// Resets form values to `initialValues`,
// clears all validation errors,
// resets touched and dirty state
form.reset();

// Reset field at `path` to its initial value
form.resetField('path');

// Sets initial values, used when form is reset
form.setInitialValues({ values: 'object' });
```",0.00684931506849315,22,0
eval2_q016,How can I attach a custom validation rule to a single field using Mantine useForm?,6adc897b-619e-4cac-b6cc-031314186030,"Topic: formNested
Section: List values validation

```tsx
import { useForm } from '@mantine/form';

const form = useForm({
mode: 'uncontrolled',
initialValues: {
users: [
{ name: 'John', age: 12 },
{ name: '', age: 22 },
],
},

validate: {
users: {
name: (value) =>
value.length < 2
? 'Name should have at least 2 letters'
: null,
age: (value) =>
value < 18 ? 'User must be 18 or older' : null,
},
},
});

// Validate list item field
form.validateField('users.1.name');

// Or with all other fields
form.validate();
console.log(form.errors);
// {
//  'users.0.age': 'User must be 18 or older',
//  'users.1.name': 'Name should have at least 2 letters'
// }
```",0.006756756756756757,23,0
eval2_q016,How can I attach a custom validation rule to a single field using Mantine useForm?,cde727ab-afa3-4a8d-b7ab-5cf25b989b57,"Topic: formGetInputProps
Section: enhanceGetInputProps

`enhanceGetInputProps` is a function that can be used to add additional props to the object returned by `form.getInputProps`.
You can define it in `useForm` hook options. Its argument is an object with the following properties:  
* `inputProps` – object returned by `form.getInputProps` by default
* `field` – field path, first argument of `form.getInputProps`, for example `name`, `user.email`, `users.0.name`
* `options` – second argument of `form.getInputProps`, for example `{ type: 'checkbox' }`, can be used to pass additional
options to `enhanceGetInputProps` function
* `form` – form instance  
Example of using `enhanceGetInputProps` to disable input based on field path:  
#### Example: enhanceGetInputProps  
```tsx
import { NumberInput, TextInput } from '@mantine/core';
import { useForm } from '@mantine/form';

interface FormValues {
name: string;
age: number | string;
}

function Demo() {
const form = useForm<FormValues>({
mode: 'uncontrolled',
initialValues: { name: '', age: '' },
enhanceGetInputProps: (payload) => ({
disabled: payload.field === 'name',
}),
});

return (
<>
<TextInput
{...form.getInputProps('name')}
key={form.key('name')}
label=""Name""
placeholder=""Name""
/>
<NumberInput
{...form.getInputProps('age')}
key={form.key('age')}
label=""Age""
placeholder=""Age""
mt=""md""
/>
</>
);
}
```  
Example of using `enhanceGetInputProps` to add additional props to the input based on option passed to `form.getInputProps`:  
#### Example: enhanceGetInputPropsOptions  
```tsx
import { NumberInput, TextInput } from '@mantine/core';
import { useForm } from '@mantine/form';

interface FormValues {
name: string;
age: number | string;
}",0.006666666666666667,24,0
eval2_q016,How can I attach a custom validation rule to a single field using Mantine useForm?,e1e2f91d-155c-4950-af91-9eb6d003f74e,"Topic: formValidation
Section: Validate fields on change

function Demo() {
const form = useForm({
mode: 'uncontrolled',
validateInputOnChange: [
'email',
'name',
// use FORM_INDEX to reference fields indices
`jobs.${FORM_INDEX}.title`,
],
initialValues: { name: '', email: '', age: 0, jobs: [{ title: '' }, { title: '' }] },

// functions will be used to validate values at corresponding key
validate: {
name: (value) => (value.length < 2 ? 'Name must have at least 2 letters' : null),
email: (value) => (/^\\S+@\\S+$/.test(value) ? null : 'Invalid email'),
age: (value) => (value < 18 ? 'You must be at least 18 to register' : null),
jobs: {
title: (value) => (value.length < 2 ? 'Job must have at least 2 letters' : null),
},
},
});

return (
<form onSubmit={form.onSubmit(console.log)}>
<TextInput
label=""Name""
placeholder=""Name""
key={form.key('name')}
{...form.getInputProps('name')}
/>
<TextInput
mt=""sm""
label=""Email""
placeholder=""Email""
key={form.key('email')}
{...form.getInputProps('email')}
/>
<NumberInput
mt=""sm""
label=""Age""
placeholder=""Age""
min={0}
max={99}
key={form.key('age')}
{...form.getInputProps('age')}
/>
<TextInput
mt=""sm""
label=""Job 1""
placeholder=""Job 1""
key={form.key('jobs.0.title')}
{...form.getInputProps('jobs.0.title')}
/>
<TextInput
mt=""sm""
label=""Job 2""
placeholder=""Job 2""
key={form.key('jobs.1.title')}
{...form.getInputProps('jobs.1.title')}
/>
<Button type=""submit"" mt=""sm"">
Submit
</Button>
</form>
);
}
```",0.006666666666666667,25,0
