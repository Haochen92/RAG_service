query_id,query_text,run_name,param_value,rank,dist,chunk_id,chunk_text,relevance
eval2_q001,How do I apply a global theme override so it affects Mantine components across my app?,hnsw_ef50_k15,50,1,0.23490220622516378,06d97495-b768-4e2a-82d5-66ed3c7d1e31,"Topic: ThemeObject
Section: Usage

To customize theme, pass theme override object to [MantineProvider](https://mantine.dev/theming/mantine-provider/) `theme` prop.
Theme override will be deeply merged with the default theme.  
```tsx
import { createTheme, MantineProvider } from '@mantine/core';

const theme = createTheme({
colors: {
// Add your color
deepBlue: [
'#eef3ff',
'#dce4f5',
'#b9c7e2',
'#94a8d0',
'#748dc1',
'#5f7cb8',
'#5474b4',
'#44639f',
'#39588f',
'#2d4b81',
],
// or replace default theme color
blue: [
'#eef3ff',
'#dee2f2',
'#bdc2de',
'#98a0ca',
'#7a84ba',
'#6672b0',
'#5c68ac',
'#4c5897',
'#424e88',
'#364379',
],
},

shadows: {
md: '1px 1px 3px rgba(0, 0, 0, .25)',
xl: '5px 5px 3px rgba(0, 0, 0, .25)',
},

headings: {
fontFamily: 'Roboto, sans-serif',
sizes: {
h1: { fontSize: '36px' },
},
},
});

function Demo() {
return (
<MantineProvider theme={theme}>
{/* Your app here */}
</MantineProvider>
);
}
```",3
eval2_q001,How do I apply a global theme override so it affects Mantine components across my app?,hnsw_ef50_k15,50,2,0.2425041600355432,a73b35a1-5e03-4501-819e-647c6ec354ff,"Topic: MantineProvider
Section: theme

Pass [theme object](https://mantine.dev/theming/theme-object) override to `theme` prop. It will be merged with the default
theme and used in all components.  
```tsx
import { createTheme, MantineProvider } from '@mantine/core';

const theme = createTheme({
fontFamily: 'Open Sans, sans-serif',
primaryColor: 'cyan',
});

function Demo() {
return (
<MantineProvider theme={theme}>
{/* Your app here */}
</MantineProvider>
);
}
```",2
eval2_q001,How do I apply a global theme override so it affects Mantine components across my app?,hnsw_ef50_k15,50,3,0.2503577936947803,94658c3e-118f-4f05-a352-9edaec5611c7,"Topic: ThemeObject
Section: Access theme outside of components

To access theme outside of components, you need to create a full theme object
(your theme override merged with the default theme).  
```tsx
// theme.ts
import {
createTheme,
DEFAULT_THEME,
mergeMantineTheme,
} from '@mantine/core';

const themeOverride = createTheme({
primaryColor: 'orange',
defaultRadius: 0,
});

export const theme = mergeMantineTheme(DEFAULT_THEME, themeOverride);
```  
Then you will be able to import it anywhere in your application:  
```tsx
import { theme } from './theme';
```",1
eval2_q001,How do I apply a global theme override so it affects Mantine components across my app?,hnsw_ef50_k15,50,4,0.2560495925691735,f1657aa4-ce58-4252-ae82-6c26bfa8e1ef,"Topic: MantineProvider
Section: Usage

```tsx
import { createTheme, MantineProvider } from '@mantine/core';

const theme = createTheme({
/** Your theme override here */
});

function Demo() {
return (
<MantineProvider theme={theme}>
{/* Your app here */}
</MantineProvider>
);
}
```",2
eval2_q001,How do I apply a global theme override so it affects Mantine components across my app?,hnsw_ef50_k15,50,5,0.2673097403764827,efb6c05b-4345-4354-a145-871e5bb6bf6f,"Topic: GlobalStyles
Section: Add global styles in your application

It is recommended to use [CSS modules](https://mantine.dev/styles/css-modules) to apply styles to Mantine components
with `className` prop or with [Styles API](https://mantine.dev/styles/styles-api). CSS modules files names usually
end with `.module.css`, if you want to add global styles to your application, create a file with
`.css` extension but without `.module` part, for example `global.css`.  
In global `.css` files you can reference all Mantine [CSS variables](https://mantine.dev/styles/css-variables) and
change styles of `<body />`, `:root` and other elements. For example, to change body background-color:  
```css
body {
background-color: var(--mantine-color-red-filled);
}
```",0
eval2_q001,How do I apply a global theme override so it affects Mantine components across my app?,hnsw_ef50_k15,50,6,0.26743902657815555,fb79f741-6566-428e-b662-0b85e34376ff,"Topic: ThemeObject
Section: Store theme override object in a variable

To store theme override object in a variable, use `createTheme` function:  
```tsx
import { createTheme, MantineProvider } from '@mantine/core';

const myTheme = createTheme({
primaryColor: 'orange',
defaultRadius: 0,
});

function Demo() {
return (
<MantineProvider theme={myTheme}>
{/* Your app here */}
</MantineProvider>
);
}
```",2
eval2_q001,How do I apply a global theme override so it affects Mantine components across my app?,hnsw_ef50_k15,50,7,0.2733403529709939,cae49f74-7c18-4f1d-9566-887a28b609d7,"Topic: Storybook
Section: Theme object

To shared [theme object](https://mantine.dev/theming/theme-object) between your application and Storybook, create
`src/theme.ts` (or any other path in your application) file with your theme override:  
```tsx
// src/theme.ts
import { createTheme } from '@mantine/core';

export const theme = createTheme({
fontFamily: 'serif',
// ... other theme override properties
});
```  
Then you will be able to use the same theme both in your application and Storybook:  
```tsx
// In your application

import { MantineProvider } from '@mantine/core';
import { theme } from './theme';

function App() {
return <MantineProvider theme={theme}>{/* ... */}</MantineProvider>;
}
```",0
eval2_q001,How do I apply a global theme override so it affects Mantine components across my app?,hnsw_ef50_k15,50,8,0.284770395062802,2d9f0958-63d9-439c-ae88-91ce5e3af470,"Topic: MantineProvider
Section: MantineProvider props

`MantineProvider` supports the following props:  
```tsx
interface MantineProviderProps {
/** Theme override object */
theme?: MantineThemeOverride;

/** Used to retrieve/set color scheme value in external storage, by default uses `window.localStorage` */
colorSchemeManager?: MantineColorSchemeManager;

/** Default color scheme value used when `colorSchemeManager` cannot retrieve value from external storage, `light` by default */
defaultColorScheme?: MantineColorScheme;

/** Forces color scheme value, if set, MantineProvider ignores `colorSchemeManager` and `defaultColorScheme` */
forceColorScheme?: 'light' | 'dark';

/** CSS selector to which CSS variables should be added, by default variables are applied to `:root` and `:host` */
cssVariablesSelector?: string;

/** Determines whether theme CSS variables should be added to given `cssVariablesSelector`, `true` by default */
withCssVariables?: boolean;

/** Determines whether CSS variables should be deduplicated: if CSS variable has the same value as in default theme, it is not added in the runtime. `true` by default. */
deduplicateCssVariables?: boolean;

/** Function to resolve root element to set `data-mantine-color-scheme` attribute, must return undefined on server, `() => document.documentElement` by default */
getRootElement?: () => HTMLElement | undefined;

/** A prefix for components static classes (for example {selector}-Text-root), `mantine` by default */
classNamesPrefix?: string;

/** Function to generate nonce attribute added to all generated `<style />` tags */
getStyleNonce?: () => string;

/** Function to generate CSS variables based on theme object */
cssVariablesResolver?: CSSVariablesResolver;

/** Determines whether components should have static classes, for example, `mantine-Button-root`. `true` by default */
withStaticClasses?: boolean;",1
eval2_q001,How do I apply a global theme override so it affects Mantine components across my app?,hnsw_ef50_k15,50,9,0.2856001494904251,67f8b975-7f51-47f3-9497-3075ae311f24,"Topic: GettingStarted
Section: Get started without framework

const theme = createTheme({
/** Put your mantine theme override here */
});

function Demo() {
return (
<MantineProvider theme={theme}>
{/* Your app here */}
</MantineProvider>
);
}
```  
If your application has server side rendering, add [ColorSchemeScript](https://mantine.dev/theming/color-schemes)
to the `<head />` of your application and spread `mantineHtmlProps` on the `<html />` element
to [avoid seeing a hydration warning](https://help.mantine.dev/q/color-scheme-hydration-warning):  
```tsx
import { ColorSchemeScript, mantineHtmlProps } from '@mantine/core';

function Demo() {
return (
<html lang=""en"" {...mantineHtmlProps}>
<head>
<meta charSet=""UTF-8"" />
<meta
name=""viewport""
content=""width=device-width, initial-scale=1.0""
/>
<title>My awesome app</title>

<ColorSchemeScript />
</head>
<body>{/* Your app here */}</body>
</html>
);
}
```  
All set! You can now use Mantine components in your application.",2
eval2_q001,How do I apply a global theme override so it affects Mantine components across my app?,hnsw_ef50_k15,50,10,0.2859555120089796,46580bac-7ff9-4ace-8cec-03b216e9e904,"Topic: DefaultProps
Section: Default props with MantineThemeProvider

You can also use `MantineThemeProvider` to define default props
for a part of your application:  
```tsx
import {
Button,
createTheme,
MantineThemeProvider,
} from '@mantine/core';

const theme = createTheme({
components: {
Button: Button.extend({
defaultProps: {
color: 'cyan',
variant: 'outline',
},
}),
},
});

function Demo() {
return (
<>
<MantineThemeProvider theme={theme}>
{/* Part of the app with theme */}
</MantineThemeProvider>

{/* Another part without theme */}
</>
);
}
```",0
eval2_q001,How do I apply a global theme override so it affects Mantine components across my app?,hnsw_ef50_k15,50,11,0.2869877095512171,361a10e6-9d7d-483e-bade-a800172c5cc5,"Topic: ThemeObject
Section: Default theme

You can import default theme object from `@mantine/core` package. It includes
all theme properties with default values. When you pass theme override to
[MantineProvider](https://mantine.dev/theming/mantine-provider), it will be deeply merged with
the default theme.  
```tsx
import { DEFAULT_THEME } from '@mantine/core';
```",1
eval2_q001,How do I apply a global theme override so it affects Mantine components across my app?,hnsw_ef50_k15,50,12,0.2878878481020598,fa3dde3d-e5f5-4a1a-97d1-295b085a28a8,"Topic: MantineProvider
Section: Overview

# MantineProvider  
`MantineProvider` provides a [theme object](https://mantine.dev/theming/theme-object) context value, manages color scheme
changes and injects [CSS variables](https://mantine.dev/styles/css-variables/). It must be rendered at the root of your
application and should be used only once.",1
eval2_q001,How do I apply a global theme override so it affects Mantine components across my app?,hnsw_ef50_k15,50,13,0.2887177091623334,5bdf7d3f-7bf1-4a6b-9db6-f5a4140fcdd4,"Topic: General
Section: How can I customize colors with theme?

You can define custom colors in the [theme object](https://mantine.dev/theming/theme-object).  
```tsx
import { createTheme, MantineProvider } from '@mantine/core';

const theme = createTheme({
colors: {
sepia: [
'#F4ECD8',
'#EAD8B7',
'#DFC29A',
'#D4AC7E',
'#C99862',
'#BD8447',
'#B2702D',
'#A55C15',
'#924908',
'#7A3704',
],
},
});

function Demo() {
return (
<MantineProvider theme={theme}>
<App />
</MantineProvider>
);
}
```  
Then you can reference these values in components and `.css` files:  
```scss
body {
background-color: var(--mantine-color-sepia-0);
color: var(--mantine-color-sepia-9);
}
```",1
eval2_q001,How do I apply a global theme override so it affects Mantine components across my app?,hnsw_ef50_k15,50,14,0.29298265932230383,2a46a3c1-fb44-431a-b007-e44b7c266107,"Topic: ColorSchemes
Section: Overview

# Color schemes  
[MantineProvider](https://mantine.dev/theming/mantine-provider/) manages color scheme context in your application.
You can configure the default color scheme value with `defaultColorScheme` prop, possible values are `light`,
`dark` and `auto` (system color scheme is used). The default value is `light`.  
```tsx
import { MantineProvider } from '@mantine/core';

function Demo() {
return (
<MantineProvider defaultColorScheme=""dark"">
{/* Your app here */}
</MantineProvider>
);
}
```",0
eval2_q001,How do I apply a global theme override so it affects Mantine components across my app?,hnsw_ef50_k15,50,15,0.2933505492081232,19866a8f-031f-4a2d-b69b-9426c7903438,"Topic: DefaultProps
Section: Overview

# Default props  
You can define default props for every Mantine component by setting `theme.components`.
These props will be used by default by all components of your application unless they are overridden by component props:  
#### Example: defaultProps  
```tsx
import { MantineProvider, Button, Group, createTheme } from '@mantine/core';

const theme = createTheme({
components: {
Button: Button.extend({
defaultProps: {
color: 'cyan',
variant: 'outline',
},
}),
},
});

function Demo() {
return (
<MantineProvider theme={theme}>
<Group>
<Button>Default button</Button>
<Button color=""red"" variant=""filled"">
Button with props
</Button>
</Group>
</MantineProvider>
);
}
```",1
eval2_q002,How can I set a global default border radius so most components use it automatically?,hnsw_ef50_k15,50,1,0.28736775741490794,4740c498-7641-4108-a6a5-2c5db7623db6,"Topic: ThemeObject
Section: defaultRadius

`theme.defaultRadius` controls the default `border-radius` property in most components, for example, [Button](https://mantine.dev/core/button) or [TextInput](https://mantine.dev/core/text-input).
You can set to either one of the values from `theme.radius` or a number/string to use exact value. Note that numbers are treated as pixels, but
converted to rem. For example, `theme.defaultRadius: 4` will be converted to `0.25rem`.
You can learn more about rem conversion in the [rem units guide](https://mantine.dev/styles/rem).  
#### Example: defaultRadiusConfigurator  
```tsx
import { MantineProvider, TextInput, Button } from '@mantine/core';

function Demo() {
return (
<MantineProvider theme={{ defaultRadius: '' }}>
<Button fullWidth>Button with defaultRadius</Button>
<TextInput mt=""sm"" label=""TextInput with defaultRadius"" placeholder=""TextInput with default radius"" />
</MantineProvider>
);
}
```",3
eval2_q002,How can I set a global default border radius so most components use it automatically?,hnsw_ef50_k15,50,2,0.31637970796765247,77a63a0c-0156-4aaf-a96a-da88546dfc3d,"Topic: CssVariables
Section: Border radius variables

Mantine components that support `radius` prop use border radius variables to control border radius.
The following CSS variables are defined based on `theme.radius`:  
<CssVariablesGroup
data={[
{
variable: '--mantine-radius-xs',
defaultValue: '0.125rem (2px)',
},
{
variable: '--mantine-radius-sm',
defaultValue: '0.25rem (4px)',
},
{
variable: '--mantine-radius-md',
defaultValue: '0.5rem (8px)',
},
{
variable: '--mantine-radius-lg',
defaultValue: '1rem (16px)',
},
{
variable: '--mantine-radius-xl',
defaultValue: '2rem (32px)',
},
]}
/>  
Additionally, `--mantine-radius-default` variable is defined based on `theme.defaultRadius`
value. If `radius` prop on components is not set explicitly, `--mantine-radius-default` is used instead.  
To define custom border radius values, use `theme.radius` and `theme.defaultRadius` properties:  
```tsx
import { createTheme } from '@mantine/core';

const theme = createTheme({
defaultRadius: 'sm',
radius: {
xs: '0.25rem',
sm: '0.5rem',
md: '1rem',
lg: '2rem',
xl: '3rem',
},
});
```",2
eval2_q002,How can I set a global default border radius so most components use it automatically?,hnsw_ef50_k15,50,3,0.3624163041960523,19866a8f-031f-4a2d-b69b-9426c7903438,"Topic: DefaultProps
Section: Overview

# Default props  
You can define default props for every Mantine component by setting `theme.components`.
These props will be used by default by all components of your application unless they are overridden by component props:  
#### Example: defaultProps  
```tsx
import { MantineProvider, Button, Group, createTheme } from '@mantine/core';

const theme = createTheme({
components: {
Button: Button.extend({
defaultProps: {
color: 'cyan',
variant: 'outline',
},
}),
},
});

function Demo() {
return (
<MantineProvider theme={theme}>
<Group>
<Button>Default button</Button>
<Button color=""red"" variant=""filled"">
Button with props
</Button>
</Group>
</MantineProvider>
);
}
```",0
eval2_q002,How can I set a global default border radius so most components use it automatically?,hnsw_ef50_k15,50,4,0.3675027353543976,52deeacc-817a-4c25-a3d3-85c1c2af2e2b,"Topic: GlobalStyles
Section: Body and :root elements styles

`@mantine/core` package includes the following `body` and `:root` elements styles:  
```css
:root {
color-scheme: var(--mantine-color-scheme);
}

body {
font-family: var(--mantine-font-family);
font-size: var(--mantine-font-size-md);
line-height: var(--mantine-line-height);
background-color: var(--mantine-color-body);
color: var(--mantine-color-text);

-webkit-font-smoothing: var(--mantine-webkit-font-smoothing);
-moz-osx-font-smoothing: var(--mantine-moz-font-smoothing);
}
```",0
eval2_q002,How can I set a global default border radius so most components use it automatically?,hnsw_ef50_k15,50,5,0.3732024521701235,8dfc7539-fa70-42e5-9a94-03a1748df654,"Topic: GlobalStyles
Section: CSS reset

`@mantine/core` package includes minimal CSS reset – it includes only basic styles required for components to work
in modern browsers. If you need to support older browsers, you can additionally include [normalize.css](https://necolas.github.io/normalize.css/)
or any other CSS reset of your choice.  
```css
body {
margin: 0;
}

*,
*::before,
*::after {
box-sizing: border-box;
}

input,
button,
textarea,
select {
font: inherit;
}

button,
select {
text-transform: none;
}
```",0
eval2_q002,How can I set a global default border radius so most components use it automatically?,hnsw_ef50_k15,50,6,0.3742983562178416,168081bb-33e5-4d59-8ea1-3e929608a2be,"Topic: ThemeObject
Section: defaultGradient

`theme.defaultGradient` controls the default gradient configuration for components that support `variant=""gradient""`
([Button](https://mantine.dev/core/button), [ActionIcon](https://mantine.dev/core/action-icon), [Badge](https://mantine.dev/core/badge), etc.).  
#### Example: defaultGradient  
```tsx
import { MantineProvider, createTheme, Button } from '@mantine/core';

const theme = createTheme({
defaultGradient: {
from: 'orange',
to: 'red',
deg: 45,
},
});

function Demo() {
return (
<MantineProvider theme={theme}>
<Button variant=""gradient"">Button with custom default gradient</Button>
</MantineProvider>
);
}
```",0
eval2_q002,How can I set a global default border radius so most components use it automatically?,hnsw_ef50_k15,50,7,0.37500008753453873,efb6c05b-4345-4354-a145-871e5bb6bf6f,"Topic: GlobalStyles
Section: Add global styles in your application

It is recommended to use [CSS modules](https://mantine.dev/styles/css-modules) to apply styles to Mantine components
with `className` prop or with [Styles API](https://mantine.dev/styles/styles-api). CSS modules files names usually
end with `.module.css`, if you want to add global styles to your application, create a file with
`.css` extension but without `.module` part, for example `global.css`.  
In global `.css` files you can reference all Mantine [CSS variables](https://mantine.dev/styles/css-variables) and
change styles of `<body />`, `:root` and other elements. For example, to change body background-color:  
```css
body {
background-color: var(--mantine-color-red-filled);
}
```",0
eval2_q002,How can I set a global default border radius so most components use it automatically?,hnsw_ef50_k15,50,8,0.3750232939575159,91e173e8-30fc-4879-a412-41c5afc4b6ea,"Topic: StyleProp
Section: Define CSS variables in style prop

You can define CSS variables in the style prop. Note that it only works with Mantine components:  
```tsx
import { Box } from '@mantine/core';

function Demo() {
return (
<Box
style={{ '--radius': '0.5rem', borderRadius: 'var(--radius)' }}
/>
);
}
```",0
eval2_q002,How can I set a global default border radius so most components use it automatically?,hnsw_ef50_k15,50,9,0.37613420286621624,5136ba5a-c0e6-4456-a6ae-7bea74b4d5fe,"Topic: Paper
Section: Polymorphic component

function Demo() {
return <Paper component=""button"" />;
}
```  
You can also use components in component prop, for example, Next.js Link:  
```tsx
import Link from 'next/link';
import { Paper } from '@mantine/core';

function Demo() {
return <Paper component={Link} href=""/"" />;
}
```  
**Polymorphic components with TypeScript**  
Note that polymorphic components props types are different from regular components – they do not extend HTML element props of the default element. For example, PaperProps does not extend React.ComponentPropsWithoutRef<'div'> although div is the default element.  
If you want to create a wrapper for a polymorphic component that is not polymorphic (does not support component prop), then your component props interface should extend HTML element props.  
#### Props  
| Prop | Type | Default | Description |
|------|------|---------|-------------|
| radius | MantineRadius | number | - | Key of <code>theme.radius</code> or any valid CSS value to set border-radius, numbers are converted to rem |
| shadow | MantineShadow | - | Key of <code>theme.shadows</code> or any valid CSS value to set <code>box-shadow</code> |
| withBorder | boolean | - | Adds border to the root element |  
#### Styles API  
Paper component supports Styles API. With Styles API, you can customize styles of any inner element. Follow the documentation to learn how to use CSS modules, CSS variables and inline styles to get full control over component styles.  
**Paper selectors**  
| Selector | Static selector | Description |
|----------|----------------|-------------|
| root | .mantine-Paper-root | Root element |  
**Paper CSS variables**  
| Selector | Variable | Description |
|----------|----------|-------------|
| root | --paper-radius | Controls `border-radius` |
| root | --paper-shadow | Controls `box-shadow` |  
**Paper data attributes**  
| Selector | Attribute | Condition | Value |
|----------|-----------|-----------|-------|
| root | data-with-border | - | - |",0
eval2_q002,How can I set a global default border radius so most components use it automatically?,hnsw_ef50_k15,50,10,0.3775796766469166,f0bf241f-d396-41d2-8a01-45d1a0e903f9,"Topic: Rem
Section: rem units

All Mantine components use `rem` units to apply size styles (`margin`, `padding`, `width`, etc.).
By default, `1rem` is considered to be `16px` as it is a default setting in most browsers.
All components scale based on the user's browser font-size settings or font-size of `html`/`:root`.  
#### Example: remSlider  
```tsx
import { Slider } from '@mantine/core';

function Demo() {
return (
<Slider
defaultValue={100}
min={70}
max={130}
onChange={(value) => {
document.documentElement.style.fontSize = `${value}%`;
}}
/>
);
}
```",0
eval2_q002,How can I set a global default border radius so most components use it automatically?,hnsw_ef50_k15,50,11,0.3775953159946691,e617def9-90f6-432c-9da0-948d5f179154,"Topic: Badge
Section: Rounded

Set `circle` prop, to reduce horizontal padding and make badge width equal to its height:  
#### Example: rounded  
```tsx
import { Badge, Group } from '@mantine/core';

function Demo() {
return (
<Group>
<Badge size=""xs"" circle>
1
</Badge>
<Badge size=""sm"" circle>
7
</Badge>
<Badge size=""md"" circle>
9
</Badge>
<Badge size=""lg"" circle>
3
</Badge>
<Badge size=""xl"" circle>
8
</Badge>
</Group>
);
}
```",0
eval2_q002,How can I set a global default border radius so most components use it automatically?,hnsw_ef50_k15,50,12,0.38195379127975726,87b00fa2-16f0-4773-b0f7-a29b919e0b9c,"Topic: SixToSeven
Section: Global styles

`Global` component and global styles on theme are not available in 7.0. Instead,
create a global stylesheet (`.css` file) and import it in your application entry point.  
```tsx
// 6.x
import { Global } from '@mantine/core';

function Demo() {
return (
<Global
styles={(theme) => ({
'*, *::before, *::after': {
boxSizing: 'border-box',
},

body: {
backgroundColor:
theme.colorScheme === 'dark'
? theme.colors.dark[7]
: theme.white,
color:
theme.colorScheme === 'dark'
? theme.colors.dark[0]
: theme.black,
lineHeight: theme.lineHeight,
},

'.your-class': {
backgroundColor: 'red',
},

'#your-id > [data-active]': {
backgroundColor: 'pink',
},
})}
/>
);
}
```  
```scss
/* 7.0 */
/* src/index.css */
*,
*::before,
*::after {
box-sizing: border-box;
}

body {
background-color: light-dark(
var(--mantine-color-white),
var(--mantine-color-dark-7)
);
color: light-dark(
var(--mantine-color-black),
var(--mantine-color-white)
);
line-height: var(--mantine-line-height);
}

.your-class {
background-color: red;
}

#your-id > [data-active] {
background-color: pink;
}
```",0
eval2_q002,How can I set a global default border radius so most components use it automatically?,hnsw_ef50_k15,50,13,0.38482309372013246,7e5fa7be-6192-4edc-8325-15b88973bea6,"Topic: CSSFilesList
Section: Global styles

All Mantine components depend on global styles, you need to import them before
all other styles:  
* `baseline.css` – a minimal CSS reset, sets `box-sizing: border-box` and changes font properties
* `default-css-variables.css` – contains all CSS variables generated from the default theme
* `global.css` – global classes used in Mantine components  
```tsx
import '@mantine/core/styles/baseline.css';
import '@mantine/core/styles/default-css-variables.css';
import '@mantine/core/styles/global.css';
```",0
eval2_q002,How can I set a global default border radius so most components use it automatically?,hnsw_ef50_k15,50,14,0.387508787167276,566b2f26-b60a-4af5-bbfb-05447e8bf38b,"Topic: Rem
Section: rem units scaling

If you want to change font-size of `:root`/`html` element and preserve Mantine components sizes,
set `scale` on [theme](https://mantine.dev/theming/theme-object) to the value of `1 / htmlFontSize`.  
For example, if you set `html` font-size to `10px` and want to scale Mantine components accordingly, you need
to set `scale` to `1 / (10 / 16)` (16 – default font-size) = `1 / 0.625` = `1.6`:  
```css
:root {
font-size: 10px;
}
```  
```tsx
import { createTheme, MantineProvider } from '@mantine/core';

const theme = createTheme({
scale: 1.6,
});

function Demo() {
return (
<MantineProvider theme={theme}>
{/* Your app here */}
</MantineProvider>
);
}
```",0
eval2_q002,How can I set a global default border radius so most components use it automatically?,hnsw_ef50_k15,50,15,0.38830998172252595,52442738-dfca-4f36-aa38-3bd5a0ed8f0f,"Topic: StylesOverview
Section: Component specific props

Most of the components provide props that allow you to customize their styles. For example,
[Button](https://mantine.dev/core/button/) component has `color`, `variant`, `size` and `radius` props that control its
appearance:  
#### Example: configurator  
```tsx
import { Button } from '@mantine/core';

function Demo() {
return <Button>Button</Button>;
}
```  
These props usually control multiple CSS properties, for example `color` and variant props control `color`,
`background-color` and `border` properties. In most cases, changing components props is the most optimal way to customize Mantine components.",0
eval2_q004,How can I define and use a new Button style variant via theming?,hnsw_ef50_k15,50,1,0.2679064889063685,b99099dc-e8cc-44dd-8fb6-551797586f2c,"Topic: Button
Section: Custom variants

To add new `Button` variants, use [data-variant](https://mantine.dev/styles/variants-sizes) attribute.
Usually new variants are added on [theme](https://mantine.dev/theming/theme-object), this way they are
available in all `Button` components in your application.  
#### Example: customVariant  
```tsx
// Demo.tsx
import { Group, Button, MantineProvider, createTheme } from '@mantine/core';
import classes from './Demo.module.css';

const theme = createTheme({
components: {
Button: Button.extend({
classNames: classes,
}),
},
});

function Demo() {
return (
<MantineProvider theme={theme}>
<Group>
<Button variant=""danger"">Danger variant</Button>
<Button variant=""primary"">Primary variant</Button>
</Group>
</MantineProvider>
);
}

// Demo.module.css
.root {
&[data-variant='danger'] {
background-color: var(--mantine-color-red-9);
color: var(--mantine-color-red-0);
}

&[data-variant='primary'] {
background: linear-gradient(45deg, #4b6cb7 10%, #253b67 90%);
color: var(--mantine-color-white);
border-width: 0;
}
}
```",3
eval2_q004,How can I define and use a new Button style variant via theming?,hnsw_ef50_k15,50,2,0.3091384738199502,3a4953dc-922b-4de1-aec5-381e1e352a2a,"Topic: Button
Section: Customize variants colors

You can customize colors for `Button` and other components variants by adding
[variantColorResolver](https://mantine.dev/theming/colors#colors-variant-resolver) to your theme.  
#### Example: variantColorsResolver  
```tsx
import {
Button,
Group,
MantineProvider,
defaultVariantColorsResolver,
VariantColorsResolver,
parseThemeColor,
rgba,
darken,
} from '@mantine/core';

const variantColorResolver: VariantColorsResolver = (input) => {
const defaultResolvedColors = defaultVariantColorsResolver(input);
const parsedColor = parseThemeColor({
color: input.color || input.theme.primaryColor,
theme: input.theme,
});

// Override some properties for variant
if (parsedColor.isThemeColor && parsedColor.color === 'lime' && input.variant === 'filled') {
return {
...defaultResolvedColors,
color: 'var(--mantine-color-black)',
hoverColor: 'var(--mantine-color-black)',
};
}

// Completely override variant
if (input.variant === 'light') {
return {
background: rgba(parsedColor.value, 0.1),
hover: rgba(parsedColor.value, 0.15),
border: `1px solid ${parsedColor.value}`,
color: darken(parsedColor.value, 0.1),
};
}

// Add new variants support
if (input.variant === 'danger') {
return {
background: 'var(--mantine-color-red-9)',
hover: 'var(--mantine-color-red-8)',
color: 'var(--mantine-color-white)',
border: 'none',
};
}

return defaultResolvedColors;
};

function Demo() {
return (
<MantineProvider theme={{ variantColorResolver }}>
<Group>
<Button color=""lime.4"" variant=""filled"">
Lime filled button
</Button>

<Button color=""orange"" variant=""light"">
Orange light button
</Button>

<Button variant=""danger"">Danger button</Button>
</Group>
</MantineProvider>
);
}
```  
<AutoContrast component=""Button"" />",1
eval2_q004,How can I define and use a new Button style variant via theming?,hnsw_ef50_k15,50,3,0.3152737431760446,437bbfcd-2c11-4ff9-9a21-293c4d31994d,"Topic: VariantsAndSizes
Section: variantColorResolver

[Button](https://mantine.dev/core/button), [Badge](https://mantine.dev/core/badge), [ActionIcon](https://mantine.dev/core/action-icon) and other
components support custom variants with [variantColorResolver](https://mantine.dev/theming/colors#colors-variant-resolver)
– it supports both changing colors and adding new variants. Note that `theme.variantColorResolver` is
responsible only for colors, if you need to change other properties, use `data-variant` attribute.  
#### Example: variantColorsResolver  
```tsx
import {
Button,
Group,
MantineProvider,
defaultVariantColorsResolver,
VariantColorsResolver,
parseThemeColor,
rgba,
darken,
} from '@mantine/core';

const variantColorResolver: VariantColorsResolver = (input) => {
const defaultResolvedColors = defaultVariantColorsResolver(input);
const parsedColor = parseThemeColor({
color: input.color || input.theme.primaryColor,
theme: input.theme,
});

// Override some properties for variant
if (parsedColor.isThemeColor && parsedColor.color === 'lime' && input.variant === 'filled') {
return {
...defaultResolvedColors,
color: 'var(--mantine-color-black)',
hoverColor: 'var(--mantine-color-black)',
};
}

// Completely override variant
if (input.variant === 'light') {
return {
background: rgba(parsedColor.value, 0.1),
hover: rgba(parsedColor.value, 0.15),
border: `1px solid ${parsedColor.value}`,
color: darken(parsedColor.value, 0.1),
};
}

// Add new variants support
if (input.variant === 'danger') {
return {
background: 'var(--mantine-color-red-9)',
hover: 'var(--mantine-color-red-8)',
color: 'var(--mantine-color-white)',
border: 'none',
};
}

return defaultResolvedColors;
};

function Demo() {
return (
<MantineProvider theme={{ variantColorResolver }}>
<Group>
<Button color=""lime.4"" variant=""filled"">
Lime filled button
</Button>

<Button color=""orange"" variant=""light"">
Orange light button
</Button>

<Button variant=""danger"">Danger button</Button>
</Group>
</MantineProvider>
);
}
```",1
eval2_q004,How can I define and use a new Button style variant via theming?,hnsw_ef50_k15,50,4,0.3224617095918192,d1990985-0088-4e1f-acc0-463c3d985ba9,"Topic: ActionIcon
Section: Add custom variants

To add new `ActionIcon` variants, use [data-variant](https://mantine.dev/styles/variants-sizes) attribute.
Usually new variants are added on [theme](https://mantine.dev/theming/theme-object), this way they are
available in all `ActionIcon` components in your application.  
#### Example: customVariant  
```tsx
// Demo.tsx
import { Group, ActionIcon, MantineProvider, createTheme } from '@mantine/core';
import { IconHeart } from '@tabler/icons-react';
import classes from './Demo.module.css';

const theme = createTheme({
components: {
ActionIcon: ActionIcon.extend({
classNames: classes,
}),
},
});

function Demo() {
return (
<MantineProvider theme={theme}>
<Group justify=""center"">
<ActionIcon size=""xl"" variant=""danger"" aria-label=""Danger variant"">
<IconHeart />
</ActionIcon>
<ActionIcon size=""xl"" variant=""primary"" aria-label=""Primary variant"">
<IconHeart />
</ActionIcon>
</Group>
</MantineProvider>
);
}

// Demo.module.css
.root {
&[data-variant='danger'] {
background-color: var(--mantine-color-red-9);
color: var(--mantine-color-red-0);
}

&[data-variant='primary'] {
background: linear-gradient(45deg, #4b6cb7 10%, #253b67 90%);
color: var(--mantine-color-white);
}
}
```",1
eval2_q004,How can I define and use a new Button style variant via theming?,hnsw_ef50_k15,50,5,0.32271796597523217,daf4663f-fbe0-4d92-ae99-716842dc6a29,"Topic: VariantsAndSizes
Section: Adding custom variants

Most of Mantine components support `variant` prop, it can be used in CSS variables resolver,
and it is also exposed as `data-variant=""{value}""` attribute on the root element of the component.
The easiest way to add custom variants is to add styles that use `[data-variant=""{value}""]`.  
Example of adding a new variant to the [Input](https://mantine.dev/core/input) component:  
* `underline` variant styles are added
* `filled` variant is a default variant – you do not need to define any additional styles for it  
#### Example: customVariant  
```tsx
// Demo.tsx
import { Input, MantineProvider, createTheme } from '@mantine/core';
import classes from './Demo.module.css';

// It is better to add new variants in theme.components
// This way you will be able to use them in anywhere in the app
const theme = createTheme({
components: {
Input: Input.extend({ classNames: classes }),
}
});

function Demo() {
return (
<MantineProvider theme={theme}>
<Input variant=""underline"" placeholder=""Underline input"" />
<Input variant=""filled"" placeholder=""Filled input"" mt=""md"" />
</MantineProvider>
);
}

// Demo.module.css
.input {
&[data-variant='underline'] {
border-bottom: 2px solid;
border-radius: 0;
padding-left: 0;
padding-right: 0;

@mixin light {
border-color: var(--mantine-color-gray-3);
}

@mixin dark {
border-color: var(--mantine-color-dark-3);
}

&:focus {
border-color: var(--mantine-color-blue-filled);
}
}
}
```  
Note that you can add custom variants to every Mantine component that supports [Styles API](https://mantine.dev/styles/styles-api)
even if there are no variants defined on the library side.  
> **Overriding existing variants styles**
>
> Apart from adding new variants, you can also override existing ones, for example, you can change the
> `filled` variant of the [Input](https://mantine.dev/core/input) component with `.input[data-variant=""filled""]` selector.",2
eval2_q004,How can I define and use a new Button style variant via theming?,hnsw_ef50_k15,50,6,0.32645080869798493,38f88514-a083-44f0-83c0-f516f82dae76,"Topic: Button
Section: Get element ref

component supports Styles API. With Styles API, you can customize styles of any inner element. Follow the documentation to learn how to use CSS modules, CSS variables and inline styles to get full control over component styles.  
**Button selectors**  
| Selector | Static selector | Description |
|----------|----------------|-------------|
| root | .mantine-Button-root | Root element |
| loader | .mantine-Button-loader | Loader component, displayed only when `loading` prop is set |
| inner | .mantine-Button-inner | Contains all other elements, child of the `root` element |
| section | .mantine-Button-section | Left and right sections of the button |
| label | .mantine-Button-label | Button children |  
**Button CSS variables**  
| Selector | Variable | Description |
|----------|----------|-------------|
| root | --button-bg | Controls `background` |
| root | --button-bd | Control `border` |
| root | --button-hover | Controls `background` when hovered |
| root | --button-color | Control text `color` |
| root | --button-hover-color | Control text `color` when hovered |
| root | --button-radius | Controls `border-radius` |
| root | --button-height | Controls `height` of the button |
| root | --button-padding-x | Controls horizontal `padding` of the button |
| root | --button-fz | Controls `font-size` of the button |
| root | --button-justify | Controls `justify-content` of `inner` element |  
**Button data attributes**  
| Selector | Attribute | Condition | Value |
|----------|-----------|-----------|-------|
| root | data-disabled | - | - |  
**Button.Group selectors**  
| Selector | Static selector | Description |
|----------|----------------|-------------|
| group | .mantine-ButtonGroup-group | Root element |  
**Button.Group CSS variables**  
| Selector | Variable | Description |
|----------|----------|-------------|
| group | --button-border-width | `border-width` of child `Button` components |  
**Button.Group data attributes**  
| Selector | Attribute |",0
eval2_q004,How can I define and use a new Button style variant via theming?,hnsw_ef50_k15,50,7,0.3291748618996433,49cbe1fd-489c-45e5-bcb9-13d8c076433d,"Topic: VariantsAndSizes
Section: Sizes with components CSS variables

You can add custom sizes to any component that supports `size` prop by providing a custom
CSS variables resolver, usually it is done in `theme.components`:  
#### Example: vars  
```tsx
// MantineProvider.tsx
import { Button, Group, MantineProvider, createTheme } from '@mantine/core';

const theme = createTheme({
components: {
Button: Button.extend({
vars: (theme, props) => {
if (props.size === 'xxl') {
return {
root: {
'--button-height': '60px',
'--button-padding-x': '30px',
'--button-fz': '24px',
},
};
}

if (props.size === 'xxs') {
return {
root: {
'--button-height': '24px',
'--button-padding-x': '10px',
'--button-fz': '10px',
},
};
}

return { root: {} };
},
}),
},
});

function Demo() {
return (
<MantineProvider theme={theme}>
<Group>
<Button size=""xxl"">XXL Button</Button>
<Button size=""xxs"">XXS Button</Button>
</Group>
</MantineProvider>
);
}

// Inline.tsx
import { Button, PartialVarsResolver, ButtonFactory, Group } from '@mantine/core';

const varsResolver: PartialVarsResolver<ButtonFactory> = (theme, props) => {
if (props.size === 'xxl') {
return {
root: {
'--button-height': '60px',
'--button-padding-x': '30px',
'--button-fz': '24px',
},
};
}

if (props.size === 'xxs') {
return {
root: {
'--button-height': '24px',
'--button-padding-x': '10px',
'--button-fz': '10px',
},
};
}

return { root: {} };
};

function Demo() {
return (
<Group>
<Button vars={varsResolver} size=""xxl"">
XXL Button
</Button>
<Button vars={varsResolver} size=""xxs"">
XXS Button
</Button>
</Group>
);
}
```",0
eval2_q004,How can I define and use a new Button style variant via theming?,hnsw_ef50_k15,50,8,0.3297065899834618,dd937c5c-16e6-4bca-a2d3-82a792c66867,"Topic: VariantsAndSizes
Section: Custom variants types

You can define types for custom variants by creating `mantine.d.ts` file
in your project and extending `{x}Props` interface with the new variant type.  
Example of adding custom variant type to [Button](https://mantine.dev/core/button) component:  
```tsx
import { ButtonVariant, MantineSize } from '@mantine/core';

type ExtendedButtonVariant = ButtonVariant | 'contrast' | 'radial-gradient';

declare module '@mantine/core' {
export interface ButtonProps {
variant?: ExtendedButtonVariant;
}
}
```",1
eval2_q004,How can I define and use a new Button style variant via theming?,hnsw_ef50_k15,50,9,0.3298948884007027,892de58c-af3b-4942-b8bf-f365e2ba70f0,"Topic: StylesApi
Section: Components CSS variables

if (props.size === 'xxs') {
return {
root: {
'--button-height': '24px',
'--button-padding-x': '10px',
'--button-fz': '10px',
},
};
}

return { root: {} };
};

function Demo() {
return (
<Group>
<Button vars={varsResolver} size=""xxl"">
XXL Button
</Button>
<Button vars={varsResolver} size=""xxs"">
XXS Button
</Button>
</Group>
);
}
```",0
eval2_q004,How can I define and use a new Button style variant via theming?,hnsw_ef50_k15,50,10,0.33417947710092333,9535c862-f6b7-40b5-9a86-c8e2c250053c,"Topic: StylesApi
Section: Components CSS variables

Most of Mantine components use CSS variables to define colors, sizes, paddings and other
properties. You can override these values using a custom CSS variables resolver function
in [theme.components](https://mantine.dev/theming/theme-object) or by passing it to the `vars` prop.  
You can find CSS variables information under the `Styles API` tab in a component's documentation.
Example of [Button](https://mantine.dev/core/button) component CSS variables:  
<VariablesTable data={ButtonStylesApi} withTableBorder={false} fixedLayout={false} />  
Example of a custom CSS variables resolver function used to add more sizes to the [Button](https://mantine.dev/core/button) component:  
#### Example: vars  
```tsx
// MantineProvider.tsx
import { Button, Group, MantineProvider, createTheme } from '@mantine/core';

const theme = createTheme({
components: {
Button: Button.extend({
vars: (theme, props) => {
if (props.size === 'xxl') {
return {
root: {
'--button-height': '60px',
'--button-padding-x': '30px',
'--button-fz': '24px',
},
};
}

if (props.size === 'xxs') {
return {
root: {
'--button-height': '24px',
'--button-padding-x': '10px',
'--button-fz': '10px',
},
};
}

return { root: {} };
},
}),
},
});

function Demo() {
return (
<MantineProvider theme={theme}>
<Group>
<Button size=""xxl"">XXL Button</Button>
<Button size=""xxs"">XXS Button</Button>
</Group>
</MantineProvider>
);
}

// Inline.tsx
import { Button, PartialVarsResolver, ButtonFactory, Group } from '@mantine/core';

const varsResolver: PartialVarsResolver<ButtonFactory> = (theme, props) => {
if (props.size === 'xxl') {
return {
root: {
'--button-height': '60px',
'--button-padding-x': '30px',
'--button-fz': '24px',
},
};
}

if (props.size === 'xxs') {
return {
root: {
'--button-height': '24px',
'--button-padding-x': '10px',
'--button-fz': '10px',
},
};
}

return { root: {} };
};",0
eval2_q004,How can I define and use a new Button style variant via theming?,hnsw_ef50_k15,50,11,0.33516288470015587,879eb435-47f2-4c6b-a769-ce51617da176,"Topic: CssVariables
Section: Variant colors

Some Mantine components like [Button](https://mantine.dev/core/button) or [Badge](https://mantine.dev/core/badge) have `variant` prop
that in combination with `color` prop controls the component text, background and border colors.
For each variant and color, Mantine defines a set of CSS variables that control these colors.
For example, for the default `blue` color the following CSS variables are defined:  
<CssVariablesGroup
data={[
{ group: 'Filled variant' },
{
variable: '--mantine-color-blue-filled',
description: 'Background color of filled variant',
defaultValue: 'var(--mantine-color-blue-6)',
},
{
variable: '--mantine-color-blue-filled-hover',
description: 'Background color of filled variant on hover',
defaultValue: 'var(--mantine-color-blue-7)',
},
{ group: 'Light variant' },
{
variable: '--mantine-color-blue-light',
description: 'Background color of light variant',
defaultValue: 'rgba(34, 139, 230, 0.1)',
},
{
variable: '--mantine-color-blue-light-hover',
description: 'Background color of light variant on hover',
defaultValue: 'rgba(34, 139, 230, 0.12)',
},
{
variable: '--mantine-color-blue-light-color',
description: 'Text color of light variant',
defaultValue: 'var(--mantine-color-blue-6)',
},
{ group: 'Outline variant' },
{
variable: '--mantine-color-blue-outline',
description: 'Border color of outline variant',
defaultValue: 'var(--mantine-color-blue-6)',
},
{
variable: '--mantine-color-blue-outline-hover',
description: 'Border color of outline variant',
defaultValue: 'rgba(34, 139, 230, 0.05)',
},
]}
/>  
For example, if you use [Button](https://mantine.dev/core/button) component the following way:  
```tsx
import { Button } from '@mantine/core';",0
eval2_q004,How can I define and use a new Button style variant via theming?,hnsw_ef50_k15,50,12,0.3352925644454856,1fc229cc-fce1-4736-88f2-ba282d088cc3,"Topic: CssVariables
Section: Variant colors

function Demo() {
return (
<Button color=""pink"" variant=""filled"">
Filled pink button
</Button>
);
}
```  
The component will have the following styles:  
* Background color will be `var(--mantine-color-pink-filled)`
* Background color on hover will be `var(--mantine-color-pink-filled-hover)`
* Text color will be `var(--mantine-color-white)`
* Border color will be `transparent`  
Note that the variables above are not static, they are generated based on the values of
`theme.colors` and `theme.primaryShade`. Additionally, their values are different for
dark and light color schemes.  
Variant colors variables are used in all components that support `color` prop, for example,
[Button](https://mantine.dev/core/button), [Badge](https://mantine.dev/core/badge), [Avatar](https://mantine.dev/core/avatar) and [Pagination](https://mantine.dev/core/pagination).
Colors values that are used by these components are determined by `cssVariablesResolver` described below
and [variantColorResolver](https://mantine.dev/styles/variants-sizes/#variantcolorresolver).",0
eval2_q004,How can I define and use a new Button style variant via theming?,hnsw_ef50_k15,50,13,0.3399788507225605,d94c7cd7-b7f9-4975-b52a-0d7b664157fa,"Topic: Colors
Section: Colors variant resolver

// Override some properties for variant
if (parsedColor.isThemeColor && parsedColor.color === 'lime' && input.variant === 'filled') {
return {
...defaultResolvedColors,
color: 'var(--mantine-color-black)',
hoverColor: 'var(--mantine-color-black)',
};
}

// Completely override variant
if (input.variant === 'light') {
return {
background: rgba(parsedColor.value, 0.1),
hover: rgba(parsedColor.value, 0.15),
border: `1px solid ${parsedColor.value}`,
color: darken(parsedColor.value, 0.1),
};
}

// Add new variants support
if (input.variant === 'danger') {
return {
background: 'var(--mantine-color-red-9)',
hover: 'var(--mantine-color-red-8)',
color: 'var(--mantine-color-white)',
border: 'none',
};
}

return defaultResolvedColors;
};

function Demo() {
return (
<MantineProvider theme={{ variantColorResolver }}>
<Group>
<Button color=""lime.4"" variant=""filled"">
Lime filled button
</Button>

<Button color=""orange"" variant=""light"">
Orange light button
</Button>

<Button variant=""danger"">Danger button</Button>
</Group>
</MantineProvider>
);
}
```",0
eval2_q004,How can I define and use a new Button style variant via theming?,hnsw_ef50_k15,50,14,0.34030169685705425,52442738-dfca-4f36-aa38-3bd5a0ed8f0f,"Topic: StylesOverview
Section: Component specific props

Most of the components provide props that allow you to customize their styles. For example,
[Button](https://mantine.dev/core/button/) component has `color`, `variant`, `size` and `radius` props that control its
appearance:  
#### Example: configurator  
```tsx
import { Button } from '@mantine/core';

function Demo() {
return <Button>Button</Button>;
}
```  
These props usually control multiple CSS properties, for example `color` and variant props control `color`,
`background-color` and `border` properties. In most cases, changing components props is the most optimal way to customize Mantine components.",0
eval2_q004,How can I define and use a new Button style variant via theming?,hnsw_ef50_k15,50,15,0.3415990126470245,c512ebf4-b7d8-44a5-8b07-802852d54d97,"Topic: TypeScript
Section: Custom variants types

You can define types for custom [variants](https://mantine.dev/styles/variants-sizes) by
extending `{x}Props` interface with the new variant type in your `mantine.d.ts` file.  
Example of adding custom variant type to [Button](https://mantine.dev/core/button) component:  
```tsx
import { ButtonVariant, MantineSize } from '@mantine/core';

type ExtendedButtonVariant = ButtonVariant | 'contrast' | 'radial-gradient';

declare module '@mantine/core' {
export interface ButtonProps {
variant?: ExtendedButtonVariant;
}
}
```",1
eval2_q005,How can I add a persistent top header area as part of the main application layout?,hnsw_ef50_k15,50,1,0.33595894769496304,0daabe20-e833-4d30-8251-60f2480611fc,"Topic: AppShell
Section: Usage

`AppShell` is a layout component that can be used to implement a common Header / Navbar / Footer / Aside
layout pattern. All `AppShell` components have `position: fixed` style, so they do not scroll with
the page.  
[Basic AppShell example](https://mantine.dev/app-shell?e=BasicAppShell) with header and navbar.
The navbar is hidden on mobile by default and toggled with the burger button.  
```tsx
import { AppShell, Burger } from '@mantine/core';
import { useDisclosure } from '@mantine/hooks';

function Demo() {
const [opened, { toggle }] = useDisclosure();

return (
<AppShell
padding=""md""
header={{ height: 60 }}
navbar={{
width: 300,
breakpoint: 'sm',
collapsed: { mobile: !opened },
}}
>
<AppShell.Header>
<Burger
opened={opened}
onClick={toggle}
hiddenFrom=""sm""
size=""sm""
/>

<div>Logo</div>
</AppShell.Header>

<AppShell.Navbar>Navbar</AppShell.Navbar>

<AppShell.Main>Main</AppShell.Main>
</AppShell>
);
}
```",3
eval2_q005,How can I add a persistent top header area as part of the main application layout?,hnsw_ef50_k15,50,2,0.35307937297215386,1d6b7392-efc6-4980-95f0-5e9929dbe3e9,"Topic: AppShell
Section: Header offset configuration

The `header` prop includes an `offset` property that allows you to control
whether the `AppShell.Main` component is offset by the header's height.
This is particularly useful when you want to collapse the `AppShell.Header`
based on scroll position. For example, you can use the [use-headroom](https://mantine.dev/hooks/use-headroom)
hook to hide the header when the user scrolls down and show it when
scrolling up ([example](https://mantine.dev/app-shell?e=Headroom)).  
```tsx
import { AppShell, rem } from '@mantine/core';
import { useHeadroom } from '@mantine/hooks';

function Demo() {
const pinned = useHeadroom({ fixedAt: 120 });

return (
<AppShell
header={{ height: 60, collapsed: !pinned, offset: false }}
padding=""md""
>
<AppShell.Header>Header</AppShell.Header>

<AppShell.Main
pt={`calc(${rem(60)} + var(--mantine-spacing-md))`}
>
{/* Content */}
</AppShell.Main>
</AppShell>
);
}
```",2
eval2_q005,How can I add a persistent top header area as part of the main application layout?,hnsw_ef50_k15,50,3,0.3612739980872829,994314e8-203a-4bbf-96d4-4e2d623e91ee,"Topic: AppShell
Section: AppShell components

* `AppShell` – root component that wraps all other sections and configures the overall layout.
* `AppShell.Header` – fixed header at the top, controlled by the `header` prop.
* `AppShell.Navbar` – fixed navbar on the left, controlled by the `navbar` prop.
* `AppShell.Aside` – fixed aside on the right, controlled by the `aside` prop.
* `AppShell.Footer` – fixed footer at the bottom, controlled by the `footer` prop.
* `AppShell.Main` – main content area, statically positioned and offset by the other sections.
* `AppShell.Section` – utility for grouping content inside `AppShell.Navbar` or `AppShell.Aside`, useful for scrollable areas.",2
eval2_q005,How can I add a persistent top header area as part of the main application layout?,hnsw_ef50_k15,50,4,0.3644676657693393,4c87be11-bd1d-40cb-af1d-5be3deecc4c3,"Topic: Table
Section: Sticky header

Set `stickyHeader` to make table header sticky. To customize top position of the header use `stickyHeaderOffset` prop:
it is useful when you have a fixed header in your application. For example, Mantine documentation website has a fixed
header with 60px height:  
#### Example: stickyHeader  
```tsx
import { Table } from '@mantine/core';

const elements = [
{ position: 6, mass: 12.011, symbol: 'C', name: 'Carbon' },
{ position: 7, mass: 14.007, symbol: 'N', name: 'Nitrogen' },
{ position: 39, mass: 88.906, symbol: 'Y', name: 'Yttrium' },
{ position: 56, mass: 137.33, symbol: 'Ba', name: 'Barium' },
{ position: 58, mass: 140.12, symbol: 'Ce', name: 'Cerium' },
];

function Demo() {
const rows = elements.map((element) => (
<Table.Tr key={element.name}>
<Table.Td>{element.position}</Table.Td>
<Table.Td>{element.name}</Table.Td>
<Table.Td>{element.symbol}</Table.Td>
<Table.Td>{element.mass}</Table.Td>
</Table.Tr>
));

return (
<Table stickyHeader stickyHeaderOffset={60}>
<Table.Thead>
<Table.Tr>
<Table.Th>Element position</Table.Th>
<Table.Th>Element name</Table.Th>
<Table.Th>Symbol</Table.Th>
<Table.Th>Atomic mass</Table.Th>
</Table.Tr>
</Table.Thead>
<Table.Tbody>{rows}</Table.Tbody>
<Table.Caption>Scroll page to see sticky thead</Table.Caption>
</Table>
);
}
```",0
eval2_q005,How can I add a persistent top header area as part of the main application layout?,hnsw_ef50_k15,50,5,0.3708222863167512,9c937e59-976c-4382-a305-0e8427cba2ad,"Topic: useHeadroom
Section: Overview

Package: @mantine/hooks
Import: import { UseHeadroom } from '@mantine/hooks';",0
eval2_q005,How can I add a persistent top header area as part of the main application layout?,hnsw_ef50_k15,50,6,0.37121865936572496,5bc4bf3d-31c4-4a0e-be50-5f64939c2dc9,"Topic: AppShell
Section: Overview

Package: @mantine/core
Import: import { AppShell } from '@mantine/core';
Description: Responsive shell for your application with header, navbar, aside and footer",1
eval2_q005,How can I add a persistent top header area as part of the main application layout?,hnsw_ef50_k15,50,7,0.371939281028711,05b844fa-44e7-4985-a8f3-6f15436c222d,"Topic: AppShell
Section: layout prop

`layout` prop controls how `AppShell.Header`/`AppShell.Footer` and `AppShell.Navbar`/`AppShell.Aside`
are positioned relative to each other. It accepts `alt` and `default` values:  
* `alt` – `AppShell.Navbar`/`AppShell.Aside` extends the full viewport height, while `AppShell.Header`/`AppShell.Footer` width equals the viewport width minus the width of `AppShell.Navbar` and `AppShell.Aside` ([example](https://mantine.dev/app-shell?e=AltLayout))
* `default` – `AppShell.Navbar`/`AppShell.Aside` height equals the viewport height minus `AppShell.Header`/`AppShell.Footer` height, and `AppShell.Header`/`AppShell.Footer` spans the full viewport width ([example](https://mantine.dev/app-shell?e=FullLayout))",0
eval2_q005,How can I add a persistent top header area as part of the main application layout?,hnsw_ef50_k15,50,8,0.37584456838978864,c62cf2fc-bc2b-463c-bd82-19c96eb19f84,"Topic: General
Section: How can I build the same footer?

* Give footer fixed position with `position: fixed` and `bottom: 0` properties.
* Create a div element that will contain all content except footer.
* Set `min-height: 100vh` on the content container to make sure that footer is always under by the content.
* Make sure that your content container has background color.
* Done! You have a footer at the bottom of the page.",0
eval2_q005,How can I add a persistent top header area as part of the main application layout?,hnsw_ef50_k15,50,9,0.37636807683032314,43956e58-d728-4820-94f0-406317e9a123,"Topic: NextJs
Section: app + pages router together

If you use both app and pages router in one application, you need to setup both `pages/_app.tsx`
and `app/layout.tsx` files as described above.",0
eval2_q005,How can I add a persistent top header area as part of the main application layout?,hnsw_ef50_k15,50,10,0.3772358028356019,d35e16b4-13ef-4202-bdb5-e2505b866a11,"Topic: AppShell
Section: AppShell.Section component

`AppShell.Section` is used to create organized areas within `AppShell.Navbar` and `AppShell.Aside`.
Since these components are flexbox containers with `flex-direction: column`, the `AppShell.Section`
component with the `grow` prop will expand to fill available space and can be made scrollable by setting
`component={ScrollArea}`.  
In the following example:  
* The first and last sections (header and footer) take only the space needed for their content
* The middle section with `grow` takes all remaining space and becomes scrollable when content exceeds the available height  
```tsx
import { AppShell, ScrollArea } from '@mantine/core';

function Demo() {
return (
<AppShell navbar={{ width: 300, breakpoint: 0 }}>
<AppShell.Navbar>
<AppShell.Section>Navbar header</AppShell.Section>
<AppShell.Section grow component={ScrollArea}>
Navbar main section, it will
</AppShell.Section>
<AppShell.Section>
Navbar footer – always at the bottom
</AppShell.Section>
</AppShell.Navbar>
<AppShell.Main>Main</AppShell.Main>
</AppShell>
);
}
```",0
eval2_q005,How can I add a persistent top header area as part of the main application layout?,hnsw_ef50_k15,50,11,0.3797013644911085,4e0b656d-d492-4fd1-843b-eacf83cbf287,"Topic: useHeadroom
Section: Usage

Use `use-headroom` hook to create headers that are hidden after user scrolls past the given distance in px.
The hook returns a boolean value that determines whether the element should be pinned or hidden.
Hook returns `true` when the current scroll position is less than the specified `fixedAt` value and
after user scrolled up.",0
eval2_q005,How can I add a persistent top header area as part of the main application layout?,hnsw_ef50_k15,50,12,0.38000438321276053,9b20576f-5cff-48d2-a26d-7a66182ce7c0,"Topic: AppShell
Section: zIndex prop

The `zIndex` prop is available on `AppShell` and its associated sections: `AppShell.Header`, `AppShell.Navbar`, `AppShell.Aside`, and `AppShell.Footer`.
By default, all sections have a `z-index` of `100`.  
To change the `z-index` of all sections, set the `zIndex` prop on the `AppShell` component:  
```tsx
import { AppShell } from '@mantine/core';

// All sections will have z-index of 200
function Demo() {
return <AppShell zIndex={200}>{/* AppShell content */}</AppShell>;
}
```  
To change `z-index` of a specific section, set `zIndex` prop on that section:  
```tsx
import { AppShell } from '@mantine/core';

// AppShell.Header has z-index of 100
// AppShell.Navbar and AppShell.Aside have z-index of 300
function Demo() {
return (
<AppShell>
<AppShell.Header zIndex={100}>Header</AppShell.Header>
<AppShell.Navbar zIndex={300}>Navbar</AppShell.Navbar>
<AppShell.Aside zIndex={300}>Aside</AppShell.Aside>
</AppShell>
);
}
```",1
eval2_q005,How can I add a persistent top header area as part of the main application layout?,hnsw_ef50_k15,50,13,0.38017376871287123,9f46b031-fd91-4df8-af8c-1b4c04b1fbd7,"Topic: Affix
Section: Usage

`Affix` renders a div element with a fixed position inside the [Portal](https://mantine.dev/core/portal) component.
Use it to display elements fixed at any position on the screen, for example, scroll to top button:  
#### Example: usage  
```tsx
import { IconArrowUp } from '@tabler/icons-react';
import { useWindowScroll } from '@mantine/hooks';
import { Affix, Button, Text, Transition } from '@mantine/core';

function Demo() {
const [scroll, scrollTo] = useWindowScroll();",0
eval2_q005,How can I add a persistent top header area as part of the main application layout?,hnsw_ef50_k15,50,14,0.3821444623960729,4707f113-238f-4ae3-82ea-67fb37646490,"Topic: General
Section: Overview

# How can I lock scroll in my application?
Use react-remove-scroll library to lock scroll in your application  
Mantine components use [react-remove-scroll](https://github.com/theKashey/react-remove-scroll)
library to lock scroll. You can use it in your application to lock scroll. For your
convenience, `@mantine/core` package exports `RemoveScroll` component:  
```tsx
import { RemoveScroll } from '@mantine/core';

function App() {
return (
<RemoveScroll>
<div>Content</div>
</RemoveScroll>
);
}
```  
The component supports all props that are supported by `react-remove-scroll` library,
you can find the full list of props in the [official documentation](https://github.com/theKashey/react-remove-scroll).",0
eval2_q005,How can I add a persistent top header area as part of the main application layout?,hnsw_ef50_k15,50,15,0.38229138415758757,35d40eae-f07f-4e5f-afef-b3e2b0204d4f,"Topic: Rich text editor
Section: Sticky toolbar

Set `sticky` prop on `RichTextEditor.Toolbar` component to make toolbar sticky,
control `top` property with `stickyOffset`. For example, on mantine.dev documentation
website there is a header with `var(--docs-header-height)` height, in this case we will need to
set `stickyOffset=""var(--docs-header-height)""` to make sticky position correctly with fixed positioned element.",0
eval2_q016,How can I attach a custom validation rule to a single field using Mantine useForm?,hnsw_ef50_k15,50,1,0.24752938144131542,93fde8bc-8120-424f-9572-bbe679e8c4b4,"Topic: formValidation
Section: Validation with rules object

To validate form with rules object, provide an object of functions which take field value as an argument
and return error message (any React node) or null if field is valid:  
#### Example: rulesValidation  
```tsx
import { useForm } from '@mantine/form';
import { NumberInput, TextInput, Button } from '@mantine/core';

function Demo() {
const form = useForm({
mode: 'uncontrolled',
initialValues: { name: '', email: '', age: 0 },

// functions will be used to validate values at corresponding key
validate: {
name: (value) => (value.length < 2 ? 'Name must have at least 2 letters' : null),
email: (value) => (/^\\S+@\\S+$/.test(value) ? null : 'Invalid email'),
age: (value) => (value < 18 ? 'You must be at least 18 to register' : null),
},
});

return (
<form onSubmit={form.onSubmit(console.log)}>
<TextInput
label=""Name""
placeholder=""Name""
key={form.key('name')}
{...form.getInputProps('name')}
/>
<TextInput
mt=""sm""
label=""Email""
placeholder=""Email""
key={form.key('email')}
{...form.getInputProps('email')}
/>
<NumberInput
mt=""sm""
label=""Age""
placeholder=""Age""
min={0}
max={99}
key={form.key('age')}
{...form.getInputProps('age')}
/>
<Button type=""submit"" mt=""sm"">
Submit
</Button>
</form>
);
}
```",3
eval2_q016,How can I attach a custom validation rule to a single field using Mantine useForm?,hnsw_ef50_k15,50,2,0.2628122261685055,05495b1c-cc7d-473a-8045-394ce3bc78d2,"Topic: formValidation
Section: Function based validation

Another approach to handle validation is to provide a function to `validate`.
Function takes form values as single argument and should return object that contains
errors of corresponding fields. If field is valid or field validation is not required, you can either return null or simply omit it
from the validation results.  
#### Example: validateFunction  
```tsx
import { useForm } from '@mantine/form';
import { Box, TextInput, NumberInput, Button, Group } from '@mantine/core';

function Demo() {
const form = useForm<{ name: string; age: number | undefined }>({
mode: 'uncontrolled',
initialValues: { name: '', age: undefined },
validate: (values) => ({
name: values.name.length < 2 ? 'Too short name' : null,
age:
values.age === undefined
? 'Age is required'
: values.age < 18
? 'You must be at least 18'
: null,
}),
});

return (
<Box maw={340} mx=""auto"">
<form onSubmit={form.onSubmit((values) => console.log(values))}>
<TextInput
label=""Name""
placeholder=""Name""
key={form.key('name')}
{...form.getInputProps('name')}
/>
<NumberInput
mt=""sm""
label=""Age""
placeholder=""You age""
key={form.key('age')}
{...form.getInputProps('age')}
/>

<Group justify=""flex-end"" mt=""md"">
<Button type=""submit"">Submit</Button>
</Group>
</form>
</Box>
);
}
```",3
eval2_q016,How can I attach a custom validation rule to a single field using Mantine useForm?,hnsw_ef50_k15,50,3,0.26844918502493964,45b96f58-7516-4f33-92c9-d4f5999590ae,"Topic: use-form
Section: Validation

[Form validation guide](https://mantine.dev/form/validation/)  
```tsx
import { useForm } from '@mantine/form';

const form = useForm({
mode: 'uncontrolled',
initialValues: {
email: '',
user: {
firstName: '',
lastName: '',
},
},
validate: {
email: (value) => (value.length < 2 ? 'Invalid email' : null),
user: {
firstName: (value) =>
value.length < 2
? 'First name must have at least 2 letters'
: null,
},
},
});

// Validates all fields with specified `validate` function or schema, sets form.errors
form.validate();

// Validates single field at specified path, sets form.errors
form.validateField('user.firstName');

// Works the same way as form.validate but does not set form.errors
form.isValid();
form.isValid('user.firstName');
```",2
eval2_q016,How can I attach a custom validation rule to a single field using Mantine useForm?,hnsw_ef50_k15,50,4,0.27008293079974854,6e113cf0-ae4a-475b-bd0a-a2d5720a4e97,"Topic: formValidation
Section: formRootRule

{fields}

{form.errors.employees && (
<Text c=""red"" size=""sm"" mt=""sm"">
{form.errors.employees}
</Text>
)}

<Group justify=""space-between"" mt=""md"">
<Button
variant=""default""
onClick={() => {
form.insertListItem('employees', { name: '', active: false, key: randomId() });
form.clearFieldError('employees');
}}
>
Add employee
</Button>
<Button type=""submit"">Submit</Button>
</Group>
</form>
);
}
```  
Another example is to validate an object fields combination:  
#### Example: rootRuleObject  
```tsx
import { Button, Text, TextInput } from '@mantine/core';
import { formRootRule, isNotEmpty, useForm } from '@mantine/form';

function Demo() {
const form = useForm({
mode: 'uncontrolled',
initialValues: {
user: {
firstName: '',
lastName: '',
},
},

validate: {
user: {
[formRootRule]: (value) =>
value.firstName.trim().length > 0 && value.firstName === value.lastName
? 'First name and last name cannot be the same'
: null,
firstName: isNotEmpty('First name is required'),
lastName: isNotEmpty('Last name is required'),
},
},
});

return (
<form onSubmit={form.onSubmit(() => {})}>
<TextInput
label=""First name""
placeholder=""First name""
{...form.getInputProps('user.firstName')}
/>
<TextInput
label=""Last name""
placeholder=""Last name""
mt=""md""
{...form.getInputProps('user.lastName')}
/>
{form.errors.user && (
<Text c=""red"" mt={5} fz=""sm"">
{form.errors.user}
</Text>
)}
<Button type=""submit"" mt=""lg"">
Submit
</Button>
</form>
);
}
```",0
eval2_q016,How can I attach a custom validation rule to a single field using Mantine useForm?,hnsw_ef50_k15,50,5,0.27056565899355556,213af0cf-d280-4a92-bc5f-511f3ab87875,"Topic: formValidation
Section: Validation based on other form values

You can get all form values as a second rule function argument to perform field validation based on other
form values. For example, you can validate that password confirmation is the same as password:  
#### Example: password  
```tsx
import { useForm } from '@mantine/form';
import { PasswordInput, Group, Button, Box } from '@mantine/core';

function Demo() {
const form = useForm({
mode: 'uncontrolled',
initialValues: {
password: 'secret',
confirmPassword: 'sevret',
},

validate: {
confirmPassword: (value, values) =>
value !== values.password ? 'Passwords did not match' : null,
},
});

return (
<Box maw={340} mx=""auto"">
<form onSubmit={form.onSubmit((values) => console.log(values))}>
<PasswordInput
label=""Password""
placeholder=""Password""
key={form.key('password')}
{...form.getInputProps('password')}
/>

<PasswordInput
mt=""sm""
label=""Confirm password""
placeholder=""Confirm password""
key={form.key('confirmPassword')}
{...form.getInputProps('confirmPassword')}
/>

<Group justify=""flex-end"" mt=""md"">
<Button type=""submit"">Submit</Button>
</Group>
</form>
</Box>
);
}
```",0
eval2_q016,How can I attach a custom validation rule to a single field using Mantine useForm?,hnsw_ef50_k15,50,6,0.2762489344846015,bb527f9c-ce6c-429e-abd3-8b6040757628,"Topic: formValidation
Section: Rule function arguments

Each form rule receives the following arguments:  
* `value` – value of field
* `values` – all form values
* `path` – field path, for example `user.email` or `cart.0.price`  
`path` argument can be used to get information about field location relative to other fields,
for example you can get index of array element:  
```tsx
import { useForm } from '@mantine/form';

const form = useForm({
mode: 'uncontrolled',
initialValues: { a: [{ b: 1 }, { b: 2 }] },
validate: {
a: {
b: (value, values, path) => (path === 'a.0.b' ? 'error' : null),
},
},
});
```",0
eval2_q016,How can I attach a custom validation rule to a single field using Mantine useForm?,hnsw_ef50_k15,50,7,0.27735009182805337,976cf723-c5f2-4e2e-b9cc-a9604efe8bea,"Topic: formValidation
Section: formRootRule

`formRootRule` is a special rule path that can be used to validate objects and arrays
alongside with their nested fields. For example, it is useful when you want to capture
a list of values, validate each value individually and then validate the list itself
to not be empty:  
#### Example: rootRuleArray  
```tsx
import { IconTrash } from '@tabler/icons-react';
import { ActionIcon, Button, Group, Switch, Text, TextInput } from '@mantine/core';
import { formRootRule, isNotEmpty, useForm } from '@mantine/form';
import { randomId } from '@mantine/hooks';

function Demo() {
const form = useForm({
mode: 'uncontrolled',
initialValues: {
employees: [{ name: '', active: false, key: randomId() }],
},
validate: {
employees: {
[formRootRule]: isNotEmpty('At least one employee is required'),
name: isNotEmpty('Name is required'),
},
},
});

const fields = form.getValues().employees.map((item, index) => (
<Group key={item.key} mt=""xs"">
<TextInput
placeholder=""John Doe""
withAsterisk
style={{ flex: 1 }}
key={form.key(`employees.${index}.name`)}
{...form.getInputProps(`employees.${index}.name`)}
/>
<Switch
label=""Active""
key={form.key(`employees.${index}.active`)}
{...form.getInputProps(`employees.${index}.active`, { type: 'checkbox' })}
/>
<ActionIcon color=""red"" onClick={() => form.removeListItem('employees', index)}>
<IconTrash size={16} />
</ActionIcon>
</Group>
));

return (
<form onSubmit={form.onSubmit(() => {})}>
{fields.length > 0 ? (
<Group mb=""xs"">
<Text fw={500} size=""sm"" style={{ flex: 1 }}>
Name
</Text>
<Text fw={500} size=""sm"" pr={90}>
Status
</Text>
</Group>
) : (
<Text c=""dimmed"" ta=""center"">
No one here...
</Text>
)}

{fields}

{form.errors.employees && (
<Text c=""red"" size=""sm"" mt=""sm"">
{form.errors.employees}
</Text>
)}",0
eval2_q016,How can I attach a custom validation rule to a single field using Mantine useForm?,hnsw_ef50_k15,50,8,0.2802785232061825,f8cde119-86bf-4a33-b8de-9e9eeae6f791,"Topic: formNested
Section: Nested object values validation

```tsx
import { useForm } from '@mantine/form';

const form = useForm({
mode: 'uncontrolled',
initialValues: {
user: {
name: '',
occupation: '',
},
},

validate: {
user: {
name: (value) =>
value.length < 2 ? 'Name is too short' : null,
occupation: (value) =>
value.length < 2 ? 'Occupation is too short' : null,
},
},
});

form.validate();
form.errors; // -> { 'user.name': 'Name is too short', 'user.occupation': 'Occupation is too short' }
```",0
eval2_q016,How can I attach a custom validation rule to a single field using Mantine useForm?,hnsw_ef50_k15,50,9,0.28221885563028914,36a1e3cb-b9a8-45a9-aa31-49dd3a89f945,"Topic: formValidation
Section: Focus first invalid field

The second argument of the `form.onSubmit` function is a callback function that is called
with the [errors object](https://mantine.dev/form/errors) when form validation fails.
You can use this callback to focus the first invalid field or perform any other action.  
To get the DOM node of any input, use `form.getInputNode('path-to-field')`. Note that
in order for this feature to work, you need to spread `form.getInputProps('path-to-field')` to
the input element.  
#### Example: focusError  
```tsx
import { Button, Group, TextInput } from '@mantine/core';
import { isEmail, isNotEmpty, useForm } from '@mantine/form';

function Demo() {
const form = useForm({
mode: 'uncontrolled',
name: 'register-form',
initialValues: {
name: '',
email: '',
},

validate: {
name: isNotEmpty('Name is required'),
email: isEmail('Invalid email'),
},
});

return (
<form
onSubmit={form.onSubmit(
(values) => console.log(values),
(errors) => {
const firstErrorPath = Object.keys(errors)[0];
form.getInputNode(firstErrorPath)?.focus();
}
)}
>
<TextInput
withAsterisk
label=""Your name""
placeholder=""Your name""
key={form.key('name')}
{...form.getInputProps('name')}
/>

<TextInput
withAsterisk
label=""Your email""
placeholder=""your@email.com""
mt=""md""
key={form.key('email')}
{...form.getInputProps('email')}
/>

<Group justify=""flex-end"" mt=""md"">
<Button type=""submit"">Submit</Button>
</Group>
</form>
);
}
```",0
eval2_q016,How can I attach a custom validation rule to a single field using Mantine useForm?,hnsw_ef50_k15,50,10,0.2868655809785645,31290352-339c-4293-9dc9-c06e798ce666,"Topic: formValidators
Section: Usage

`@mantine/form` package exports several functions that can be used in [validation rules object](https://mantine.dev/form/validation/#validation-with-rules-object).
Validation functions are tiny in size and provide basic validation, if you have complex validation requirements, use other types of [validation](https://mantine.dev/form/validation/).  
#### Example: validators  
```tsx
import { useForm, isNotEmpty, isEmail, isInRange, hasLength, matches } from '@mantine/form';
import { Button, Group, TextInput, NumberInput } from '@mantine/core';

function Demo() {
const form = useForm({
mode: 'uncontrolled',
initialValues: {
name: '',
job: '',
email: '',
favoriteColor: '',
age: 18,
},

validate: {
name: hasLength({ min: 2, max: 10 }, 'Name must be 2-10 characters long'),
job: isNotEmpty('Enter your current job'),
email: isEmail('Invalid email'),
favoriteColor: matches(/^#([0-9a-f]{3}){1,2}$/, 'Enter a valid hex color'),
age: isInRange({ min: 18, max: 99 }, 'You must be 18-99 years old to register'),
},
});

return (
<form onSubmit={form.onSubmit(() => {})}>
<TextInput
label=""Name""
placeholder=""Name""
withAsterisk
key={form.key('name')}
{...form.getInputProps('name')}
/>
<TextInput
label=""Your job""
placeholder=""Your job""
withAsterisk
mt=""md""
key={form.key('job')}
{...form.getInputProps('job')}
/>
<TextInput
label=""Your email""
placeholder=""Your email""
withAsterisk
mt=""md""
key={form.key('email')}
{...form.getInputProps('email')}
/>
<TextInput
label=""Your favorite color""
placeholder=""Your favorite color""
withAsterisk
mt=""md""
key={form.key('favoriteColor')}
{...form.getInputProps('favoriteColor')}
/>
<NumberInput
label=""Your age""
placeholder=""Your age""
withAsterisk
mt=""md""
key={form.key('age')}
{...form.getInputProps('age')}
/>

<Group justify=""flex-end"" mt=""md"">
<Button type=""submit"">Submit</Button>
</Group>
</form>
);
}
```",0
eval2_q016,How can I attach a custom validation rule to a single field using Mantine useForm?,hnsw_ef50_k15,50,11,0.288327167192457,acab8965-1bef-4db6-bf7a-762a7aa2edfc,"Topic: General
Section: What should I do instead?

If you are building a form that requires usage of Mantine inputs
with custom UI, you should validate form data after it has been
submitted. You can use [@mantine/form](https://mantine.dev/form/use-form) package
to perform form validation on submit.",0
eval2_q016,How can I attach a custom validation rule to a single field using Mantine useForm?,hnsw_ef50_k15,50,12,0.2897315566022646,d38670d1-871f-4579-bd89-f3aae45b0200,"Topic: formSchemaValidation
Section: joi

const listSchema = Joi.object({
list: Joi.array().items(
Joi.object({
name: Joi.string().min(2).messages({
'string.min': 'Name should have at least 2 letters',
'string.empty': 'Name should have at least 2 letters',
}),
})
),
});

const form = useForm({
mode: 'uncontrolled',
initialValues: {
list: [{ name: '' }],
},
validate: joiResolver(listSchema),
});

form.validate();
form.errors;
// -> {
//  'list.0.name': 'Name should have at least 2 letters',
// }
```",0
eval2_q016,How can I attach a custom validation rule to a single field using Mantine useForm?,hnsw_ef50_k15,50,13,0.2902397382666162,ccad2c10-70eb-43f9-8945-dce06214a128,"Topic: formSchemaValidation
Section: valibot

const listSchema = v.object({
list: v.array(
v.object({
name: v.pipe(
v.string(),
v.minLength(2, 'Name should have at least 2 letters')
),
})
),
});

const form = useForm({
initialValues: {
list: [{ name: '' }],
},
validate: valibotResolver(listSchema),
});

form.validate();
form.errors;
// -> {
//  'list.0.name': 'Name should have at least 2 letters',
// }
```  
With TypeScript:  
You can use the `InferInput` type from the `valibot` library to get the type of the form data.  
```tsx
import { valibotResolver } from 'mantine-form-valibot-resolver';
import * as v from 'valibot';
import { useForm } from '@mantine/form';

export const userSchema = v.object({
email: v.pipe(v.string(), v.email()),
});

type FormData = v.InferInput<typeof userSchema>;

const form = useForm<FormData>({
initialValues: {
email: '',
},
validate: valibotResolver(userSchema),
});
```",0
eval2_q016,How can I attach a custom validation rule to a single field using Mantine useForm?,hnsw_ef50_k15,50,14,0.2915307031323764,83e816a1-7511-4dbf-bc83-939bfb937acc,"Topic: formNested
Section: List values validation

```tsx
import { useForm } from '@mantine/form';

const form = useForm({
mode: 'uncontrolled',
initialValues: {
users: [
{ name: 'John', age: 12 },
{ name: '', age: 22 },
],
},

validate: {
users: {
name: (value) =>
value.length < 2
? 'Name should have at least 2 letters'
: null,
age: (value) =>
value < 18 ? 'User must be 18 or older' : null,
},
},
});

// Validate list item field
form.validateField('users.1.name');

// Or with all other fields
form.validate();
console.log(form.errors);
// {
//  'users.0.age': 'User must be 18 or older',
//  'users.1.name': 'Name should have at least 2 letters'
// }
```",0
eval2_q016,How can I attach a custom validation rule to a single field using Mantine useForm?,hnsw_ef50_k15,50,15,0.29223336893207796,b39582d1-5e54-4fcf-95fa-08dace7d9b06,"Topic: formValidation
Section: Validate fields on change

function Demo() {
const form = useForm({
mode: 'uncontrolled',
validateInputOnChange: [
'email',
'name',
// use FORM_INDEX to reference fields indices
`jobs.${FORM_INDEX}.title`,
],
initialValues: { name: '', email: '', age: 0, jobs: [{ title: '' }, { title: '' }] },

// functions will be used to validate values at corresponding key
validate: {
name: (value) => (value.length < 2 ? 'Name must have at least 2 letters' : null),
email: (value) => (/^\\S+@\\S+$/.test(value) ? null : 'Invalid email'),
age: (value) => (value < 18 ? 'You must be at least 18 to register' : null),
jobs: {
title: (value) => (value.length < 2 ? 'Job must have at least 2 letters' : null),
},
},
});

return (
<form onSubmit={form.onSubmit(console.log)}>
<TextInput
label=""Name""
placeholder=""Name""
key={form.key('name')}
{...form.getInputProps('name')}
/>
<TextInput
mt=""sm""
label=""Email""
placeholder=""Email""
key={form.key('email')}
{...form.getInputProps('email')}
/>
<NumberInput
mt=""sm""
label=""Age""
placeholder=""Age""
min={0}
max={99}
key={form.key('age')}
{...form.getInputProps('age')}
/>
<TextInput
mt=""sm""
label=""Job 1""
placeholder=""Job 1""
key={form.key('jobs.0.title')}
{...form.getInputProps('jobs.0.title')}
/>
<TextInput
mt=""sm""
label=""Job 2""
placeholder=""Job 2""
key={form.key('jobs.1.title')}
{...form.getInputProps('jobs.1.title')}
/>
<Button type=""submit"" mt=""sm"">
Submit
</Button>
</form>
);
}
```",0
eval2_q007,How can I validate that two fields match in Mantine useForm while showing the error only on the second field?,hnsw_ef50_k15,50,1,0.2215287751549041,213af0cf-d280-4a92-bc5f-511f3ab87875,"Topic: formValidation
Section: Validation based on other form values

You can get all form values as a second rule function argument to perform field validation based on other
form values. For example, you can validate that password confirmation is the same as password:  
#### Example: password  
```tsx
import { useForm } from '@mantine/form';
import { PasswordInput, Group, Button, Box } from '@mantine/core';

function Demo() {
const form = useForm({
mode: 'uncontrolled',
initialValues: {
password: 'secret',
confirmPassword: 'sevret',
},

validate: {
confirmPassword: (value, values) =>
value !== values.password ? 'Passwords did not match' : null,
},
});

return (
<Box maw={340} mx=""auto"">
<form onSubmit={form.onSubmit((values) => console.log(values))}>
<PasswordInput
label=""Password""
placeholder=""Password""
key={form.key('password')}
{...form.getInputProps('password')}
/>

<PasswordInput
mt=""sm""
label=""Confirm password""
placeholder=""Confirm password""
key={form.key('confirmPassword')}
{...form.getInputProps('confirmPassword')}
/>

<Group justify=""flex-end"" mt=""md"">
<Button type=""submit"">Submit</Button>
</Group>
</form>
</Box>
);
}
```",3
eval2_q007,How can I validate that two fields match in Mantine useForm while showing the error only on the second field?,hnsw_ef50_k15,50,2,0.22578098238892585,36b9836b-b8ba-43f6-abd3-72bb7dac671e,"Topic: formValidators
Section: matchesField

`matchesField` checks whether form value is the same as value in other form field.
Note that `matchesField` can only work with primitive values (arrays and objects cannot be compared).  
```tsx
import { matchesField, useForm } from '@mantine/form';

const form = useForm({
mode: 'uncontrolled',
initialValues: {
password: '',
confirmPassword: '',
},

validate: {
confirmPassword: matchesField(
'password',
'Passwords are not the same'
),
},
});
```",3
eval2_q007,How can I validate that two fields match in Mantine useForm while showing the error only on the second field?,hnsw_ef50_k15,50,3,0.27850795771250625,05495b1c-cc7d-473a-8045-394ce3bc78d2,"Topic: formValidation
Section: Function based validation

Another approach to handle validation is to provide a function to `validate`.
Function takes form values as single argument and should return object that contains
errors of corresponding fields. If field is valid or field validation is not required, you can either return null or simply omit it
from the validation results.  
#### Example: validateFunction  
```tsx
import { useForm } from '@mantine/form';
import { Box, TextInput, NumberInput, Button, Group } from '@mantine/core';

function Demo() {
const form = useForm<{ name: string; age: number | undefined }>({
mode: 'uncontrolled',
initialValues: { name: '', age: undefined },
validate: (values) => ({
name: values.name.length < 2 ? 'Too short name' : null,
age:
values.age === undefined
? 'Age is required'
: values.age < 18
? 'You must be at least 18'
: null,
}),
});

return (
<Box maw={340} mx=""auto"">
<form onSubmit={form.onSubmit((values) => console.log(values))}>
<TextInput
label=""Name""
placeholder=""Name""
key={form.key('name')}
{...form.getInputProps('name')}
/>
<NumberInput
mt=""sm""
label=""Age""
placeholder=""You age""
key={form.key('age')}
{...form.getInputProps('age')}
/>

<Group justify=""flex-end"" mt=""md"">
<Button type=""submit"">Submit</Button>
</Group>
</form>
</Box>
);
}
```",1
eval2_q007,How can I validate that two fields match in Mantine useForm while showing the error only on the second field?,hnsw_ef50_k15,50,4,0.2855029781668019,93fde8bc-8120-424f-9572-bbe679e8c4b4,"Topic: formValidation
Section: Validation with rules object

To validate form with rules object, provide an object of functions which take field value as an argument
and return error message (any React node) or null if field is valid:  
#### Example: rulesValidation  
```tsx
import { useForm } from '@mantine/form';
import { NumberInput, TextInput, Button } from '@mantine/core';

function Demo() {
const form = useForm({
mode: 'uncontrolled',
initialValues: { name: '', email: '', age: 0 },

// functions will be used to validate values at corresponding key
validate: {
name: (value) => (value.length < 2 ? 'Name must have at least 2 letters' : null),
email: (value) => (/^\\S+@\\S+$/.test(value) ? null : 'Invalid email'),
age: (value) => (value < 18 ? 'You must be at least 18 to register' : null),
},
});

return (
<form onSubmit={form.onSubmit(console.log)}>
<TextInput
label=""Name""
placeholder=""Name""
key={form.key('name')}
{...form.getInputProps('name')}
/>
<TextInput
mt=""sm""
label=""Email""
placeholder=""Email""
key={form.key('email')}
{...form.getInputProps('email')}
/>
<NumberInput
mt=""sm""
label=""Age""
placeholder=""Age""
min={0}
max={99}
key={form.key('age')}
{...form.getInputProps('age')}
/>
<Button type=""submit"" mt=""sm"">
Submit
</Button>
</form>
);
}
```",1
eval2_q007,How can I validate that two fields match in Mantine useForm while showing the error only on the second field?,hnsw_ef50_k15,50,5,0.2879412006128379,45b96f58-7516-4f33-92c9-d4f5999590ae,"Topic: use-form
Section: Validation

[Form validation guide](https://mantine.dev/form/validation/)  
```tsx
import { useForm } from '@mantine/form';

const form = useForm({
mode: 'uncontrolled',
initialValues: {
email: '',
user: {
firstName: '',
lastName: '',
},
},
validate: {
email: (value) => (value.length < 2 ? 'Invalid email' : null),
user: {
firstName: (value) =>
value.length < 2
? 'First name must have at least 2 letters'
: null,
},
},
});

// Validates all fields with specified `validate` function or schema, sets form.errors
form.validate();

// Validates single field at specified path, sets form.errors
form.validateField('user.firstName');

// Works the same way as form.validate but does not set form.errors
form.isValid();
form.isValid('user.firstName');
```",0
eval2_q007,How can I validate that two fields match in Mantine useForm while showing the error only on the second field?,hnsw_ef50_k15,50,6,0.28822031087224387,588a3214-bdca-4c09-8ed6-7dea20ee1506,"Topic: formValidators
Section: Optional error

Last argument of all validator functions below is optional. If error is not set, then fields with failed validation will
only have invalid styles without error message:  
#### Example: validatorsEmpty  
```tsx
import { useForm, isNotEmpty, isEmail, isInRange, hasLength, matches } from '@mantine/form';
import { Button, Group, TextInput, NumberInput } from '@mantine/core';

function Demo() {
const form = useForm({
mode: 'uncontrolled',
initialValues: {
name: '',
job: '',
email: '',
favoriteColor: '',
age: 18,
},

validate: {
name: hasLength({ min: 2, max: 10 }),
job: isNotEmpty(),
email: isEmail(),
favoriteColor: matches(/^#([0-9a-f]{3}){1,2}$/),
age: isInRange({ min: 18, max: 99 }),
},
});

return (
<form onSubmit={form.onSubmit(() => {})}>
<TextInput
label=""Name""
placeholder=""Name""
withAsterisk
key={form.key('name')}
{...form.getInputProps('name')}
/>
<TextInput
label=""Your job""
placeholder=""Your job""
withAsterisk
mt=""md""
key={form.key('job')}
{...form.getInputProps('job')}
/>
<TextInput
label=""Your email""
placeholder=""Your email""
withAsterisk
mt=""md""
key={form.key('email')}
{...form.getInputProps('email')}
/>
<TextInput
label=""Your favorite color""
placeholder=""Your favorite color""
withAsterisk
mt=""md""
key={form.key('favoriteColor')}
{...form.getInputProps('favoriteColor')}
/>
<NumberInput
label=""Your age""
placeholder=""Your age""
withAsterisk
mt=""md""
key={form.key('age')}
{...form.getInputProps('age')}
/>

<Group justify=""flex-end"" mt=""md"">
<Button type=""submit"">Submit</Button>
</Group>
</form>
);
}
```",0
eval2_q007,How can I validate that two fields match in Mantine useForm while showing the error only on the second field?,hnsw_ef50_k15,50,7,0.28827554390213583,36a1e3cb-b9a8-45a9-aa31-49dd3a89f945,"Topic: formValidation
Section: Focus first invalid field

The second argument of the `form.onSubmit` function is a callback function that is called
with the [errors object](https://mantine.dev/form/errors) when form validation fails.
You can use this callback to focus the first invalid field or perform any other action.  
To get the DOM node of any input, use `form.getInputNode('path-to-field')`. Note that
in order for this feature to work, you need to spread `form.getInputProps('path-to-field')` to
the input element.  
#### Example: focusError  
```tsx
import { Button, Group, TextInput } from '@mantine/core';
import { isEmail, isNotEmpty, useForm } from '@mantine/form';

function Demo() {
const form = useForm({
mode: 'uncontrolled',
name: 'register-form',
initialValues: {
name: '',
email: '',
},

validate: {
name: isNotEmpty('Name is required'),
email: isEmail('Invalid email'),
},
});

return (
<form
onSubmit={form.onSubmit(
(values) => console.log(values),
(errors) => {
const firstErrorPath = Object.keys(errors)[0];
form.getInputNode(firstErrorPath)?.focus();
}
)}
>
<TextInput
withAsterisk
label=""Your name""
placeholder=""Your name""
key={form.key('name')}
{...form.getInputProps('name')}
/>

<TextInput
withAsterisk
label=""Your email""
placeholder=""your@email.com""
mt=""md""
key={form.key('email')}
{...form.getInputProps('email')}
/>

<Group justify=""flex-end"" mt=""md"">
<Button type=""submit"">Submit</Button>
</Group>
</form>
);
}
```",0
eval2_q007,How can I validate that two fields match in Mantine useForm while showing the error only on the second field?,hnsw_ef50_k15,50,8,0.2895864600904354,f8cde119-86bf-4a33-b8de-9e9eeae6f791,"Topic: formNested
Section: Nested object values validation

```tsx
import { useForm } from '@mantine/form';

const form = useForm({
mode: 'uncontrolled',
initialValues: {
user: {
name: '',
occupation: '',
},
},

validate: {
user: {
name: (value) =>
value.length < 2 ? 'Name is too short' : null,
occupation: (value) =>
value.length < 2 ? 'Occupation is too short' : null,
},
},
});

form.validate();
form.errors; // -> { 'user.name': 'Name is too short', 'user.occupation': 'Occupation is too short' }
```",0
eval2_q007,How can I validate that two fields match in Mantine useForm while showing the error only on the second field?,hnsw_ef50_k15,50,9,0.2911767703963497,6e113cf0-ae4a-475b-bd0a-a2d5720a4e97,"Topic: formValidation
Section: formRootRule

{fields}

{form.errors.employees && (
<Text c=""red"" size=""sm"" mt=""sm"">
{form.errors.employees}
</Text>
)}

<Group justify=""space-between"" mt=""md"">
<Button
variant=""default""
onClick={() => {
form.insertListItem('employees', { name: '', active: false, key: randomId() });
form.clearFieldError('employees');
}}
>
Add employee
</Button>
<Button type=""submit"">Submit</Button>
</Group>
</form>
);
}
```  
Another example is to validate an object fields combination:  
#### Example: rootRuleObject  
```tsx
import { Button, Text, TextInput } from '@mantine/core';
import { formRootRule, isNotEmpty, useForm } from '@mantine/form';

function Demo() {
const form = useForm({
mode: 'uncontrolled',
initialValues: {
user: {
firstName: '',
lastName: '',
},
},

validate: {
user: {
[formRootRule]: (value) =>
value.firstName.trim().length > 0 && value.firstName === value.lastName
? 'First name and last name cannot be the same'
: null,
firstName: isNotEmpty('First name is required'),
lastName: isNotEmpty('Last name is required'),
},
},
});

return (
<form onSubmit={form.onSubmit(() => {})}>
<TextInput
label=""First name""
placeholder=""First name""
{...form.getInputProps('user.firstName')}
/>
<TextInput
label=""Last name""
placeholder=""Last name""
mt=""md""
{...form.getInputProps('user.lastName')}
/>
{form.errors.user && (
<Text c=""red"" mt={5} fz=""sm"">
{form.errors.user}
</Text>
)}
<Button type=""submit"" mt=""lg"">
Submit
</Button>
</form>
);
}
```",0
eval2_q007,How can I validate that two fields match in Mantine useForm while showing the error only on the second field?,hnsw_ef50_k15,50,10,0.292989621153928,0a02e364-6440-436f-bcbe-4c87da719122,"Topic: formValidators
Section: matches

`matches` checks whether form value matches given regexp. If form value is not a string, validation will be failed.  
```tsx
import { matches, useForm } from '@mantine/form';

const form = useForm({
mode: 'uncontrolled',
initialValues: {
color: '',
},

validate: {
color: matches(/^#([0-9a-f]{3}){1,2}$/, 'Invalid color'),
},
});
```",0
eval2_q007,How can I validate that two fields match in Mantine useForm while showing the error only on the second field?,hnsw_ef50_k15,50,11,0.29542122314459274,5ca93ca5-b393-4bb4-9bc8-a65aab381c49,"Topic: formValidation
Section: Validation in onSubmit handler

`form.onSubmit` accepts two arguments: first argument is `handleSubmit` function that will be called with form values, when validation
was completed without errors, second argument is `handleErrors` function, it is called with errors object when validation was completed with errors.  
You can use `handleErrors` function to perform certain actions when user tries to submit form without values,
for example, you can show a notification:  
#### Example: onSubmitErrors  
```tsx
import { useForm } from '@mantine/form';
import { TextInput, Button } from '@mantine/core';
import { notifications } from '@mantine/notifications';

function Demo() {
const form = useForm({
mode: 'uncontrolled',
initialValues: { name: '', email: '' },
validate: {
name: (value) => (value.length < 2 ? 'Name must have at least 2 letters' : null),
email: (value) => (/^\\S+@\\S+$/.test(value) ? null : 'Invalid email'),
},
});

const handleError = (errors: typeof form.errors) => {
if (errors.name) {
notifications.show({ message: 'Please fill name field', color: 'red' });
} else if (errors.email) {
notifications.show({ message: 'Please provide a valid email', color: 'red' });
}
};

return (
<form onSubmit={form.onSubmit(console.log, handleError)}>
<TextInput
label=""Name""
placeholder=""Name""
key={form.key('name')}
{...form.getInputProps('name')}
/>
<TextInput
mt=""sm""
label=""Email""
placeholder=""Email""
key={form.key('email')}
{...form.getInputProps('email')}
/>
<Button type=""submit"" mt=""sm"">
Submit
</Button>
</form>
);
}
```",0
eval2_q007,How can I validate that two fields match in Mantine useForm while showing the error only on the second field?,hnsw_ef50_k15,50,12,0.2955553538748241,b39582d1-5e54-4fcf-95fa-08dace7d9b06,"Topic: formValidation
Section: Validate fields on change

function Demo() {
const form = useForm({
mode: 'uncontrolled',
validateInputOnChange: [
'email',
'name',
// use FORM_INDEX to reference fields indices
`jobs.${FORM_INDEX}.title`,
],
initialValues: { name: '', email: '', age: 0, jobs: [{ title: '' }, { title: '' }] },

// functions will be used to validate values at corresponding key
validate: {
name: (value) => (value.length < 2 ? 'Name must have at least 2 letters' : null),
email: (value) => (/^\\S+@\\S+$/.test(value) ? null : 'Invalid email'),
age: (value) => (value < 18 ? 'You must be at least 18 to register' : null),
jobs: {
title: (value) => (value.length < 2 ? 'Job must have at least 2 letters' : null),
},
},
});

return (
<form onSubmit={form.onSubmit(console.log)}>
<TextInput
label=""Name""
placeholder=""Name""
key={form.key('name')}
{...form.getInputProps('name')}
/>
<TextInput
mt=""sm""
label=""Email""
placeholder=""Email""
key={form.key('email')}
{...form.getInputProps('email')}
/>
<NumberInput
mt=""sm""
label=""Age""
placeholder=""Age""
min={0}
max={99}
key={form.key('age')}
{...form.getInputProps('age')}
/>
<TextInput
mt=""sm""
label=""Job 1""
placeholder=""Job 1""
key={form.key('jobs.0.title')}
{...form.getInputProps('jobs.0.title')}
/>
<TextInput
mt=""sm""
label=""Job 2""
placeholder=""Job 2""
key={form.key('jobs.1.title')}
{...form.getInputProps('jobs.1.title')}
/>
<Button type=""submit"" mt=""sm"">
Submit
</Button>
</form>
);
}
```",0
eval2_q007,How can I validate that two fields match in Mantine useForm while showing the error only on the second field?,hnsw_ef50_k15,50,13,0.2998117857704725,ee71242e-e01d-4035-a881-37208054e10c,"Topic: General
Section: Focus first input with error on form submit

`form.onSubmit` handler accepts two functions: the first function is called
with valid form values when validation passes, the second function is called
with form errors when validation fails. You can use the second function and
`form.getInputNode` to focus the first input with error:  
#### Example: FocusFirstInputWithError  
```tsx
function Demo() {
const form = useForm({
mode: 'uncontrolled',
initialValues: {
name: '',
email: '',
},

validate: {
name: isNotEmpty('Name is required'),
email: isEmail('Invalid email'),
},
});

return (
<form
onSubmit={form.onSubmit(
() => {},
(errors) => {
const firstErrorPath = Object.keys(errors)[0];
form.getInputNode(firstErrorPath)?.focus();
}
)}
>
<TextInput
withAsterisk
label=""Your name""
placeholder=""Your name""
key={form.key('name')}
{...form.getInputProps('name')}
/>

<TextInput
withAsterisk
label=""Your email""
placeholder=""your@email.com""
mt=""md""
key={form.key('email')}
{...form.getInputProps('email')}
/>

<Group justify=""flex-end"" mt=""md"">
<Button type=""submit"">Submit</Button>
</Group>
</form>
);
}
```",0
eval2_q007,How can I validate that two fields match in Mantine useForm while showing the error only on the second field?,hnsw_ef50_k15,50,14,0.3010755724045595,acab8965-1bef-4db6-bf7a-762a7aa2edfc,"Topic: General
Section: What should I do instead?

If you are building a form that requires usage of Mantine inputs
with custom UI, you should validate form data after it has been
submitted. You can use [@mantine/form](https://mantine.dev/form/use-form) package
to perform form validation on submit.",0
eval2_q007,How can I validate that two fields match in Mantine useForm while showing the error only on the second field?,hnsw_ef50_k15,50,15,0.30194325945603373,bb527f9c-ce6c-429e-abd3-8b6040757628,"Topic: formValidation
Section: Rule function arguments

Each form rule receives the following arguments:  
* `value` – value of field
* `values` – all form values
* `path` – field path, for example `user.email` or `cart.0.price`  
`path` argument can be used to get information about field location relative to other fields,
for example you can get index of array element:  
```tsx
import { useForm } from '@mantine/form';

const form = useForm({
mode: 'uncontrolled',
initialValues: { a: [{ b: 1 }, { b: 2 }] },
validate: {
a: {
b: (value, values, path) => (path === 'a.0.b' ? 'error' : null),
},
},
});
```",0
eval2_q009,How do I set up MantineProvider in Next.js App Router (app/layout.tsx)?,hnsw_ef50_k15,50,1,0.21440666072582848,faddea91-657e-490b-925a-6eaef4edc8ed,"Topic: NextJs
Section: Setup with app router

Add [MantineProvider](https://mantine.dev/theming/mantine-provider), [ColorSchemeScript](https://mantine.dev/theming/color-schemes)
and styles imports to the `app/layout.tsx` file:  
```tsx
// Import styles of packages that you've installed.
// All packages except `@mantine/hooks` require styles imports
import '@mantine/core/styles.css';

import { ColorSchemeScript, MantineProvider, mantineHtmlProps } from '@mantine/core';

export const metadata = {
title: 'My Mantine app',
description: 'I have followed setup instructions carefully',
};

export default function RootLayout({
children,
}: {
children: React.ReactNode;
}) {
return (
<html lang=""en"" {...mantineHtmlProps}>
<head>
<ColorSchemeScript />
</head>
<body>
<MantineProvider>{children}</MantineProvider>
</body>
</html>
);
}
```  
All set! Start development server:  
```bash
npm run dev
```",3
eval2_q009,How do I set up MantineProvider in Next.js App Router (app/layout.tsx)?,hnsw_ef50_k15,50,2,0.22499433353509735,b864cd09-5dac-4b73-bb20-752863361e3e,"Topic: Emotion
Section: Usage with Next.js app router

useServerInsertedHTML(() => {
const names = flush();
if (names.length === 0) return null;
let styles = '';
for (const name of names) {
styles += cache.inserted[name];
}
return (
<style
data-emotion={`${cache.key} ${names.join(' ')}`}
dangerouslySetInnerHTML={{
__html: styles,
}}
/>
);
});

return <CacheProvider value={cache}>{children}</CacheProvider>;
}
```  
Add `RootStyleRegistry`, `MantineEmotionProvider` and `emotionTransform` to `app/layout.tsx`.
It should look something like this:  
```tsx
import '@mantine/core/styles.css';

import { ColorSchemeScript, MantineProvider } from '@mantine/core';
import {
emotionTransform,
MantineEmotionProvider,
} from '@mantine/emotion';
import { RootStyleRegistry } from './EmotionRootStyleRegistry';

export const metadata = {
title: 'Mantine Next.js template',
description: 'I am using Mantine with Next.js!',
};

export default function RootLayout({ children }: { children: any }) {
return (
<html lang=""en"">
<head>
<ColorSchemeScript />
<link rel=""shortcut icon"" href=""/favicon.svg"" />
<meta
name=""viewport""
content=""minimum-scale=1, initial-scale=1, width=device-width, user-scalable=no""
/>
</head>
<body>
<RootStyleRegistry>
<MantineEmotionProvider>
<MantineProvider stylesTransform={emotionTransform}>
{children}
</MantineProvider>
</MantineEmotionProvider>
</RootStyleRegistry>
</body>
</html>
);
}
```  
Done! You can now use `sx`, `styles` props and `createStyles` in your application.
Note that `'use client'` is required in most components that use `sx`, `styles` or `createStyles`:  
```tsx
'use client';

import { Box } from '@mantine/core';

export default function HomePage() {
return (
<Box
sx={(theme, u) => ({
padding: 40,

[u.light]: {
backgroundColor: theme.colors.blue[0],
color: theme.colors.blue[9],

'&:hover': {
backgroundColor: theme.colors.blue[1],
},
},
})}
>
Box with emotion sx prop
</Box>
);
}
```",2
eval2_q009,How do I set up MantineProvider in Next.js App Router (app/layout.tsx)?,hnsw_ef50_k15,50,3,0.26135723275480516,7f9b0b31-21cd-4942-910a-30d4f92a1d05,"Topic: ReactRouter
Section: Setup

Add styles imports, [MantineProvider](https://mantine.dev/theming/mantine-provider/) and [ColorSchemeScript](https://mantine.dev/theming/color-schemes) to `app/root.tsx`:  
```tsx
// Import styles of packages that you've installed.
// All packages except `@mantine/hooks` require styles imports
import '@mantine/core/styles.css';

import {
Links,
Meta,
Outlet,
Scripts,
ScrollRestoration,
} from ""react-router"";
import { ColorSchemeScript, MantineProvider, mantineHtmlProps } from '@mantine/core';

export function Layout({ children }: { children: React.ReactNode }) {
return (
<html lang=""en"" {...mantineHtmlProps}>
<head>
<meta charSet=""utf-8"" />
<meta name=""viewport"" content=""width=device-width, initial-scale=1"" />
<ColorSchemeScript />
<Meta />
<Links />
</head>
<body>
<MantineProvider>{children}</MantineProvider>
<ScrollRestoration />
<Scripts />
</body>
</html>
);
}

// ... other app/root.tsx content
```  
All set! Start development server:  
```bash
npm run dev
```",0
eval2_q009,How do I set up MantineProvider in Next.js App Router (app/layout.tsx)?,hnsw_ef50_k15,50,4,0.2616702959834659,7668f61e-a768-45f5-8d4d-5a475b507e6b,"Topic: Emotion
Section: Usage with Next.js app router

[View example repository with full setup](https://github.com/mantinedev/next-app-min-template/tree/emotion)  
Install dependencies:  
```bash
yarn add @mantine/emotion @emotion/react @emotion/cache @emotion/serialize @emotion/utils @emotion/server
```  
```bash
npm install @mantine/emotion @emotion/react @emotion/cache @emotion/serialize @emotion/utils @emotion/server
```  
Create `app/emotion.d.ts` file with the following content:  
```tsx
import '@mantine/core';

import type { EmotionStyles, EmotionSx } from '@mantine/emotion';

declare module '@mantine/core' {
export interface BoxProps {
sx?: EmotionSx;
styles?: EmotionStyles;
}
}
```  
Create `app/EmotionRootStyleRegistry.tsx` file with the following content:  
```tsx
'use client';

import { useState } from 'react';
import { useServerInsertedHTML } from 'next/navigation';
import createCache from '@emotion/cache';
import { CacheProvider } from '@emotion/react';

export function RootStyleRegistry({
children,
}: {
children: React.ReactNode;
}) {
const [{ cache, flush }] = useState(() => {
const cache = createCache({ key: 'my' });
cache.compat = true;
const prevInsert = cache.insert;
let inserted: string[] = [];
cache.insert = (...args) => {
const serialized = args[1];
if (cache.inserted[serialized.name] === undefined) {
inserted.push(serialized.name);
}
return prevInsert(...args);
};
const flush = () => {
const prevInserted = inserted;
inserted = [];
return prevInserted;
};
return { cache, flush };
});

useServerInsertedHTML(() => {
const names = flush();
if (names.length === 0) return null;
let styles = '';
for (const name of names) {
styles += cache.inserted[name];
}
return (
<style
data-emotion={`${cache.key} ${names.join(' ')}`}
dangerouslySetInnerHTML={{
__html: styles,
}}
/>
);
});",1
eval2_q009,How do I set up MantineProvider in Next.js App Router (app/layout.tsx)?,hnsw_ef50_k15,50,5,0.26245126996087387,dbc0e3de-97a3-4511-87b1-87316f20f1f4,"Topic: NextJs
Section: Setup with pages router

Add styles imports and [MantineProvider](https://mantine.dev/theming/mantine-provider) to the `pages/_app.tsx` file:  
```tsx
// Import styles of packages that you've installed.
// All packages except `@mantine/hooks` require styles imports
import '@mantine/core/styles.css';

import type { AppProps } from 'next/app';
import { createTheme, MantineProvider } from '@mantine/core';

const theme = createTheme({
/** Put your mantine theme override here */
});

export default function App({ Component, pageProps }: AppProps) {
return (
<MantineProvider theme={theme}>
<Component {...pageProps} />
</MantineProvider>
);
}
```  
Create `pages/_document.tsx` file with [ColorSchemeScript](https://mantine.dev/theming/color-schemes) component.
Note that it is required even if you use only one color scheme in your application.  
```tsx
import { Head, Html, Main, NextScript } from 'next/document';
import { ColorSchemeScript, mantineHtmlProps } from '@mantine/core';

export default function Document() {
return (
<Html lang=""en"" {...mantineHtmlProps}>
<Head>
<ColorSchemeScript defaultColorScheme=""auto"" />
</Head>
<body>
<Main />
<NextScript />
</body>
</Html>
);
}
```  
All set! Start development server:  
```bash
npm run dev
```",0
eval2_q009,How do I set up MantineProvider in Next.js App Router (app/layout.tsx)?,hnsw_ef50_k15,50,6,0.26691514503726044,5e8f4d42-1b21-4a17-b4f5-1cbae5f61d28,"Topic: Emotion
Section: Usage with Next.js pages router

import Head from 'next/head';
import { MantineProvider } from '@mantine/core';
import {
emotionTransform,
MantineEmotionProvider,
} from '@mantine/emotion';
import { emotionCache } from '../emotion/cache';

export default function App({ Component, pageProps }: any) {
return (
<MantineEmotionProvider cache={emotionCache}>
<MantineProvider stylesTransform={emotionTransform}>
<Head>
<title>Mantine Template</title>
<meta
name=""viewport""
content=""minimum-scale=1, initial-scale=1, width=device-width, user-scalable=no""
/>
<link rel=""shortcut icon"" href=""/favicon.svg"" />
</Head>
<Component {...pageProps} />
</MantineProvider>
</MantineEmotionProvider>
);
}
```  
Done! You can now use `sx`, `styles` props and `createStyles` in your application:  
```tsx
import { Box } from '@mantine/core';

function Demo() {
return (
<Box
sx={(theme, u) => ({
padding: 40,

[u.light]: {
backgroundColor: theme.colors.blue[0],
color: theme.colors.blue[9],

'&:hover': {
backgroundColor: theme.colors.blue[1],
},
},
})}
>
Box with emotion sx prop
</Box>
);
}
```",1
eval2_q009,How do I set up MantineProvider in Next.js App Router (app/layout.tsx)?,hnsw_ef50_k15,50,7,0.26986088284763454,cf893652-b60b-4819-80f8-4d8b9741f309,"Topic: MantineProvider
Section: Usage

```tsx
import { createTheme, MantineProvider } from '@mantine/core';

const theme = createTheme({
/** Your theme override here */
});

function Demo() {
return (
<MantineProvider theme={theme}>
{/* Your app here */}
</MantineProvider>
);
}
```",1
eval2_q009,How do I set up MantineProvider in Next.js App Router (app/layout.tsx)?,hnsw_ef50_k15,50,8,0.27272378853337964,c85a4519-723a-4ce9-afeb-c2c1fbf269c7,"Topic: NextJs
Section: app + pages router together

If you use both app and pages router in one application, you need to setup both `pages/_app.tsx`
and `app/layout.tsx` files as described above.",0
eval2_q009,How do I set up MantineProvider in Next.js App Router (app/layout.tsx)?,hnsw_ef50_k15,50,9,0.27903579733108574,59461b79-298f-4109-87b6-f222a2edbc2b,"Topic: GettingStarted
Section: Get started without framework

const theme = createTheme({
/** Put your mantine theme override here */
});

function Demo() {
return (
<MantineProvider theme={theme}>
{/* Your app here */}
</MantineProvider>
);
}
```  
If your application has server side rendering, add [ColorSchemeScript](https://mantine.dev/theming/color-schemes)
to the `<head />` of your application and spread `mantineHtmlProps` on the `<html />` element
to [avoid seeing a hydration warning](https://help.mantine.dev/q/color-scheme-hydration-warning):  
```tsx
import { ColorSchemeScript, mantineHtmlProps } from '@mantine/core';

function Demo() {
return (
<html lang=""en"" {...mantineHtmlProps}>
<head>
<meta charSet=""UTF-8"" />
<meta
name=""viewport""
content=""width=device-width, initial-scale=1.0""
/>
<title>My awesome app</title>

<ColorSchemeScript />
</head>
<body>{/* Your app here */}</body>
</html>
);
}
```  
All set! You can now use Mantine components in your application.",1
eval2_q009,How do I set up MantineProvider in Next.js App Router (app/layout.tsx)?,hnsw_ef50_k15,50,10,0.27998630341377306,5b0dde77-a979-4e7a-9930-894cdd74db1a,"Topic: General
Section: How to fix hydration warning?

To fix the hydration warning, spread `mantineHtmlProps` on the `<html />` element:  
```tsx
// app/layout.tsx
import { ColorSchemeScript, MantineProvider, mantineHtmlProps } from '@mantine/core';

export default function RootLayout({ children }: { children: any }) {
return (
<html lang=""en"" {...mantineHtmlProps}>
<head>
<ColorSchemeScript />
<link rel=""shortcut icon"" href=""/favicon.svg"" />
<meta
name=""viewport""
content=""minimum-scale=1, initial-scale=1, width=device-width, user-scalable=no""
/>
</head>
<body>
<MantineProvider>{children}</MantineProvider>
</body>
</html>
);
}
```",0
eval2_q009,How do I set up MantineProvider in Next.js App Router (app/layout.tsx)?,hnsw_ef50_k15,50,11,0.2908195019588563,b79aa873-af61-49bd-b020-464ceb8cc4ff,"Topic: Modals manager
Section: Setup ModalsProvider

Wrap your app with `ModalsProvider` component:  
```tsx
import { MantineProvider } from '@mantine/core';
import { ModalsProvider } from '@mantine/modals';

function Demo() {
return (
<MantineProvider>
<ModalsProvider>{/* Your app here */}</ModalsProvider>
</MantineProvider>
);
}
```",0
eval2_q009,How do I set up MantineProvider in Next.js App Router (app/layout.tsx)?,hnsw_ef50_k15,50,12,0.29172914497749125,ddf687f1-ebf1-408d-bd5b-b38a466718ef,"Topic: MantineProvider
Section: Overview

# MantineProvider  
`MantineProvider` provides a [theme object](https://mantine.dev/theming/theme-object) context value, manages color scheme
changes and injects [CSS variables](https://mantine.dev/styles/css-variables/). It must be rendered at the root of your
application and should be used only once.",0
eval2_q009,How do I set up MantineProvider in Next.js App Router (app/layout.tsx)?,hnsw_ef50_k15,50,13,0.2935313112620195,a1850dc9-9a86-45d3-a28b-e67f7884eb51,"Topic: Redwood
Section: Setup

Add styles imports, [MantineProvider](https://mantine.dev/theming/mantine-provider) and [ColorSchemeScript](https://mantine.dev/theming/color-schemes)
to `web/src/App.tsx` file:  
```tsx
// Import styles of packages that you've installed.
// All packages except `@mantine/hooks` require styles imports
import '@mantine/core/styles.css';

import { FatalErrorBoundary, RedwoodProvider } from '@redwoodjs/web';
import { RedwoodApolloProvider } from '@redwoodjs/web/apollo';
import FatalErrorPage from 'src/pages/FatalErrorPage';
import Routes from 'src/Routes';
import { ColorSchemeScript, MantineProvider } from '@mantine/core';

const App = () => (
<FatalErrorBoundary page={FatalErrorPage}>
<RedwoodProvider titleTemplate=""%PageTitle | %AppTitle"">
<ColorSchemeScript />
<MantineProvider>
<RedwoodApolloProvider>
<Routes />
</RedwoodApolloProvider>
</MantineProvider>
</RedwoodProvider>
</FatalErrorBoundary>
);

export default App;
```  
All set! Start development server:  
```bash
yarn rw dev
```",0
eval2_q009,How do I set up MantineProvider in Next.js App Router (app/layout.tsx)?,hnsw_ef50_k15,50,14,0.2936322013880054,e26d514a-e530-4c0a-b3d4-6b8cff312d41,"Topic: Vite
Section: Setup

Add styles imports and [MantineProvider](https://mantine.dev/theming/mantine-provider/) to your application root component (usually `App.tsx`):  
```tsx
// Import styles of packages that you've installed.
// All packages except `@mantine/hooks` require styles imports
import '@mantine/core/styles.css';

import { MantineProvider } from '@mantine/core';

export default function App() {
return <MantineProvider>{/* Your app here */}</MantineProvider>;
}
```  
All set! Start development server:  
```bash
npm run dev
```",0
eval2_q009,How do I set up MantineProvider in Next.js App Router (app/layout.tsx)?,hnsw_ef50_k15,50,15,0.2941782199485974,afb14cb8-5e0c-407a-a5a1-bef5b99bc412,"Topic: NextJs
Section: app router tree shaking

To enable tree shaking with app router, enable experimental `optimizePackageImports` feature in
your `next.config.mjs`:  
```tsx
export default {
// ...other configuration
experimental: {
optimizePackageImports: ['@mantine/core', '@mantine/hooks'],
},
};
```",0
eval2_q010,"In Mantine, which styling approach is most performant at runtime, and why?",hnsw_ef50_k15,50,1,0.22460061563619216,92103f00-abff-4c22-84d3-15f283b09547,"Topic: StylesPerformance
Section: CSS modules

[CSS modules](https://mantine.dev/styles/css-modules) is the most performant way to apply styles –
this approach generates static CSS that is never re-evaluated. 99% of Mantine components
styles are generated with CSS modules – components are optimized out of the box.  
In most cases, it is recommended to use [CSS modules](https://mantine.dev/styles/css-modules) to style your components as well.
You can apply styles to HTML elements with `className` prop and to Mantine components with `className`,
`classNames` props.  
Applying styles with `className`:  
#### Example: className  
```tsx
import { Box } from '@mantine/core';
import classes from './Demo.module.css';

function Demo() {
return (
<Box className={classes.box}>
Box component with <span className={classes.highlight}>some styles</span>
</Box>
);
}
```  
Applying styles with `classNames` (see [Styles API guide](https://mantine.dev/styles/styles-api) to learn more):  
#### Example: classNames  
```tsx
import { useState } from 'react';
import { TextInput } from '@mantine/core';
import classes from './Demo.module.css';

function Demo() {
const [value, setValue] = useState('');
const [focused, setFocused] = useState(false);
const floating = focused || value.length > 0 || undefined;

return (
<TextInput
label=""Floating label input""
labelProps={{ 'data-floating': floating }}
classNames={{
root: classes.root,
input: classes.input,
label: classes.label,
}}
onFocus={() => setFocused(true)}
onBlur={() => setFocused(false)}
value={value}
onChange={(event) => setValue(event.currentTarget.value)}
/>
);
}
```",3
eval2_q010,"In Mantine, which styling approach is most performant at runtime, and why?",hnsw_ef50_k15,50,2,0.230446298516919,da53ec77-756f-4ff5-995b-7724d6246c78,"Topic: StylesPerformance
Section: Responsive style props

Responsive [style props](https://mantine.dev/styles/style-props) have worse performance than regular style props
because they require injecting `<style />` tag next to the component. It is fine to use responsive
style props to apply styles to several components, but it is not recommended to use
them in large lists of components, for example, if you have 1000 inputs with responsive margins,
it is better to refactor to use `classNames` prop:  
```tsx
import { TextInput } from '@mantine/core';

// Ok, style props are used to apply margin-top property to several components
function StyleProps() {
return (
<>
<TextInput label=""Input 1"" />
<TextInput label=""Input 2"" mt={{ base: 10, md: 20 }} />
<TextInput label=""Input 3"" mt={{ base: 10, md: 20 }} />
</>
);
}

// Worse, 1000 separate `<style />` tags will be generated
// Better to refactor to use className prop
function StylePropsArray() {
const inputs = Array(1000)
.fill(0)
.map((_, index) => (
<TextInput
key={index}
label={`Input ${index}`}
mt={{ base: 10, md: 20 }}
/>
));

return <>{inputs}</>;
}
```",1
eval2_q010,"In Mantine, which styling approach is most performant at runtime, and why?",hnsw_ef50_k15,50,3,0.23774147090755715,b1036083-7395-4b11-b5ed-f0b283ad1400,"Topic: StylesPerformance
Section: Overview

# Styles performance",0
eval2_q010,"In Mantine, which styling approach is most performant at runtime, and why?",hnsw_ef50_k15,50,4,0.2397539813886288,1063db3a-1656-4992-8aa1-0160e885021f,"Topic: StylesPerformance
Section: Style props

[Style props](https://mantine.dev/styles/style-props) transform component props into inline styles. Style props have
the same caveats as inline styles, it is not recommended to use them as the primary means of styling
your components. Usually, style props are used to apply 1–3 styles to a component – using them
this way does not impact performance.",0
eval2_q010,"In Mantine, which styling approach is most performant at runtime, and why?",hnsw_ef50_k15,50,5,0.24133940836105183,765daffa-892e-42b6-b4b5-d62d396a12a3,"Topic: StylesPerformance
Section: Inline styles

Inline styles (`style` and `styles` props) are less performant than CSS modules, but still
performant enough to be used in most cases if it is your preferred way of styling in your project.  
Inline styles caveats:  
* Styles are not reused between components, each component will generate its own styles, for example,
if you have 100 buttons with the same styles, CSS modules will generate 1 class for all of them,
inline styles will generate 100 `style` attributes
* If inline styles are overused, it can increase bundle size and output HTML size
* *Not performance related*: inline styles have higher specificity than CSS modules, so if you want
to override inline styles you will have to use `!important` or use another inline styles  
Example of inline styles:  
#### Example: styles  
```tsx
import { Button } from '@mantine/core';

function Demo() {
const gradient =
'linear-gradient(45deg, var(--mantine-color-pink-filled) 0%, var(--mantine-color-orange-filled) 50%, var(--mantine-color-yellow-filled) 100%)';

return (
<Button
radius=""md""
styles={{
root: {
padding: 2,
border: 0,
backgroundImage: gradient,
},

inner: {
background: 'var(--mantine-color-body)',
color: 'var(--mantine-color-text)',
borderRadius: 'calc(var(--button-radius) - 2px)',
paddingLeft: 'var(--mantine-spacing-md)',
paddingRight: 'var(--mantine-spacing-md)',
},

label: {
backgroundImage: gradient,
WebkitBackgroundClip: 'text',
WebkitTextFillColor: 'transparent',
},
}}
>
Gradient button
</Button>
);
}
```",1
eval2_q010,"In Mantine, which styling approach is most performant at runtime, and why?",hnsw_ef50_k15,50,6,0.25236341852606003,628aaa38-aa39-414a-9762-dedbec675769,"Topic: StylesOverview
Section: CSS modules

[CSS modules](https://mantine.dev/styles/css-modules/) is the recommended way of applying most of the styles to Mantine components.
CSS modules are the most performant and flexible way of styling components.  
```scss
// Demo.module.css

.root {
padding-right: 100px;

&[data-collapsed] {
padding-right: 40px;

& .control {
max-width: 200px;
}
}
}

.control {
background-color: var(--mantine-color-blue-1);
color: var(--mantine-color-blue-filled);
padding: var(--mantine-spacing-xl);
margin-left: 40px;

@media (max-width: $mantine-breakpoint-sm) {
margin-left: 0;
margin-top: var(--mantine-spacing-md);
}

@mixin hover {
background-color: light-dark(
var(--mantine-color-blue-1),
var(--mantine-color-blue-9)
);
}
}
```  
```tsx
// Demo.tsx
import classes from './Demo.module.css';

function Demo({ collapsed }: { collapsed: boolean }) {
return (
<div
className={classes.root}
data-collapsed={collapsed || undefined}
>
<button type=""button"" className={classes.control}>
Control
</button>
</div>
);
}
```",3
eval2_q010,"In Mantine, which styling approach is most performant at runtime, and why?",hnsw_ef50_k15,50,7,0.2535028173614835,1320042c-57af-4049-b850-09c729953813,"Topic: General
Section: Why nested inline styles are not supported?

Mantine does not use CSS-in-JS library for styling – all styles are either in CSS files
or inline in the `style` attribute which does not support nested styles. Mantine does not
use CSS-in-JS to keep bundle size small, provide support for server-side rendering and
improve performance. You can learn more about performance [in the styles performance guide](https://mantine.dev/styles/styles-performance/).",0
eval2_q010,"In Mantine, which styling approach is most performant at runtime, and why?",hnsw_ef50_k15,50,8,0.26187370495528406,7ef91869-2924-444e-b525-47853a46eee3,"Topic: StylesPerformance
Section: Components responsive props

Some components, like [SimpleGrid](https://mantine.dev/core/simple-grid) and [Grid](https://mantine.dev/core/grid)
rely on the same mechanism as responsive style props to apply styles. The limitations are the same
– it is fine to use these several of these components on a page, but it is not recommended to use
them in large lists of components.",0
eval2_q010,"In Mantine, which styling approach is most performant at runtime, and why?",hnsw_ef50_k15,50,9,0.26379151909028886,67164b0b-4201-49d1-9089-e732ebd21531,"Topic: General
Section: I prefer a third-party styles solution, can I use Mantine with it?

All Mantine components are fully compatible with any third-party styling solution and native CSS.
There are two main strategies to apply styles with a third-party library:  
* `className`, `classNames`, `style` and `styles` props
* with static selectors, for example `.mantine-Text-root`  
Example of applying styles with a utility CSS library:  
```tsx
import { TextInput } from '@mantine/core';

function Demo() {
return (
<TextInput
classNames={{
root: 'mt-4',
input: 'bg-red-500 text-white',
}}
/>
);
}
```  
Example of applying styles with global CSS:  
```css
/* styles.css */

/* Note that these styles are not scoped and
will be applied to all TextInput components */
.mantine-TextInput-root {
margin-top: 0.8rem;
}

.mantine-TextInput-input {
background-color: var(--mantine-color-red-filled);
color: var(--mantine-color-white);
}
```  
You can combine both approaches to achieve desired results, for example,
`@emotion/styled` and `styled-components` packages will pass `className` prop to
a given component, and you can use static selectors to style inner elements:  
```tsx
import styled from '@emotion/styled';
import { Slider } from '@mantine/core';

const StyledSlider = styled(Slider)`
& .mantine-Slider-bar {
background-color: var(--mantine-color-pink-5);
}

& .mantine-Slider-thumb {
border-color: var(--mantine-color-pink-5);
background-color: white;
width: 1.5rem;
height: 1.5rem;
}
`;

function Demo() {
return <StyledSlider defaultValue={40} />;
}
```",0
eval2_q010,"In Mantine, which styling approach is most performant at runtime, and why?",hnsw_ef50_k15,50,10,0.2652033543060426,ad47a76f-01db-41a8-a4ec-ce9fce56939c,"Topic: CSSModules
Section: Styling Mantine components without CSS modules

All Mantine components are fully compatible with any third-party styling solution and native CSS.
There are two main strategies to apply styles with a third-party library:  
* `className`, `classNames`, `style` and `styles` props
* with static selectors, for example `.mantine-Text-root`  
Example of applying styles with a utility CSS library:  
```tsx
import { TextInput } from '@mantine/core';

function Demo() {
return (
<TextInput
classNames={{
root: 'mt-4',
input: 'bg-red-500 text-white',
}}
/>
);
}
```  
Example of applying styles with global CSS:  
```css
/* styles.css */

/* Note that these styles are not scoped and
will be applied to all TextInput components */
.mantine-TextInput-root {
margin-top: 0.8rem;
}

.mantine-TextInput-input {
background-color: var(--mantine-color-red-filled);
color: var(--mantine-color-white);
}
```  
You can combine both approaches to achieve desired results, for example,
`@emotion/styled` and `styled-components` packages will pass `className` prop to
a given component, and you can use static selectors to style inner elements:  
```tsx
import styled from '@emotion/styled';
import { Slider } from '@mantine/core';

const StyledSlider = styled(Slider)`
& .mantine-Slider-bar {
background-color: var(--mantine-color-pink-5);
}

& .mantine-Slider-thumb {
border-color: var(--mantine-color-pink-5);
background-color: white;
width: 1.5rem;
height: 1.5rem;
}
`;",0
eval2_q010,"In Mantine, which styling approach is most performant at runtime, and why?",hnsw_ef50_k15,50,11,0.2674175279457741,1af5831f-9460-427d-82a4-b7f4203530aa,"Topic: StylesOverview
Section: Style prop

[Style prop](https://mantine.dev/styles/style/) is supported by all Mantine components and allows setting
CSS properties as well as CSS variables. It is useful in the following cases:  
* You want to apply a single CSS property to a component:  
```tsx
import { Button, Flex } from '@mantine/core';

function Demo() {
return (
<Flex>
<Button style={{ flex: 1 }}>Large button</Button>
<Button>Small button</Button>
</Flex>
);
}
```  
* You want to set a CSS variable based on component prop:  
```tsx
import { Box } from '@mantine/core';

function Demo({ color }: { color: string }) {
// Later you will be able to use var(--my-color) in any nested element
return <Box style={{ '--my-color': color }}>My box</Box>;
}
```  
[Style prop](https://mantine.dev/styles/style/) works the same way as React `style` prop. It is not
recommended to use it as a primary way of styling components. In most cases, it is
better to create a separate file with styles – it will be easier to maintain and
will be more [performant](https://mantine.dev/styles/styles-performance/).",0
eval2_q010,"In Mantine, which styling approach is most performant at runtime, and why?",hnsw_ef50_k15,50,12,0.26950727267009966,72219216-86eb-4591-88db-91b5afae1d40,"Topic: General
Section: Inline styles

If the value that controls dynamic styles is not represented by a known union
of values (for example, value can be any valid CSS color), then you can use
inline styles or [style props](https://mantine.dev/styles/style-props/):  
```tsx
import { Box } from '@mantine/core';

interface DemoProps {
fontFamily: string;
color: string;
}

function Demo({ fontFamily, color }: DemoProps) {
return (
<Box style={{ backgroundColor: color }} ff={fontFamily}>
My demo
</Box>
);
}
```  
If you need to customize a deeply nested element, use [styles](https://mantine.dev/styles/styles-api/#styles-prop)
prop instead:  
```tsx
import { Button } from '@mantine/core';

interface DemoProps {
color: string;
}

function Demo({ color }: DemoProps) {
return (
<Button styles={{ label: { backgroundColor: color } }}>
My demo
</Button>
);
}
```  
Note that, it is not possible use pseudo-classes (for example, `:hover`, `:first-of-type`)
and media queries inside the `styles` prop. For this purpose, use CSS variables
with [classNames](https://mantine.dev/styles/styles-api/#classnames-prop) prop.",0
eval2_q010,"In Mantine, which styling approach is most performant at runtime, and why?",hnsw_ef50_k15,50,13,0.2718082736696028,32b9fde9-aa69-404b-a5f1-66f0ae5ef1ee,"Topic: CSSModules
Section: Overview

# CSS modules  
All Mantine components use CSS modules for styling.
It is recommended to use CSS modules in your project as well, but it is not required –
Mantine components are fully compatible with any third-party styling solution and native CSS.",0
eval2_q010,"In Mantine, which styling approach is most performant at runtime, and why?",hnsw_ef50_k15,50,14,0.2730717099836323,3c20e0d5-01e9-4078-9b34-551ab33124fb,"Topic: General
Section: How Mantine styles work

All `@mantine/*` packages that include styles export `@mantine/*/styles.css`
file which includes all the styles for the package.
These files are handled by your framework/build tool (Next.js, Vite, React Router, etc.)
and included in the final bundle.  
Most of Mantine styles (99%+) have low specificity (class selectors) to allow
easy customization and overrides.",0
eval2_q010,"In Mantine, which styling approach is most performant at runtime, and why?",hnsw_ef50_k15,50,15,0.2754910400931505,9cf2af60-1ad9-49c9-95fa-497049b46875,"Topic: StylesApi
Section: styles prop

The `styles` prop works the same way as `classNames`, but applies inline styles. Note that inline
styles have higher specificity than classes, so you will not be able to override them with classes
without using `!important`. You cannot use pseudo-classes (for example, `:hover`, `:first-of-type`)
and media queries inside the `styles` prop.  
#### Example: styles  
```tsx
import { Button } from '@mantine/core';

function Demo() {
const gradient =
'linear-gradient(45deg, var(--mantine-color-pink-filled) 0%, var(--mantine-color-orange-filled) 50%, var(--mantine-color-yellow-filled) 100%)';

return (
<Button
radius=""md""
styles={{
root: {
padding: 2,
border: 0,
backgroundImage: gradient,
},

inner: {
background: 'var(--mantine-color-body)',
color: 'var(--mantine-color-text)',
borderRadius: 'calc(var(--button-radius) - 2px)',
paddingLeft: 'var(--mantine-spacing-md)',
paddingRight: 'var(--mantine-spacing-md)',
},

label: {
backgroundImage: gradient,
WebkitBackgroundClip: 'text',
WebkitTextFillColor: 'transparent',
},
}}
>
Gradient button
</Button>
);
}
```  
> **styles prop usage**
>
> Some examples and demos in the documentation use the `styles` prop for convenience, but it is not
> recommended to use the `styles` prop as the primary means of styling components, as the `classNames`
> prop is more flexible and has [better performance](https://mantine.dev/styles/styles-performance).",0
eval2_q012,How do I render a stacked BarChart in Mantine Charts with multiple data series?,hnsw_ef50_k15,50,1,0.21316119661681143,60d81541-3f86-4382-92f5-9f559bab9c30,"Topic: BarChart
Section: Stacked bar chart

Set `type=""stacked""` to render a stacked bar chart. In this type of bar chart
stacking is applied along the vertical axis, allowing you to see the overall trend
as well as the contribution of each individual series to the total.  
#### Example: stacked  
```tsx
// Demo.tsx
import { BarChart } from '@mantine/charts';
import { data } from './data';

function Demo() {
return (
<BarChart
h={300}
data={data}
dataKey=""month""
type=""stacked""
series={[
{ name: 'Smartphones', color: 'violet.6' },
{ name: 'Laptops', color: 'blue.6' },
{ name: 'Tablets', color: 'teal.6' },
]}
/>
);
}

// data.ts
export const data = [
{ month: 'January', Smartphones: 1200, Laptops: 900, Tablets: 200 },
{ month: 'February', Smartphones: 1900, Laptops: 1200, Tablets: 400 },
{ month: 'March', Smartphones: 400, Laptops: 1000, Tablets: 200 },
{ month: 'April', Smartphones: 1000, Laptops: 200, Tablets: 800 },
{ month: 'May', Smartphones: 800, Laptops: 1400, Tablets: 1200 },
{ month: 'June', Smartphones: 750, Laptops: 600, Tablets: 1000 },
];
```",3
eval2_q012,How do I render a stacked BarChart in Mantine Charts with multiple data series?,hnsw_ef50_k15,50,2,0.23405003501003463,25a5740f-1e70-4566-8699-fd069992bc21,"Topic: BarChart
Section: Mixed stacked bar chart

You can control how series are stacked by setting `stackId` property in series object:  
#### Example: mixedStack  
```tsx
// Demo.tsx
import { BarChart } from '@mantine/charts';
import { data } from './data';

function Demo() {
return (
<BarChart
h={300}
data={data}
dataKey=""month""
series={[
{ name: 'Smartphones', color: 'violet.6', stackId: 'a' },
{ name: 'Laptops', color: 'blue.6', stackId: 'b' },
{ name: 'Tablets', color: 'teal.6', stackId: 'b' },
]}
/>
);
}

// data.ts
export const data = [
{ month: 'January', Smartphones: 1200, Laptops: 500, Tablets: 800 },
{ month: 'February', Smartphones: 1900, Laptops: 1200, Tablets: 400 },
{ month: 'March', Smartphones: 1800, Laptops: 1000, Tablets: 200 },
{ month: 'April', Smartphones: 1000, Laptops: 200, Tablets: 800 },
{ month: 'May', Smartphones: 800, Laptops: 200, Tablets: 700 },
{ month: 'June', Smartphones: 800, Laptops: 500, Tablets: 200 },
];
```",2
eval2_q012,How do I render a stacked BarChart in Mantine Charts with multiple data series?,hnsw_ef50_k15,50,3,0.24758484331275488,b84e3f18-5aa9-4dfc-93d2-d6780855c536,"Topic: BarChart
Section: Usage

Use `BarChart` component without `type` prop to render a regular bar chart.
In a regular bar chart, each data series is plotted on its own and does
not interact with other series.  
#### Example: usage  
```tsx
// Demo.tsx
import { BarChart } from '@mantine/charts';
import { data } from './data';


function Demo() {
return (
<BarChart
h={300}
data={data}
dataKey=""month""
series={[
{ name: 'Smartphones', color: 'violet.6' },
{ name: 'Laptops', color: 'blue.6' },
{ name: 'Tablets', color: 'teal.6' },
]}

/>
);
}

// data.ts
export const data = [
{ month: 'January', Smartphones: 1200, Laptops: 900, Tablets: 200 },
{ month: 'February', Smartphones: 1900, Laptops: 1200, Tablets: 400 },
{ month: 'March', Smartphones: 400, Laptops: 1000, Tablets: 200 },
{ month: 'April', Smartphones: 1000, Laptops: 200, Tablets: 800 },
{ month: 'May', Smartphones: 800, Laptops: 1400, Tablets: 1200 },
{ month: 'June', Smartphones: 750, Laptops: 600, Tablets: 1000 },
];
```",0
eval2_q012,How do I render a stacked BarChart in Mantine Charts with multiple data series?,hnsw_ef50_k15,50,4,0.24964503031092733,b85003ea-6ecb-4d0e-a341-510ff6854253,"Topic: AreaChart
Section: Stacked area chart

Set `type=""stacked""` to render a stacked area chart. In this type of area chart
stacking is applied along the vertical axis, allowing you to see the overall trend
as well as the contribution of each individual series to the total.  
#### Example: stacked  
```tsx
// Demo.tsx
import { AreaChart } from '@mantine/charts';
import { data } from './data';

function Demo() {
return (
<AreaChart
h={300}
data={data}
dataKey=""date""
type=""stacked""
series={[
{ name: 'Apples', color: 'indigo.6' },
{ name: 'Oranges', color: 'blue.6' },
{ name: 'Tomatoes', color: 'teal.6' },
]}
/>
);
}

// data.ts
export const data = [
{
date: 'Mar 22',
Apples: 2890,
Oranges: 2338,
Tomatoes: 2452,
},
{
date: 'Mar 23',
Apples: 2756,
Oranges: 2103,
Tomatoes: 2402,
},
{
date: 'Mar 24',
Apples: 3322,
Oranges: 986,
Tomatoes: 1821,
},
{
date: 'Mar 25',
Apples: 3470,
Oranges: 2108,
Tomatoes: 2809,
},
{
date: 'Mar 26',
Apples: 3129,
Oranges: 1726,
Tomatoes: 2290,
},
];
```",0
eval2_q012,How do I render a stacked BarChart in Mantine Charts with multiple data series?,hnsw_ef50_k15,50,5,0.2601225027374653,b30ed2e7-0aab-4b38-a080-295d60967518,"Topic: BarChart
Section: Series labels

By default, series `name` is used as a label. To change it, set `label`
property in `series` object:  
#### Example: seriesLabels  
```tsx
// Demo.tsx
import { BarChart } from '@mantine/charts';
import { data } from './data';

function Demo() {
return (
<BarChart
h={300}
data={data}
dataKey=""month""
type=""stacked""
withLegend
legendProps={{ verticalAlign: 'bottom' }}
series={[
{ name: 'Smartphones', label: 'Smartphones sales', color: 'violet.6' },
{ name: 'Laptops', label: 'Laptops sales', color: 'blue.6' },
{ name: 'Tablets', label: 'Tablets sales', color: 'teal.6' },
]}
/>
);
}

// data.ts
export const data = [
{ month: 'January', Smartphones: 1200, Laptops: 900, Tablets: 200 },
{ month: 'February', Smartphones: 1900, Laptops: 1200, Tablets: 400 },
{ month: 'March', Smartphones: 400, Laptops: 1000, Tablets: 200 },
{ month: 'April', Smartphones: 1000, Laptops: 200, Tablets: 800 },
{ month: 'May', Smartphones: 800, Laptops: 1400, Tablets: 1200 },
{ month: 'June', Smartphones: 750, Laptops: 600, Tablets: 1000 },
];
```",1
eval2_q012,How do I render a stacked BarChart in Mantine Charts with multiple data series?,hnsw_ef50_k15,50,6,0.26180347297907236,4dbf268d-228b-4a83-9443-fa2b28448936,"Topic: BarChart
Section: Waterfall bar chart

Set `type=""waterfall""` to render a waterfall bar chart. This chart type illustrates how an
initial value is influenced by subsequent positive or negative values,
with each bar starting where the previous one ended.
Use the `color` prop inside data to color each bar individually. Note that the series color gets overwritten for this specific bar.
Use the `standalone` prop inside data to decouple the bar from the flow.  
#### Example: waterfall  
```tsx
// Demo.tsx
import { BarChart } from '@mantine/charts';
import { data } from './data';


function Demo() {
return (
<BarChart
h={300}
data={data}
dataKey=""item""
type=""waterfall""
series={[{ name: 'Effective tax rate in %', color: 'blue' }]}
withLegend
/>
);
}

// data.ts
export const data =
[
{ item: 'TaxRate', 'Effective tax rate in %': 21, color: 'blue' },
{ item: 'Foreign inc.', 'Effective tax rate in %': -15.5, color: 'teal' },
{ item: 'Perm. diff.', 'Effective tax rate in %': -3, color: 'teal' },
{ item: 'Credits', 'Effective tax rate in %': -3, color: 'teal' },
{ item: 'Loss carryf. ', 'Effective tax rate in %': -2, color: 'teal' },
{ item: 'Law changes', 'Effective tax rate in %': 2, color: 'red' },
{ item: 'Reven. adj.', 'Effective tax rate in %': 4, color: 'red' },
{ item: 'ETR', 'Effective tax rate in %': 3.5, color: 'blue', standalone: true },
];
```",0
eval2_q012,How do I render a stacked BarChart in Mantine Charts with multiple data series?,hnsw_ef50_k15,50,7,0.2639279334293375,792d10f5-5f4f-410b-b833-5b37124a9b8f,"Topic: BarChart
Section: Bar overlays

#### Example: overlay  
```tsx
// Demo.tsx
import { BarChart } from '@mantine/charts';
import classes from './Demo.module.css';
import { data } from './data';

function Demo() {
const bigBarWidth = useMediaQuery('(min-width: 48em)') ? 42 : 26;
const ratio = 0.5;
const smallBarWidth = bigBarWidth * ratio;
const barGap = (bigBarWidth + smallBarWidth) / -2;

return (
<BarChart
h={300}
data={overlayData}
dataKey=""index""
barChartProps={{ barGap }}
barProps={(data) => ({ barSize: data.name === 'you' ? bigBarWidth : smallBarWidth })}
classNames={classes}
series={[
{ name: 'you', color: 'var(--you-bar-color)' },
{ name: 'average', color: 'var(--average-bar-color)' },
]}
/>
);
}

// Demo.module.css
.root {
@mixin light {
--average-bar-color: var(--mantine-color-dark-8);
--you-bar-color: var(--mantine-color-blue-3);
}

@mixin dark {
--you-bar-color: var(--mantine-color-blue-8);
--average-bar-color: var(--mantine-color-gray-4);
}
}

.bar {
transform: translateX(-1.5px);
}",0
eval2_q012,How do I render a stacked BarChart in Mantine Charts with multiple data series?,hnsw_ef50_k15,50,8,0.26591605596582735,5f8912d6-ec41-452d-b161-e2b18c670cd3,"Topic: ScatterChart
Section: Multiple series

#### Example: multipleSeries  
```tsx
// Demo.tsx
import { ScatterChart } from '@mantine/charts';
import { data } from './data';

function Demo() {
return (
<ScatterChart
h={350}
data={data}
dataKey={{ x: 'age', y: 'BMI' }}
xAxisLabel=""Age""
yAxisLabel=""BMI""
/>
);
}

// data.ts
export const data = [
{
color: 'blue.5',
name: 'Group 1',
data: [
{ age: 25, BMI: 20 },
{ age: 30, BMI: 22 },
{ age: 35, BMI: 18 },
{ age: 40, BMI: 25 },
{ age: 45, BMI: 30 },
{ age: 28, BMI: 15 },
{ age: 22, BMI: 12 },
{ age: 50, BMI: 28 },
{ age: 32, BMI: 19 },
{ age: 48, BMI: 31 },
{ age: 26, BMI: 24 },
{ age: 38, BMI: 27 },
{ age: 42, BMI: 29 },
{ age: 29, BMI: 16 },
{ age: 34, BMI: 23 },
{ age: 44, BMI: 33 },
{ age: 23, BMI: 14 },
{ age: 37, BMI: 26 },
{ age: 49, BMI: 34 },
{ age: 27, BMI: 17 },
{ age: 41, BMI: 32 },
{ age: 31, BMI: 21 },
{ age: 46, BMI: 35 },
{ age: 24, BMI: 13 },
{ age: 33, BMI: 22 },
{ age: 39, BMI: 28 },
{ age: 47, BMI: 30 },
{ age: 36, BMI: 25 },
{ age: 43, BMI: 29 },
{ age: 21, BMI: 11 },
],
},
{
color: 'red.5',
name: 'Group 2',
data: [
{ age: 26, BMI: 21 },
{ age: 31, BMI: 24 },
{ age: 37, BMI: 19 },
{ age: 42, BMI: 27 },
{ age: 29, BMI: 32 },
{ age: 35, BMI: 18 },
{ age: 40, BMI: 23 },
{ age: 45, BMI: 30 },
{ age: 27, BMI: 15 },
{ age: 33, BMI: 20 },
{ age: 38, BMI: 25 },
{ age: 43, BMI: 29 },
{ age: 30, BMI: 16 },
{ age: 36, BMI: 22 },
{ age: 41, BMI: 28 },
{ age: 46, BMI: 33 },
{ age: 28, BMI: 17 },
{ age: 34, BMI: 22 },
{ age: 39, BMI: 26 },
{ age: 44, BMI: 31 },
{ age: 32, BMI: 18 },
{ age: 38, BMI: 23 },
{ age: 43, BMI: 28 },
{ age: 48, BMI: 35 },
{ age: 25, BMI: 14 },
{ age: 31, BMI: 20 },
{ age: 36, BMI: 25 },
{ age: 41, BMI: 30 },
{ age: 29, BMI: 16 },
],
},
];
```",0
eval2_q012,How do I render a stacked BarChart in Mantine Charts with multiple data series?,hnsw_ef50_k15,50,9,0.2661970500312001,b745d311-808a-4cd3-a165-dffec784026d,"Topic: BarChart
Section: Vertical orientation

Set `orientation=""vertical""` to render a vertical bar chart:  
#### Example: vertical  
```tsx
// Demo.tsx
import { BarChart } from '@mantine/charts';
import { data } from './data';

function Demo() {
return (
<BarChart
h={300}
data={data}
dataKey=""month""
type=""stacked""
orientation=""vertical""
yAxisProps={{ width: 80 }}
series={[
{ name: 'Smartphones', color: 'violet.6' },
{ name: 'Laptops', color: 'blue.6' },
{ name: 'Tablets', color: 'teal.6' },
]}
/>
);
}

// data.ts
export const data = [
{ month: 'January', Smartphones: 1200, Laptops: 900, Tablets: 200 },
{ month: 'February', Smartphones: 1900, Laptops: 1200, Tablets: 400 },
{ month: 'March', Smartphones: 400, Laptops: 1000, Tablets: 200 },
{ month: 'April', Smartphones: 1000, Laptops: 200, Tablets: 800 },
{ month: 'May', Smartphones: 800, Laptops: 1400, Tablets: 1200 },
{ month: 'June', Smartphones: 750, Laptops: 600, Tablets: 1000 },
];
```",1
eval2_q012,How do I render a stacked BarChart in Mantine Charts with multiple data series?,hnsw_ef50_k15,50,10,0.27207622514964513,84093d98-4f09-4a97-88c4-8b9ad8ac013a,"Topic: BarChart
Section: Percent bar chart

Set `type=""percent""` to render a percent bar chart. In this type of bar chart
the y-axis scale is always normalized to 100%, making it easier to compare the
contribution of each series in terms of percentages.  
#### Example: percent  
```tsx
// Demo.tsx
import { BarChart } from '@mantine/charts';
import { data } from './data';

function Demo() {
return (
<BarChart
h={300}
data={data}
dataKey=""month""
type=""percent""
series={[
{ name: 'Smartphones', color: 'violet.6' },
{ name: 'Laptops', color: 'blue.6' },
{ name: 'Tablets', color: 'teal.6' },
]}
/>
);
}

// data.ts
export const data = [
{ month: 'January', Smartphones: 1200, Laptops: 900, Tablets: 200 },
{ month: 'February', Smartphones: 1900, Laptops: 1200, Tablets: 400 },
{ month: 'March', Smartphones: 400, Laptops: 1000, Tablets: 200 },
{ month: 'April', Smartphones: 1000, Laptops: 200, Tablets: 800 },
{ month: 'May', Smartphones: 800, Laptops: 1400, Tablets: 1200 },
{ month: 'June', Smartphones: 750, Laptops: 600, Tablets: 1000 },
];
```",0
eval2_q012,How do I render a stacked BarChart in Mantine Charts with multiple data series?,hnsw_ef50_k15,50,11,0.27341189132372723,2ec4ede0-f618-4d62-9a84-035dbc60f0fd,"Topic: BarChart
Section: SVG pattern as bar fill

You can use SVG patterns as bar fill. To do so, set `fill` property in series object to
a url of the SVG pattern that is defined in the `defs` section of the chart `children`.  
Example of using diagonal stripes and crosshatch patterns as bar fill:  
#### Example: stripes  
```tsx
// Demo.tsx
import { BarChart } from '@mantine/charts';
import { data } from './data';

function Demo() {
return (
<BarChart
h={300}
data={mixedStackData}
dataKey=""month""
series={[
{ name: 'Smartphones', color: 'url(#crosshatch)', stackId: 'a' },
{ name: 'Laptops', color: 'blue.6', stackId: 'b' },
{ name: 'Tablets', color: 'url(#diagonalStripes)', stackId: 'b' },
]}
>
<defs>
<pattern
id=""diagonalStripes""
patternUnits=""userSpaceOnUse""
width={6}
height={8}
patternTransform=""rotate(45)""
>
<rect
width=""2""
height=""8""
transform=""translate(0,0)""
fill=""color-mix(in lch, var(--mantine-color-teal-6) 70%, rgba(0,0,0,0))""
/>
</pattern>

<pattern id=""crosshatch"" patternUnits=""userSpaceOnUse"" width={8} height={8}>
<path
d=""M 0 0 L 8 0 L 8 8 L 0 8 Z""
fill=""none""
stroke=""color-mix(in lch, var(--mantine-color-indigo-6) 70%, rgba(0,0,0,0))""
strokeWidth=""1""
/>
<path
d=""M 0 0 L 8 8""
stroke=""color-mix(in lch, var(--mantine-color-indigo-6) 70%, rgba(0,0,0,0))""
strokeWidth=""1""
/>
<path
d=""M 8 0 L 0 8""
stroke=""color-mix(in lch, var(--mantine-color-indigo-6) 70%, rgba(0,0,0,0))""
strokeWidth=""1""
/>
</pattern>
</defs>
</BarChart>
);
}

// data.ts
export const data = [
{ month: 'January', Smartphones: 1200, Laptops: 500, Tablets: 800 },
{ month: 'February', Smartphones: 1900, Laptops: 1200, Tablets: 400 },
{ month: 'March', Smartphones: 1800, Laptops: 1000, Tablets: 200 },
{ month: 'April', Smartphones: 1000, Laptops: 200, Tablets: 800 },
{ month: 'May', Smartphones: 800, Laptops: 200, Tablets: 700 },
{ month: 'June', Smartphones: 800, Laptops: 500, Tablets: 200 },
];
```",0
eval2_q012,How do I render a stacked BarChart in Mantine Charts with multiple data series?,hnsw_ef50_k15,50,12,0.2746908585405604,850729c9-2160-4edc-942e-abcbd746af21,"Topic: RadarChart
Section: Multiple series

You can display multiple series on the same radar chart:  
#### Example: multiple  
```tsx
// Demo.tsx
import { RadarChart } from '@mantine/charts';
import { data } from './data';

function Demo() {
return (
<RadarChart
h={300}
data={data}
dataKey=""product""
withPolarRadiusAxis
series={[
{ name: 'Sales January', color: 'lime.4', opacity: 0.1 },
{ name: 'Sales February', color: 'cyan.4', opacity: 0.1 },
]}
/>
);
}

// data.ts
export const data = [
{
product: 'Apples',
'Sales January': 120,
'Sales February': 100,
},
{
product: 'Oranges',
'Sales January': 98,
'Sales February': 90,
},
{
product: 'Tomatoes',
'Sales January': 86,
'Sales February': 70,
},
{
product: 'Grapes',
'Sales January': 99,
'Sales February': 80,
},
{
product: 'Bananas',
'Sales January': 85,
'Sales February': 120,
},
{
product: 'Lemons',
'Sales January': 65,
'Sales February': 150,
},
];
```",0
eval2_q012,How do I render a stacked BarChart in Mantine Charts with multiple data series?,hnsw_ef50_k15,50,13,0.27705995990036725,40bdbbda-d9d2-4304-99d7-84f17405a811,"Topic: CompositeChart
Section: Usage

`CompositeChart` allows using `Line`, `Area` and `Bar` charts together in a single
chart:  
#### Example: usage  
```tsx
// Demo.tsx
import { CompositeChart } from '@mantine/charts';
import { data } from './data';


function Demo() {
return (
<CompositeChart
h={300}
data={data}
dataKey=""date""
maxBarWidth={30}
series={[
{ name: 'Tomatoes', color: 'rgba(18, 120, 255, 0.2)', type: 'bar' },
{ name: 'Apples', color: 'red.8', type: 'line' },
{ name: 'Oranges', color: 'yellow.8', type: 'area' },
]}

/>
);
}

// data.ts
export const data = [
{
date: 'Mar 22',
Apples: 2890,
Oranges: 2338,
Tomatoes: 2452,
},
{
date: 'Mar 23',
Apples: 2756,
Oranges: 2103,
Tomatoes: 2402,
},
{
date: 'Mar 24',
Apples: 3322,
Oranges: 986,
Tomatoes: 1821,
},
{
date: 'Mar 25',
Apples: 3470,
Oranges: 2108,
Tomatoes: 2809,
},
{
date: 'Mar 26',
Apples: 3129,
Oranges: 1726,
Tomatoes: 2290,
},
];
```",0
eval2_q012,How do I render a stacked BarChart in Mantine Charts with multiple data series?,hnsw_ef50_k15,50,14,0.28399082907777506,87d80993-c23f-45c8-9b83-00eff6ebedf3,"Topic: BarChart
Section: Legend

To display chart legend, set `withLegend` prop. When one of the items in the legend
is hovered, the corresponding data series is highlighted in the chart.  
#### Example: legend  
```tsx
// Demo.tsx
import { BarChart } from '@mantine/charts';
import { data } from './data';

function Demo() {
return (
<BarChart
h={300}
data={data}
dataKey=""month""
withLegend
series={[
{ name: 'Smartphones', color: 'violet.6' },
{ name: 'Laptops', color: 'blue.6' },
{ name: 'Tablets', color: 'teal.6' },
]}
/>
);
}

// data.ts
export const data = [
{ month: 'January', Smartphones: 1200, Laptops: 900, Tablets: 200 },
{ month: 'February', Smartphones: 1900, Laptops: 1200, Tablets: 400 },
{ month: 'March', Smartphones: 400, Laptops: 1000, Tablets: 200 },
{ month: 'April', Smartphones: 1000, Laptops: 200, Tablets: 800 },
{ month: 'May', Smartphones: 800, Laptops: 1400, Tablets: 1200 },
{ month: 'June', Smartphones: 750, Laptops: 600, Tablets: 1000 },
];
```",0
eval2_q012,How do I render a stacked BarChart in Mantine Charts with multiple data series?,hnsw_ef50_k15,50,15,0.2874141345882638,988039c4-07e2-499d-b96c-834e6e2d70e6,"Topic: BarChart
Section: Bar overlays

// data.ts
export const data = [
{ you: 5, average: 3, index: '1' },
{ you: 7, average: 9, index: '2' },
{ you: 8, average: 5, index: '3' },
{ you: 3, average: 6, index: '4' },
{ you: 2, average: 4, index: '5' },
{ you: 6, average: 8, index: '6' },
{ you: 4, average: 7, index: '7' },
{ you: 9, average: 2, index: '8' },
];
```  
#### Props  
| Prop | Type | Default | Description |
|------|------|---------|-------------|
| barChartProps | Omit<CategoricalChartProps & RefAttributes<{ readonly eventEmitterSymbol: Symbol; clipPathId: string; accessibilityManager: AccessibilityManager; ... 65 more ...; UNSAFE_componentWillUpdate?(nextProps: Readonly<...>, nextState: Readonly<...>, nextContext: any): void; }>, ""ref""> | - | Props passed down to recharts <code>BarChart</code> component |
| barLabelColor | MantineColor | - | Controls color of the bar label, by default the value is determined by the chart orientation |
| barProps | ((series: BarChartSeries) => Partial<Omit<Props, ""ref"">>) | Partial<Omit<Props, ""ref"">> | - | Props passed down to recharts <code>Bar</code> component |
| children | React.ReactNode | - | Additional components that are rendered inside recharts <code>BarChart</code> component |
| cursorFill | MantineColor | - | Fill of hovered bar section, by default value is based on color scheme |
| data | Record<string, any>[] | required | Data used to display chart. |
| dataKey | string | required | Key of the <code>data</code> object for x-axis values |
| fillOpacity | number | - | Controls fill opacity of all bars |
| getBarColor | (value: number, series: BarChartSeries) => DefaultMantineColor | - | A function to assign dynamic bar color based on its value |
| gridAxis | ""none"" | ""x"" | ""y"" | ""xy"" | - | Specifies which lines should be displayed in the grid, <code>'x'</code> by default |
| gridColor | MantineColor | - | Color of the grid and cursor lines, by default depends on color scheme |
| gridProps | RechartsProps | - | Props passed down to the",0
eval2_q014,"Does Mantine provide a built-in way to synchronize state across browser tabs (e.g., theme/color scheme), and how do I use it?",hnsw_ef50_k15,50,1,0.2046342870497485,4db4e952-7f1b-4e40-ae74-f7db9242265d,"Topic: useLocalStorage
Section: Browser tabs synchronization

`use-local-storage` subscribes to [storage event](https://developer.mozilla.org/en-US/docs/Web/API/Window/storage_event).
When state changes in one tab, it automatically updates the value in all other opened browser tabs.
You can test this feature by opening 2 tabs with Mantine docs side by side and changing the color scheme
(button on the top right or `⌘ + J` on MacOS and `Ctrl + J` on Windows and Linux).",2
eval2_q014,"Does Mantine provide a built-in way to synchronize state across browser tabs (e.g., theme/color scheme), and how do I use it?",hnsw_ef50_k15,50,2,0.28305255228724713,741197d5-808f-4951-a069-c6b4d9eed475,"Topic: ColorSchemes
Section: Color scheme manager

return {
get: (defaultValue) => {
if (typeof window === 'undefined') {
return defaultValue;
}

try {
return (
(window.localStorage.getItem(key) as MantineColorScheme) ||
defaultValue
);
} catch {
return defaultValue;
}
},

set: (value) => {
try {
window.localStorage.setItem(key, value);
} catch (error) {
// eslint-disable-next-line no-console
console.warn(
'[@mantine/core] Local storage color scheme manager was unable to save color scheme.',
error
);
}
},

subscribe: (onUpdate) => {
handleStorageEvent = (event) => {
if (
event.storageArea === window.localStorage &&
event.key === key
) {
isMantineColorScheme(event.newValue) &&
onUpdate(event.newValue);
}
};

window.addEventListener('storage', handleStorageEvent);
},

unsubscribe: () => {
window.removeEventListener('storage', handleStorageEvent);
},

clear: () => {
window.localStorage.removeItem(key);
},
};
}
```  
Then custom color scheme manager can be passed to [MantineProvider](https://mantine.dev/theming/mantine-provider):  
```tsx
import { MantineProvider } from '@mantine/core';
import { localStorageColorSchemeManager } from './localStorageColorSchemeManager';

const colorSchemeManager = localStorageColorSchemeManager({
key: 'my-color-scheme',
});

function Demo() {
return (
<MantineProvider colorSchemeManager={colorSchemeManager}>
{/* Your app here */}
</MantineProvider>
);
}
```",3
eval2_q014,"Does Mantine provide a built-in way to synchronize state across browser tabs (e.g., theme/color scheme), and how do I use it?",hnsw_ef50_k15,50,3,0.2867586937169416,675d4cba-344d-40fb-80d3-59c60b349380,"Topic: ColorSchemes
Section: Color scheme manager

By default, color scheme value is stored in local storage, but you can implement your own
color scheme manager to store the value in any other external storage.  
Color scheme manager must have the following methods:  
```tsx
interface MantineColorSchemeManager {
/** Function to retrieve color scheme value from external storage, for example window.localStorage */
get: (defaultValue: MantineColorScheme) => MantineColorScheme;

/** Function to set color scheme value in external storage, for example window.localStorage */
set: (value: MantineColorScheme) => void;

/** Function to subscribe to color scheme changes triggered by external events */
subscribe: (
onUpdate: (colorScheme: MantineColorScheme) => void
) => void;

/** Function to unsubscribe from color scheme changes triggered by external events */
unsubscribe: () => void;

/** Function to clear value from external storage */
clear: () => void;
}
```  
Usually, it is better to wrap color scheme manager in a creator function to provide a way to
configure it. Default local storage based color scheme manager example:  
```tsx
import {
isMantineColorScheme,
MantineColorScheme,
MantineColorSchemeManager,
} from '@mantine/core';

export interface LocalStorageColorSchemeManagerOptions {
/** Local storage key used to retrieve value with `localStorage.getItem(key)`, `mantine-color-scheme` by default */
key?: string;
}

export function localStorageColorSchemeManager({
key = 'mantine-color-scheme',
}: LocalStorageColorSchemeManagerOptions = {}): MantineColorSchemeManager {
let handleStorageEvent: (event: StorageEvent) => void;

return {
get: (defaultValue) => {
if (typeof window === 'undefined') {
return defaultValue;
}

try {
return (
(window.localStorage.getItem(key) as MantineColorScheme) ||
defaultValue
);
} catch {
return defaultValue;
}
},",1
eval2_q014,"Does Mantine provide a built-in way to synchronize state across browser tabs (e.g., theme/color scheme), and how do I use it?",hnsw_ef50_k15,50,4,0.29090021557529344,9de06d5c-d367-4e9a-86d6-8d607a2c84c4,"Topic: MantineProvider
Section: colorSchemeManager

`colorSchemeManager` is used to retrieve and set color scheme value in external storage. By default,
`MantineProvider` uses `window.localStorage` to store color scheme value, but you can pass your own
implementation to `colorSchemeManager` prop. You can learn more about color scheme management in the
[color schemes guide](https://mantine.dev/theming/color-schemes).  
```tsx
import {
localStorageColorSchemeManager,
MantineProvider,
} from '@mantine/core';

const colorSchemeManager = localStorageColorSchemeManager({
key: 'my-app-color-scheme',
});

function Demo() {
return (
<MantineProvider colorSchemeManager={colorSchemeManager}>
{/* Your app here */}
</MantineProvider>
);
}
```",0
eval2_q014,"Does Mantine provide a built-in way to synchronize state across browser tabs (e.g., theme/color scheme), and how do I use it?",hnsw_ef50_k15,50,5,0.291528031024907,e081e040-3381-40e1-a57a-ba3eef40f0c5,"Topic: ColorSchemes
Section: Color scheme value caveats

By default, the color scheme value is stored in local storage, and its value is saved in state
before the component is mounted to avoid flash of inaccurate color scheme. This means that
color scheme value can be different on client and server, as server does not have access
to local storage and always uses the default value.  
If you have server side rendering in your application (for example, if you use [Next.js](https://mantine.dev/guides/next) or [React Router](https://mantine.dev/guides/react-router)), then you cannot use `colorScheme`
value in your application to avoid hydration issues. Instead, you can use `dark` and `light`
mixins from [postcss-preset-mantine](https://mantine.dev/styles/postcss-preset) to generate styles that will
hide elements based on color scheme value:  
#### Example: colorSchemeControl  
```tsx
import { ActionIcon, useMantineColorScheme, useComputedColorScheme } from '@mantine/core';
import { IconSun, IconMoon } from '@tabler/icons-react';
import cx from 'clsx';
import classes from './Demo.module.css';

function Demo() {
const { setColorScheme } = useMantineColorScheme();
const computedColorScheme = useComputedColorScheme('light', { getInitialValueInEffect: true });

return (
<ActionIcon
onClick={() => setColorScheme(computedColorScheme === 'light' ? 'dark' : 'light')}
variant=""default""
size=""xl""
aria-label=""Toggle color scheme""
>
<IconSun className={cx(classes.icon, classes.light)} stroke={1.5} />
<IconMoon className={cx(classes.icon, classes.dark)} stroke={1.5} />
</ActionIcon>
);
}
```  
> **colorScheme for client only applications**
>
> You can safely use `colorScheme` value in client only applications (for example, Vite or create-react-app applications).
> In this case, there is no hydration, and thus hydration error cannot occur.",0
eval2_q014,"Does Mantine provide a built-in way to synchronize state across browser tabs (e.g., theme/color scheme), and how do I use it?",hnsw_ef50_k15,50,6,0.2956174316897002,633483d7-2117-4a20-9e30-296f2e12171c,"Topic: General
Section: Get color scheme value in component

To get color scheme value in component use `useMantineColorScheme` hook:  
```tsx
import { useMantineColorScheme } from '@mantine/core';

function Demo() {
// colorScheme is `'dark' | 'light' | 'auto'`
const { colorScheme } = useMantineColorScheme();
}
```  
If you want to get computed color scheme, use `useComputedColorScheme` hook instead.
It will resolve `auto` value to `dark` or `light` based on user preferences:  
```tsx
import { useComputedColorScheme } from '@mantine/core';

function Demo() {
// colorScheme is `'dark' | 'light'`
const colorScheme = useComputedColorScheme();
}
```  
Note that both hooks are using `localStorage` to store color scheme value.
It is not possible to get color scheme value on the server side – the value
will always fallback to `light` during SSR.",0
eval2_q014,"Does Mantine provide a built-in way to synchronize state across browser tabs (e.g., theme/color scheme), and how do I use it?",hnsw_ef50_k15,50,7,0.29591963578109837,d070dc0b-d315-47cb-915d-de5ef5f9eec1,"Topic: General
Section: Can I get color scheme value in JavaScript?

If your application does not have server-side rendering, you can get color scheme value
with `useMantineColorScheme` hook:  
```tsx
import { useMantineColorScheme } from '@mantine/core';

function MyComponent() {
const { colorScheme } = useMantineColorScheme();

// ✅ Works in Vite and other client-side bundlers/frameworks
// ❌ Hydration mismatch in Next.js, React Router, and other server-side rendering frameworks
return <div>Color scheme is {colorScheme}</div>;
}
```  
If you have server-side rendering in your application (Next.js, React Router, etc.), you should
not rely on JavaScript to get color scheme value – conditional rendering based on color
scheme value will produce hydration mismatch. In this case, the only option is to use
styles to hide/show elements based on the color scheme value.",0
eval2_q014,"Does Mantine provide a built-in way to synchronize state across browser tabs (e.g., theme/color scheme), and how do I use it?",hnsw_ef50_k15,50,8,0.2971810582805381,e78c0722-8239-4301-8c30-8c5afa03303b,"Topic: useLocalStorage
Section: Example

Example of a color scheme toggle button that uses `use-local-storage` hook
to store current color scheme in the `localStorage`:  
```tsx
import { IconMoonStars, IconSun } from '@tabler/icons-react';
import { ActionIcon } from '@mantine/core';
import { useLocalStorage } from '@mantine/hooks';

function ColorSchemeToggle() {
const [colorScheme, setColorScheme] = useLocalStorage<
'light' | 'dark'
>({
key: 'color-scheme',
defaultValue: 'light',
});

const toggleColorScheme = () =>
setColorScheme((current) =>
current === 'dark' ? 'light' : 'dark'
);

return (
<ActionIcon onClick={toggleColorScheme}>
{colorScheme === 'dark' ? <IconSun /> : <IconMoonStars />}
</ActionIcon>
);
}
```",1
eval2_q014,"Does Mantine provide a built-in way to synchronize state across browser tabs (e.g., theme/color scheme), and how do I use it?",hnsw_ef50_k15,50,9,0.30113543210410554,cb6ca235-a88b-4fe3-9ea9-77082042b64d,"Topic: useLocalStorage
Section: Usage

`use-local-storage` allows using value from the `localStorage` as react state.
The hook works the same way as `useState`, but also writes the value to the `localStorage`:  
```tsx
import { useLocalStorage } from '@mantine/hooks';

// The hook will read value from localStorage.getItem('color-scheme')
// If localStorage is not available or value at a given key does not exist
// 'dark' will be assigned to value variable
const [value, setValue] = useLocalStorage({
key: 'color-scheme',
defaultValue: 'dark',
});

// Value is set both to state and localStorage at 'color-scheme'
setValue('light');

// You can also use callback like in useState hook to set value
setValue((current) => (current === 'dark' ? 'light' : 'dark'));
```",1
eval2_q014,"Does Mantine provide a built-in way to synchronize state across browser tabs (e.g., theme/color scheme), and how do I use it?",hnsw_ef50_k15,50,10,0.304537985440564,ddf687f1-ebf1-408d-bd5b-b38a466718ef,"Topic: MantineProvider
Section: Overview

# MantineProvider  
`MantineProvider` provides a [theme object](https://mantine.dev/theming/theme-object) context value, manages color scheme
changes and injects [CSS variables](https://mantine.dev/styles/css-variables/). It must be rendered at the root of your
application and should be used only once.",0
eval2_q014,"Does Mantine provide a built-in way to synchronize state across browser tabs (e.g., theme/color scheme), and how do I use it?",hnsw_ef50_k15,50,11,0.3052845646331047,e2c32976-a65f-4ca4-b283-eea848a95aec,"Topic: General
Section: Get color scheme value outside of component

To get color scheme value outside of component, create an utility function
that will parse color scheme value from `data-mantine-color-scheme` attribute:  
```tsx
import { MantineColorScheme } from '@mantine/core';

export function getColorScheme() {
return document.documentElement.getAttribute(
'data-mantine-color-scheme'
) as MantineColorScheme;
}
```  
Then use it in any place of your application:  
```tsx
import { getColorScheme } from './getColorScheme';

const colorScheme = getColorScheme();
```  
Note that this approach will not work on the server side.",0
eval2_q014,"Does Mantine provide a built-in way to synchronize state across browser tabs (e.g., theme/color scheme), and how do I use it?",hnsw_ef50_k15,50,12,0.30751687036136455,4b912ed6-5db9-46f6-ba39-340b04dc8cb4,"Topic: General
Section: Overview

# use-local-storage hook returns real value only after mounting, is it a bug?
Learn how Mantine retrieves local storage value",0
eval2_q014,"Does Mantine provide a built-in way to synchronize state across browser tabs (e.g., theme/color scheme), and how do I use it?",hnsw_ef50_k15,50,13,0.3106758048394316,e3e9768f-ebdb-44ab-8559-5b977c114fe8,"Topic: Tabs
Section: Usage with Next.js router

```tsx
// For file /tabs/[activeTab].tsx
import { useRouter } from 'next/router';
import { Tabs } from '@mantine/core';

function Demo() {
const router = useRouter();

return (
<Tabs
value={router.query.activeTab as string}
onChange={(value) => router.push(`/tabs/${value}`)}
>
<Tabs.List>
<Tabs.Tab value=""first"">First tab</Tabs.Tab>
<Tabs.Tab value=""second"">Second tab</Tabs.Tab>
</Tabs.List>
</Tabs>
);
}
```  
#### Example: stylesApi  
```tsx
import { Tabs } from '@mantine/core';

function Demo() {
return (
<Tabs defaultValue=""gallery"">
<Tabs.List>
<Tabs.Tab value=""gallery"" leftSection={<IconPhoto size={12} />}>
Gallery
</Tabs.Tab>
<Tabs.Tab value=""messages"" leftSection={<IconMessageCircle size={12} />}>
Messages
</Tabs.Tab>
<Tabs.Tab value=""settings"" rightSection={<IconSettings size={12} />}>
Settings
</Tabs.Tab>
</Tabs.List>

<Tabs.Panel value=""gallery"" pt=""xs"">
Gallery tab content
</Tabs.Panel>

<Tabs.Panel value=""messages"" pt=""xs"">
Messages tab content
</Tabs.Panel>

<Tabs.Panel value=""settings"" pt=""xs"">
Settings tab content
</Tabs.Panel>
</Tabs>
);
}
```  
Example of Styles API usage to customize tab styles:  
#### Example: customize  
```tsx
// Demo.module.css
.tab {
position: relative;
border: 1px solid light-dark(var(--mantine-color-gray-2), var(--mantine-color-dark-4));
background-color: light-dark(var(--mantine-color-white), var(--mantine-color-dark-6));

&:first-of-type {
border-radius: 4px 0 0 4px;

@mixin rtl {
border-radius: 0 4px 4px 0;
}
}

&:last-of-type {
border-radius: 0 4px 4px 0;

@mixin rtl {
border-radius: 4px 0 0 4px;
}
}

& + & {
border-left-width: 0;

@mixin rtl {
border-right-width: 0;
border-left-width: 1px;
}
}

@mixin hover {
background-color: light-dark(var(--mantine-color-gray-0), var(--mantine-color-dark-5));
}

&[data-active] {
z-index: 1;
background-color: var(--mantine-color-blue-filled);
border-color: var(--mantine-color-blue-filled);
color: var(--mantine-color-white);",0
eval2_q014,"Does Mantine provide a built-in way to synchronize state across browser tabs (e.g., theme/color scheme), and how do I use it?",hnsw_ef50_k15,50,14,0.3106785343596882,0d617a60-7a2f-443a-8757-5bba1557bc84,"Topic: ColorSchemes
Section: Overview

# Color schemes  
[MantineProvider](https://mantine.dev/theming/mantine-provider/) manages color scheme context in your application.
You can configure the default color scheme value with `defaultColorScheme` prop, possible values are `light`,
`dark` and `auto` (system color scheme is used). The default value is `light`.  
```tsx
import { MantineProvider } from '@mantine/core';

function Demo() {
return (
<MantineProvider defaultColorScheme=""dark"">
{/* Your app here */}
</MantineProvider>
);
}
```",0
eval2_q014,"Does Mantine provide a built-in way to synchronize state across browser tabs (e.g., theme/color scheme), and how do I use it?",hnsw_ef50_k15,50,15,0.3120802700521551,99d1d5a1-d250-4950-8c7b-0834488a484a,"Topic: General
Section: Overview

# How can I get current color scheme value in JavaScript?
How to use useMantineColorScheme and useComputedColorScheme hooks to get current color scheme value in JavaScript",0
